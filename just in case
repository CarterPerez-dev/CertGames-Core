Below is a complete approach for adding a Daily Bonus (per user) and a Daily Question of the Day (global, but each user can answer individually) to your site. The user can claim a daily coin bonus (1000 coins every 24 hours) and see a cybersecurity PBQ question that changes every 24 hours for everyone. Each user can only answer once per day. If correct, they get 250 coins; if wrong, 50 coins—but the question itself is the same for all users.

We’ll outline:

Database Model: How to store daily questions and keep track of user answers.
Backend Routes:
GET /daily-question returns today’s question.
POST /daily-question/answer processes the user’s attempt.
Frontend: A single DailyStationPage.js that has both the daily bonus + daily question.
Daily Cron or Logic**: So that each day, the question automatically increments.
You already have daily bonus logic in "/user/<user_id>/daily-bonus". We’ll keep that as-is, just integrate it into the new “Daily Station.”

1) Database Setup and Logic
Daily Questions Storage
Create a dailyQuestions collection with docs like:

json
Copy
Edit
{
  "_id": ObjectId(...),
  "dayIndex": 0,
  "prompt": "Pretend this is a big PBQ scenario about server logs…",
  "options": [
    "Choice A",
    "Choice B",
    "Choice C",
    "Choice D"
  ],
  "correctIndex": 2
}
dayIndex is an integer from 0..99 for your 100 PBQ questions.
You can add fields like explanation, imageUrl, etc.
Determining the “Question of the Day”
A simple approach:
Pick a “startDate” (like 2023-01-01T00:00:00Z).
Each day, the “day index” is (today - startDate) // 1 day. For example, if 30 days have passed, dayIndex = 30.
Then fetch dailyQuestions doc where dayIndex = dayIndex mod totalDocuments if you want it to cycle. Or just do dayIndex directly if you have enough docs.
Alternatively, store a single doc with “today’s index = N.” At midnight, increment N by 1.
Tracking Per-User Answers
In your testAnswers_collection or a new dailyAnswers collection, you store:
json
Copy
Edit
{
  "_id": ObjectId(...),
  "userId": ObjectId(...),
  "dayIndex": 37,
  "answeredAt": ISODate("2023-10-12T10:00:00Z"),
  "isCorrect": true
}
Then you can prevent multiple attempts by the same user on the same day.

2) Backend Routes
For simplicity, we’ll add two routes in your existing test_routes.py. Or you can create a new daily_routes.py.

2.1) GET /daily-question
Returns something like:

json
Copy
Edit
{
  "dayIndex": 37,
  "prompt": "PBQ scenario goes here",
  "options": ["Choice A","Choice B","Choice C","Choice D"],
  "alreadyAnswered": false,   // or true if user answered
  "userAnswer": null          // or the user’s saved answer
}
Code:

python
Copy
Edit
# In test_routes.py
from datetime import datetime, timedelta
import math
import pytz

@api_bp.route('/daily-question', methods=['GET'])
def get_daily_question():
    """
    1) Compute today's dayIndex.
    2) Find that doc in dailyQuestions.
    3) Check if user has answered.
    4) Return question + whether user answered.
    """
    user_id = request.args.get("userId")  # or from token.  We'll assume we pass userId=? 
    if not user_id:
        return jsonify({"error": "No userId provided"}), 400
    
    # Convert to ObjectId
    try:
        user_oid = ObjectId(user_id)
    except:
        return jsonify({"error": "Invalid user ID"}), 400

    # 1) dayIndex calculation example:
    # Let's define a start date:
    start_date = datetime(2023, 1, 1, tzinfo=pytz.UTC)
    now_utc = datetime.utcnow().replace(tzinfo=pytz.UTC)
    diff_days = (now_utc - start_date).days  # integer difference in days
    day_index = diff_days  # or day_index = diff_days % 100 if you want to cycle

    # 2) Find the doc in dailyQuestions
    daily_doc = db.dailyQuestions.find_one({"dayIndex": day_index})
    if not daily_doc:
        return jsonify({"error": "No daily question for dayIndex="+str(day_index)}), 404

    # 3) Check if user has answered:
    existing_answer = db.dailyAnswers.find_one({
        "userId": user_oid,
        "dayIndex": day_index
    })
    
    already_answered = existing_answer is not None
    user_answer_index = None
    if already_answered:
        user_answer_index = existing_answer.get("userAnswerIndex")

    # 4) Return
    resp = {
        "dayIndex": day_index,
        "prompt": daily_doc["prompt"],
        "options": daily_doc["options"],
        "alreadyAnswered": already_answered,
        "userAnswer": user_answer_index
    }
    return jsonify(resp), 200
2.2) POST /daily-question/answer
Accepts:

{ userId, dayIndex, selectedIndex }
We check if that user has answered today.
If not answered, compare to dailyDoc.correctIndex.
If correct => +250 coins
If not => +50 coins
Code:

python
Copy
Edit
@api_bp.route('/daily-question/answer', methods=['POST'])
def submit_daily_question():
    data = request.json or {}
    user_id = data.get("userId")
    day_index = data.get("dayIndex")
    selected_index = data.get("selectedIndex")

    if user_id is None or day_index is None or selected_index is None:
        return jsonify({"error": "Missing userId, dayIndex, or selectedIndex"}), 400

    try:
        user_oid = ObjectId(user_id)
    except:
        return jsonify({"error": "Invalid user ID"}), 400

    # fetch the daily doc
    daily_doc = db.dailyQuestions.find_one({"dayIndex": day_index})
    if not daily_doc:
        return jsonify({"error": "No daily question found for dayIndex="+str(day_index)}), 404

    # Check if user already answered
    existing = db.dailyAnswers.find_one({
        "userId": user_oid,
        "dayIndex": day_index
    })
    if existing:
        return jsonify({"error": "You already answered today's question"}), 400

    # Evaluate correctness
    correct_index = daily_doc.get("correctIndex", 0)
    is_correct = (selected_index == correct_index)

    # Award coins
    award_coins = 250 if is_correct else 50

    # Insert into dailyAnswers
    db.dailyAnswers.insert_one({
        "userId": user_oid,
        "dayIndex": day_index,
        "answeredAt": datetime.utcnow(),
        "userAnswerIndex": selected_index,
        "isCorrect": is_correct
    })

    # Update user’s coin total:
    from models.test import update_user_coins
    update_user_coins(user_id, award_coins)

    return jsonify({
        "message": "Answer submitted",
        "correct": is_correct,
        "awardedCoins": award_coins
    }), 200
3) Front-End: DailyStationPage.js
We can expand the “DailyStationPage” from previous answer to include the question of the day. For example:

jsx
Copy
Edit
// DailyStationPage.js
import React, { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchUserData } from '../store/userSlice';
import './DailyStation.css';

const DailyStationPage = () => {
  const dispatch = useDispatch();
  const {
    userId,
    coins,
    username
  } = useSelector((state) => state.user);

  // States for daily bonus
  const [loadingBonus, setLoadingBonus] = useState(false);
  const [bonusError, setBonusError] = useState(null);
  const [dailyClaimed, setDailyClaimed] = useState(false);
  const [bonusCountdown, setBonusCountdown] = useState(0);

  // States for daily question
  const [loadingQuestion, setLoadingQuestion] = useState(true);
  const [questionData, setQuestionData] = useState(null); // { prompt, options, alreadyAnswered, userAnswer }
  const [qError, setQError] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [submitResult, setSubmitResult] = useState(null);

  useEffect(() => {
    if (userId) {
      dispatch(fetchUserData(userId));
      fetchDailyQuestion();
    }
  // eslint-disable-next-line
  }, [userId]);

  // ~~~~~~~~~~~~~~~~~~~~~
  // Daily Bonus Logic
  // ~~~~~~~~~~~~~~~~~~~~~
  const claimDailyBonus = async () => {
    if (!userId) {
      setBonusError("Please log in first.");
      return;
    }
    setLoadingBonus(true);
    setBonusError(null);
    try {
      const res = await fetch(`/api/test/user/${userId}/daily-bonus`, {
        method: "POST"
      });
      const data = await res.json();
      setLoadingBonus(false);

      if (res.ok && data.success) {
        setDailyClaimed(true);
        dispatch(fetchUserData(userId));
      } else {
        setBonusError(data.message || "Failed to claim daily bonus.");
      }
    } catch (err) {
      setBonusError("Error claiming daily bonus: " + err.message);
      setLoadingBonus(false);
    }
  };

  // e.g. handle countdown to next claim...
  // omitted for brevity. Same logic as prior snippet.

  // ~~~~~~~~~~~~~~~~~~~~~
  // Daily Question Logic
  // ~~~~~~~~~~~~~~~~~~~~~
  const fetchDailyQuestion = async () => {
    if (!userId) return;
    setLoadingQuestion(true);
    setQError(null);
    try {
      const res = await fetch(`/api/test/daily-question?userId=${userId}`);
      const data = await res.json();
      setLoadingQuestion(false);

      if (!res.ok) {
        setQError(data.error || "Failed to load daily question");
        return;
      }
      setQuestionData(data);
    } catch (err) {
      setQError("Error fetching daily question: " + err.message);
      setLoadingQuestion(false);
    }
  };

  const submitDailyAnswer = async () => {
    if (!userId || !questionData) return;
    if (questionData.alreadyAnswered) {
      setQError("You already answered today’s question!");
      return;
    }
    if (selectedAnswer === null) {
      setQError("Please select an answer.");
      return;
    }
    setQError(null);
    try {
      const body = {
        userId,
        dayIndex: questionData.dayIndex,
        selectedIndex: selectedAnswer
      };
      const res = await fetch('/api/test/daily-question/answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const answerData = await res.json();
      if (!res.ok) {
        setQError(answerData.error || "Error submitting answer.");
      } else {
        setSubmitResult(answerData);
        // e.g. if correct => answerData.correct = true
        // if you want to reflect new coin total:
        dispatch(fetchUserData(userId));
        // re-fetch question so "alreadyAnswered" is updated
        fetchDailyQuestion();
      }
    } catch (err) {
      setQError("Error submitting daily answer: " + err.message);
    }
  };

  // ~~~~~~~~~~~~~~~~~~~~~
  // Render daily question portion
  // ~~~~~~~~~~~~~~~~~~~~~
  const renderDailyQuestion = () => {
    if (loadingQuestion) {
      return <p>Loading the daily question...</p>;
    }
    if (qError) {
      return <p style={{ color: 'red' }}>{qError}</p>;
    }
    if (!questionData) {
      return <p>No daily question data found.</p>;
    }

    const { prompt, options, alreadyAnswered, userAnswer } = questionData;
    // if userAnswer is not null => user answered
    // if submitResult is set => show "You got 250 coins" or "you got 50 coins"

    return (
      <div className="daily-question-box">
        <h2>Daily PBQ Challenge</h2>
        <p>{prompt}</p>
        {alreadyAnswered ? (
          <div>
            <p>You have answered this question today.</p>
            {submitResult && (
              <p>
                {submitResult.correct
                  ? `You got it right! Awarded ${submitResult.awardedCoins} coins.`
                  : `Nice try. You still got ${submitResult.awardedCoins} coins.`}
              </p>
            )}
          </div>
        ) : (
          <div>
            <p>Select your answer:</p>
            <ul>
              {options.map((opt, idx) => (
                <li key={idx}>
                  <label>
                    <input
                      type="radio"
                      name="dailyQuestion"
                      value={idx}
                      checked={selectedAnswer === idx}
                      onChange={() => setSelectedAnswer(idx)}
                    />
                    {opt}
                  </label>
                </li>
              ))}
            </ul>
            <button onClick={submitDailyAnswer}>Submit Answer</button>
          </div>
        )}
      </div>
    );
  };

  // ~~~~~~~~~~~~~~~~~~~~~
  // Return
  // ~~~~~~~~~~~~~~~~~~~~~
  return (
    <div className="daily-station-container">
      <h1 className="daily-station-title">Daily Station</h1>
      <p>Welcome, {username}. You have {coins} coins.</p>

      {/* Daily Bonus Section */}
      <div className="daily-bonus-section">
        <h2>Daily 1000 Coin Bonus</h2>
        {bonusError && <p style={{ color: "red" }}>{bonusError}</p>}
        {/* Example logic: if user can claim => show button, else show countdown or msg */}
        <button onClick={claimDailyBonus} disabled={loadingBonus || dailyClaimed}>
          {dailyClaimed ? "Claimed!" : "Claim 1000 Coins"}
        </button>
      </div>

      {/* Daily Question Section */}
      {renderDailyQuestion()}

    </div>
  );
};

export default DailyStationPage;
Here we do the following:

We fetch the daily question from the route GET /api/test/daily-question?userId=....
If not answered, user picks an option and clicks “Submit Answer.”
We call POST /api/test/daily-question/answer with user’s choice.
We show the result (winning 250 or 50 coins).
This daily question changes automatically every day (based on your day index logic in the backend).
4) Add to Sidebar and App.js
As explained in the prior answer, you can add:

jsx
Copy
Edit
// Sidebar.js snippet
<li>
  <NavLink to="/daily" className={({ isActive }) => isActive ? 'active-link' : ''}>
    /Daily Station
  </NavLink>
</li>
In App.js:

jsx
Copy
Edit
// ...
import DailyStationPage from './components/pages/DailyStation/DailyStationPage';
// ...
<Route path="/daily" element={
  <ProtectedRoute>
    <DailyStationPage />
  </ProtectedRoute>
}/>
Now you have a single page with both:

The daily coin bonus.
The daily PBQ question.
All users see the same question each day, but each user’s answer attempt is tracked individually. The question auto‐rotates every 24 hours for everyone.

5) Summary of “Flow”
Each day, the server’s code calculates dayIndex = (today - startDate).days.
The user visits “/daily.” The front end calls GET /daily-question?userId=xxx.
The server returns the doc from dailyQuestions where dayIndex = dayIndex.
If user hasn’t answered, front end shows the question and possible answers. If user answered, it says “You already answered.”
Submitting an answer calls POST /daily-question/answer => awards coins.
The daily coin bonus remains your same approach (/user/<user_id>/daily-bonus), with a 24hr check in your DB’s user doc.
Done! This approach gives you:

A global daily question that changes on a 24‐hour schedule.
Per‐user coin rewards.
The daily bonus claim.
When you want to add 100 questions, just insert them into dailyQuestions with dayIndex = 0..99 (or however many). Each day dayIndex increments by 1. Once you pass dayIndex=99, either you can cycle back to 0 or keep going if you have 200, 300, etc.

That’s it. You now have a “Daily Station” featuring both a daily coin bonus and a daily PBQ question for your entire user base. Enjoy!
